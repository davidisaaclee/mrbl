(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.0.2
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function() {
        process.nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertx() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      var enumerator = this;

      enumerator._instanceConstructor = Constructor;
      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (enumerator._validateInput(input)) {
        enumerator._input     = input;
        enumerator.length     = input.length;
        enumerator._remaining = input.length;

        enumerator._init();

        if (enumerator.length === 0) {
          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
        } else {
          enumerator.length = enumerator.length || 0;
          enumerator._enumerate();
          if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
      }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$es6$promise$utils$$isArray(input);
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var enumerator = this;

      var length  = enumerator.length;
      var promise = enumerator.promise;
      var input   = enumerator._input;

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        enumerator._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var enumerator = this;
      var c = enumerator._instanceConstructor;

      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
          entry._onerror = null;
          enumerator._settledAt(entry._state, i, entry._result);
        } else {
          enumerator._willSettleAt(c.resolve(entry), i);
        }
      } else {
        enumerator._remaining--;
        enumerator._result[i] = entry;
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var enumerator = this;
      var promise = enumerator.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        enumerator._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          enumerator._result[i] = value;
        }
      }

      if (enumerator._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!lib$es6$promise$utils$$isArray(entries)) {
        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$es6$promise$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$es6$promise$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this._id = lib$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        if (!lib$es6$promise$utils$$isFunction(resolver)) {
          lib$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
          lib$es6$promise$promise$$needsNew();
        }

        lib$es6$promise$$internal$$initializePromise(this, resolver);
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor(lib$es6$promise$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          lib$es6$promise$asap$$asap(function(){
            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":2}],4:[function(require,module,exports){
/*!
 * Object.observe polyfill - v0.2.4
 * by Massimo Artizzu (MaxArt2501)
 * 
 * https://github.com/MaxArt2501/object-observe
 * 
 * Licensed under the MIT License
 * See LICENSE for details
 */

// Some type definitions
/**
 * This represents the data relative to an observed object
 * @typedef  {Object}                     ObjectData
 * @property {Map<Handler, HandlerData>}  handlers
 * @property {String[]}                   properties
 * @property {*[]}                        values
 * @property {Descriptor[]}               descriptors
 * @property {Notifier}                   notifier
 * @property {Boolean}                    frozen
 * @property {Boolean}                    extensible
 * @property {Object}                     proto
 */
/**
 * Function definition of a handler
 * @callback Handler
 * @param {ChangeRecord[]}                changes
*/
/**
 * This represents the data relative to an observed object and one of its
 * handlers
 * @typedef  {Object}                     HandlerData
 * @property {Map<Object, ObservedData>}  observed
 * @property {ChangeRecord[]}             changeRecords
 */
/**
 * @typedef  {Object}                     ObservedData
 * @property {String[]}                   acceptList
 * @property {ObjectData}                 data
*/
/**
 * Type definition for a change. Any other property can be added using
 * the notify() or performChange() methods of the notifier.
 * @typedef  {Object}                     ChangeRecord
 * @property {String}                     type
 * @property {Object}                     object
 * @property {String}                     [name]
 * @property {*}                          [oldValue]
 * @property {Number}                     [index]
 */
/**
 * Type definition for a notifier (what Object.getNotifier returns)
 * @typedef  {Object}                     Notifier
 * @property {Function}                   notify
 * @property {Function}                   performChange
 */
/**
 * Function called with Notifier.performChange. It may optionally return a
 * ChangeRecord that gets automatically notified, but `type` and `object`
 * properties are overridden.
 * @callback Performer
 * @returns {ChangeRecord|undefined}
 */

Object.observe || (function(O, A, root) {
    "use strict";

        /**
         * Relates observed objects and their data
         * @type {Map<Object, ObjectData}
         */
    var observed,
        /**
         * List of handlers and their data
         * @type {Map<Handler, Map<Object, HandlerData>>}
         */
        handlers,

        defaultAcceptList = [ "add", "update", "delete", "reconfigure", "setPrototype", "preventExtensions" ];

    // Functions for internal usage

        /**
         * Checks if the argument is an Array object. Polyfills Array.isArray.
         * @function isArray
         * @param {?*} object
         * @returns {Boolean}
         */
    var isArray = A.isArray || (function(toString) {
            return function (object) { return toString.call(object) === "[object Array]"; };
        })(O.prototype.toString),

        /**
         * Returns the index of an item in a collection, or -1 if not found.
         * Uses the generic Array.indexOf or Array.prototype.indexOf if available.
         * @function inArray
         * @param {Array} array
         * @param {*} pivot           Item to look for
         * @param {Number} [start=0]  Index to start from
         * @returns {Number}
         */
        inArray = A.prototype.indexOf ? A.indexOf || function(array, pivot, start) {
            return A.prototype.indexOf.call(array, pivot, start);
        } : function(array, pivot, start) {
            for (var i = start || 0; i < array.length; i++)
                if (array[i] === pivot)
                    return i;
            return -1;
        },

        /**
         * Returns an instance of Map, or a Map-like object is Map is not
         * supported or doesn't support forEach()
         * @function createMap
         * @returns {Map}
         */
        createMap = typeof root.Map === "undefined" || !Map.prototype.forEach ? function() {
            // Lightweight shim of Map. Lacks clear(), entries(), keys() and
            // values() (the last 3 not supported by IE11, so can't use them),
            // it doesn't handle the constructor's argument (like IE11) and of
            // course it doesn't support for...of.
            // Chrome 31-35 and Firefox 13-24 have a basic support of Map, but
            // they lack forEach(), so their native implementation is bad for
            // this polyfill. (Chrome 36+ supports Object.observe.)
            var keys = [], values = [];

            return {
                size: 0,
                has: function(key) { return inArray(keys, key) > -1; },
                get: function(key) { return values[inArray(keys, key)]; },
                set: function(key, value) {
                    var i = inArray(keys, key);
                    if (i === -1) {
                        keys.push(key);
                        values.push(value);
                        this.size++;
                    } else values[i] = value;
                },
                "delete": function(key) {
                    var i = inArray(keys, key);
                    if (i > -1) {
                        keys.splice(i, 1);
                        values.splice(i, 1);
                        this.size--;
                    }
                },
                forEach: function(callback/*, thisObj*/) {
                    for (var i = 0; i < keys.length; i++)
                        callback.call(arguments[1], values[i], keys[i], this);
                }
            };
        } : function() { return new Map(); },

        /**
         * Simple shim for Object.getOwnPropertyNames when is not available
         * Misses checks on object, don't use as a replacement of Object.keys/getOwnPropertyNames
         * @function getProps
         * @param {Object} object
         * @returns {String[]}
         */
        getProps = O.getOwnPropertyNames ? (function() {
            var func = O.getOwnPropertyNames;
            try {
                arguments.callee;
            } catch (e) {
                // Strict mode is supported

                // In strict mode, we can't access to "arguments", "caller" and
                // "callee" properties of functions. Object.getOwnPropertyNames
                // returns [ "prototype", "length", "name" ] in Firefox; it returns
                // "caller" and "arguments" too in Chrome and in Internet
                // Explorer, so those values must be filtered.
                var avoid = (func(inArray).join(" ") + " ").replace(/prototype |length |name /g, "").slice(0, -1).split(" ");
                if (avoid.length) func = function(object) {
                    var props = O.getOwnPropertyNames(object);
                    if (typeof object === "function")
                        for (var i = 0, j; i < avoid.length;)
                            if ((j = inArray(props, avoid[i++])) > -1)
                                props.splice(j, 1);

                    return props;
                };
            }
            return func;
        })() : function(object) {
            // Poor-mouth version with for...in (IE8-)
            var props = [], prop, hop;
            if ("hasOwnProperty" in object) {
                for (prop in object)
                    if (object.hasOwnProperty(prop))
                        props.push(prop);
            } else {
                hop = O.hasOwnProperty;
                for (prop in object)
                    if (hop.call(object, prop))
                        props.push(prop);
            }

            // Inserting a common non-enumerable property of arrays
            if (isArray(object))
                props.push("length");

            return props;
        },

        /**
         * Return the prototype of the object... if defined.
         * @function getPrototype
         * @param {Object} object
         * @returns {Object}
         */
        getPrototype = O.getPrototypeOf,

        /**
         * Return the descriptor of the object... if defined.
         * IE8 supports a (useless) Object.getOwnPropertyDescriptor for DOM
         * nodes only, so defineProperties is checked instead.
         * @function getDescriptor
         * @param {Object} object
         * @param {String} property
         * @returns {Descriptor}
         */
        getDescriptor = O.defineProperties && O.getOwnPropertyDescriptor,

        /**
         * Sets up the next check and delivering iteration, using
         * requestAnimationFrame or a (close) polyfill.
         * @function nextFrame
         * @param {function} func
         * @returns {number}
         */
        nextFrame = root.requestAnimationFrame || root.webkitRequestAnimationFrame || (function() {
            var initial = +new Date,
                last = initial;
            return function(func) {
                return setTimeout(function() {
                    func((last = +new Date) - initial);
                }, 17);
            };
        })(),

        /**
         * Sets up the observation of an object
         * @function doObserve
         * @param {Object} object
         * @param {Handler} handler
         * @param {String[]} [acceptList]
         */
        doObserve = function(object, handler, acceptList) {

            var data = observed.get(object);

            if (data)
                setHandler(object, data, handler, acceptList);
            else {
                data = createObjectData(object);
                setHandler(object, data, handler, acceptList);
                
                if (observed.size === 1)
                    // Let the observation begin!
                    nextFrame(runGlobalLoop);
            }
        },

        /**
         * Creates the initial data for an observed object
         * @function createObjectData
         * @param {Object} object
         */
        createObjectData = function(object, data) {
            var props = getProps(object),
                values = [], descs, i = 0,
                data = {
                    handlers: createMap(),
                    frozen: O.isFrozen ? O.isFrozen(object) : false,
                    extensible: O.isExtensible ? O.isExtensible(object) : true,
                    proto: getPrototype && getPrototype(object),
                    properties: props,
                    values: values,
                    notifier: retrieveNotifier(object, data)
                };

            if (getDescriptor) {
                descs = data.descriptors = [];
                while (i < props.length) {
                    descs[i] = getDescriptor(object, props[i]);
                    values[i] = object[props[i++]];
                }
            } else while (i < props.length)
                values[i] = object[props[i++]];

            observed.set(object, data);

            return data;
        },

        /**
         * Performs basic property value change checks on an observed object
         * @function performPropertyChecks
         * @param {ObjectData} data
         * @param {Object} object
         * @param {String} [except]  Doesn't deliver the changes to the
         *                           handlers that accept this type
         */
        performPropertyChecks = (function() {
            var updateCheck = getDescriptor ? function(object, data, idx, except, descr) {
                var key = data.properties[idx],
                    value = object[key],
                    ovalue = data.values[idx],
                    odesc = data.descriptors[idx];

                if ("value" in descr && (ovalue === value
                        ? ovalue === 0 && 1/ovalue !== 1/value 
                        : ovalue === ovalue || value === value)) {
                    addChangeRecord(object, data, {
                        name: key,
                        type: "update",
                        object: object,
                        oldValue: ovalue
                    }, except);
                    data.values[idx] = value;
                }
                if (odesc.configurable && (!descr.configurable
                        || descr.writable !== odesc.writable
                        || descr.enumerable !== odesc.enumerable
                        || descr.get !== odesc.get
                        || descr.set !== odesc.set)) {
                    addChangeRecord(object, data, {
                        name: key,
                        type: "reconfigure",
                        object: object,
                        oldValue: ovalue
                    }, except);
                    data.descriptors[idx] = descr;
                }
            } : function(object, data, idx, except) {
                var key = data.properties[idx],
                    value = object[key],
                    ovalue = data.values[idx];

                if (ovalue === value ? ovalue === 0 && 1/ovalue !== 1/value 
                        : ovalue === ovalue || value === value) {
                    addChangeRecord(object, data, {
                        name: key,
                        type: "update",
                        object: object,
                        oldValue: ovalue
                    }, except);
                    data.values[idx] = value;
                }
            };

            // Checks if some property has been deleted
            var deletionCheck = getDescriptor ? function(object, props, proplen, data, except) {
                var i = props.length, descr;
                while (proplen && i--) {
                    if (props[i] !== null) {
                        descr = getDescriptor(object, props[i]);
                        proplen--;

                        // If there's no descriptor, the property has really
                        // been deleted; otherwise, it's been reconfigured so
                        // that's not enumerable anymore
                        if (descr) updateCheck(object, data, i, except, descr);
                        else {
                            addChangeRecord(object, data, {
                                name: props[i],
                                type: "delete",
                                object: object,
                                oldValue: data.values[i]
                            }, except);
                            data.properties.splice(i, 1);
                            data.values.splice(i, 1);
                            data.descriptors.splice(i, 1);
                        }
                    }
                }
            } : function(object, props, proplen, data, except) {
                var i = props.length;
                while (proplen && i--)
                    if (props[i] !== null) {
                        addChangeRecord(object, data, {
                            name: props[i],
                            type: "delete",
                            object: object,
                            oldValue: data.values[i]
                        }, except);
                        data.properties.splice(i, 1);
                        data.values.splice(i, 1);
                        proplen--;
                    }
            };

            return function(data, object, except) {
                if (!data.handlers.size || data.frozen) return;

                var props, proplen, keys,
                    values = data.values,
                    descs = data.descriptors,
                    i = 0, idx,
                    key, value,
                    proto, descr;

                // If the object isn't extensible, we don't need to check for new
                // or deleted properties
                if (data.extensible) {

                    props = data.properties.slice();
                    proplen = props.length;
                    keys = getProps(object);

                    if (descs) {
                        while (i < keys.length) {
                            key = keys[i++];
                            idx = inArray(props, key);
                            descr = getDescriptor(object, key);

                            if (idx === -1) {
                                addChangeRecord(object, data, {
                                    name: key,
                                    type: "add",
                                    object: object
                                }, except);
                                data.properties.push(key);
                                values.push(object[key]);
                                descs.push(descr);
                            } else {
                                props[idx] = null;
                                proplen--;
                                updateCheck(object, data, idx, except, descr);
                            }
                        }
                        deletionCheck(object, props, proplen, data, except);

                        if (!O.isExtensible(object)) {
                            data.extensible = false;
                            addChangeRecord(object, data, {
                                type: "preventExtensions",
                                object: object
                            }, except);

                            data.frozen = O.isFrozen(object);
                        }
                    } else {
                        while (i < keys.length) {
                            key = keys[i++];
                            idx = inArray(props, key);
                            value = object[key];

                            if (idx === -1) {
                                addChangeRecord(object, data, {
                                    name: key,
                                    type: "add",
                                    object: object
                                }, except);
                                data.properties.push(key);
                                values.push(value);
                            } else {
                                props[idx] = null;
                                proplen--;
                                updateCheck(object, data, idx, except);
                            }
                        }
                        deletionCheck(object, props, proplen, data, except);
                    }

                } else if (!data.frozen) {

                    // If the object is not extensible, but not frozen, we just have
                    // to check for value changes
                    for (; i < props.length; i++) {
                        key = props[i];
                        updateCheck(object, data, i, except, getDescriptor(object, key));
                    }

                    if (O.isFrozen(object))
                        data.frozen = true;
                }

                if (getPrototype) {
                    proto = getPrototype(object);
                    if (proto !== data.proto) {
                        addChangeRecord(object, data, {
                            type: "setPrototype",
                            name: "__proto__",
                            object: object,
                            oldValue: data.proto
                        });
                        data.proto = proto;
                    }
                }
            };
        })(),

        /**
         * Sets up the main loop for object observation and change notification
         * It stops if no object is observed.
         * @function runGlobalLoop
         */
        runGlobalLoop = function() {
            if (observed.size) {
                observed.forEach(performPropertyChecks);
                handlers.forEach(deliverHandlerRecords);
                nextFrame(runGlobalLoop);
            }
        },

        /**
         * Deliver the change records relative to a certain handler, and resets
         * the record list.
         * @param {HandlerData} hdata
         * @param {Handler} handler
         */
        deliverHandlerRecords = function(hdata, handler) {
            if (hdata.changeRecords.length) {
                handler(hdata.changeRecords);
                hdata.changeRecords = [];
            }
        },

        /**
         * Returns the notifier for an object - whether it's observed or not
         * @function retrieveNotifier
         * @param {Object} object
         * @param {ObjectData} [data]
         * @returns {Notifier}
         */
        retrieveNotifier = function(object, data) {
            if (arguments.length < 2)
                data = observed.get(object);

            /** @type {Notifier} */
            return data && data.notifier || {
                /**
                 * @method notify
                 * @see http://arv.github.io/ecmascript-object-observe/#notifierprototype._notify
                 * @memberof Notifier
                 * @param {ChangeRecord} changeRecord
                 */
                notify: function(changeRecord) {
                    changeRecord.type; // Just to check the property is there...

                    // If there's no data, the object has been unobserved
                    var data = observed.get(object);
                    if (data) {
                        var recordCopy = { object: object }, prop;
                        for (prop in changeRecord)
                            if (prop !== "object")
                                recordCopy[prop] = changeRecord[prop];
                        addChangeRecord(object, data, recordCopy);
                    }
                },

                /**
                 * @method performChange
                 * @see http://arv.github.io/ecmascript-object-observe/#notifierprototype_.performchange
                 * @memberof Notifier
                 * @param {String} changeType
                 * @param {Performer} func     The task performer
                 * @param {*} [thisObj]        Used to set `this` when calling func
                 */
                performChange: function(changeType, func/*, thisObj*/) {
                    if (typeof changeType !== "string")
                        throw new TypeError("Invalid non-string changeType");

                    if (typeof func !== "function")
                        throw new TypeError("Cannot perform non-function");

                    // If there's no data, the object has been unobserved
                    var data = observed.get(object),
                        prop, changeRecord,
                        result = func.call(arguments[2]);

                    data && performPropertyChecks(data, object, changeType);

                    // If there's no data, the object has been unobserved
                    if (data && result && typeof result === "object") {
                        changeRecord = { object: object, type: changeType };
                        for (prop in result)
                            if (prop !== "object" && prop !== "type")
                                changeRecord[prop] = result[prop];
                        addChangeRecord(object, data, changeRecord);
                    }
                }
            };
        },

        /**
         * Register (or redefines) an handler in the collection for a given
         * object and a given type accept list.
         * @function setHandler
         * @param {Object} object
         * @param {ObjectData} data
         * @param {Handler} handler
         * @param {String[]} acceptList
         */
        setHandler = function(object, data, handler, acceptList) {
            var hdata = handlers.get(handler);
            if (!hdata)
                handlers.set(handler, hdata = {
                    observed: createMap(),
                    changeRecords: []
                });
            hdata.observed.set(object, {
                acceptList: acceptList.slice(),
                data: data
            });
            data.handlers.set(handler, hdata);
        },

        /**
         * Adds a change record in a given ObjectData
         * @function addChangeRecord
         * @param {Object} object
         * @param {ObjectData} data
         * @param {ChangeRecord} changeRecord
         * @param {String} [except]
         */
        addChangeRecord = function(object, data, changeRecord, except) {
            data.handlers.forEach(function(hdata) {
                var acceptList = hdata.observed.get(object).acceptList;
                // If except is defined, Notifier.performChange has been
                // called, with except as the type.
                // All the handlers that accepts that type are skipped.
                if ((typeof except !== "string"
                        || inArray(acceptList, except) === -1)
                        && inArray(acceptList, changeRecord.type) > -1)
                    hdata.changeRecords.push(changeRecord);
            });
        };

    observed = createMap();
    handlers = createMap();

    /**
     * @function Object.observe
     * @see http://arv.github.io/ecmascript-object-observe/#Object.observe
     * @param {Object} object
     * @param {Handler} handler
     * @param {String[]} [acceptList]
     * @throws {TypeError}
     * @returns {Object}               The observed object
     */
    O.observe = function observe(object, handler, acceptList) {
        if (!object || typeof object !== "object" && typeof object !== "function")
            throw new TypeError("Object.observe cannot observe non-object");

        if (typeof handler !== "function")
            throw new TypeError("Object.observe cannot deliver to non-function");

        if (O.isFrozen && O.isFrozen(handler))
            throw new TypeError("Object.observe cannot deliver to a frozen function object");

        if (typeof acceptList === "undefined")
            acceptList = defaultAcceptList;
        else if (!acceptList || typeof acceptList !== "object")
            throw new TypeError("Third argument to Object.observe must be an array of strings.");

        doObserve(object, handler, acceptList);

        return object;
    };

    /**
     * @function Object.unobserve
     * @see http://arv.github.io/ecmascript-object-observe/#Object.unobserve
     * @param {Object} object
     * @param {Handler} handler
     * @throws {TypeError}
     * @returns {Object}         The given object
     */
    O.unobserve = function unobserve(object, handler) {
        if (object === null || typeof object !== "object" && typeof object !== "function")
            throw new TypeError("Object.unobserve cannot unobserve non-object");

        if (typeof handler !== "function")
            throw new TypeError("Object.unobserve cannot deliver to non-function");

        var hdata = handlers.get(handler), odata;

        if (hdata && (odata = hdata.observed.get(object))) {
            hdata.observed.forEach(function(odata, object) {
                performPropertyChecks(odata.data, object);
            });
            nextFrame(function() {
                deliverHandlerRecords(hdata, handler);
            });

            // In Firefox 13-18, size is a function, but createMap should fall
            // back to the shim for those versions
            if (hdata.observed.size === 1 && hdata.observed.has(object))
                handlers["delete"](handler);
            else hdata.observed["delete"](object);

            if (odata.data.handlers.size === 1)
                observed["delete"](object);
            else odata.data.handlers["delete"](handler);
        }

        return object;
    };

    /**
     * @function Object.getNotifier
     * @see http://arv.github.io/ecmascript-object-observe/#GetNotifier
     * @param {Object} object
     * @throws {TypeError}
     * @returns {Notifier}
     */
    O.getNotifier = function getNotifier(object) {
        if (object === null || typeof object !== "object" && typeof object !== "function")
            throw new TypeError("Object.getNotifier cannot getNotifier non-object");

        if (O.isFrozen && O.isFrozen(object)) return null;

        return retrieveNotifier(object);
    };

    /**
     * @function Object.deliverChangeRecords
     * @see http://arv.github.io/ecmascript-object-observe/#Object.deliverChangeRecords
     * @see http://arv.github.io/ecmascript-object-observe/#DeliverChangeRecords
     * @param {Handler} handler
     * @throws {TypeError}
     */
    O.deliverChangeRecords = function deliverChangeRecords(handler) {
        if (typeof handler !== "function")
            throw new TypeError("Object.deliverChangeRecords cannot deliver to non-function");

        var hdata = handlers.get(handler);
        if (hdata) {
            hdata.observed.forEach(function(odata, object) {
                performPropertyChecks(odata.data, object);
            });
            deliverHandlerRecords(hdata, handler);
        }
    };

})(Object, Array, this);
},{}],5:[function(require,module,exports){
module.exports = require("./lib/$EventTarget.js");
},{"./lib/$EventTarget.js":6}],6:[function(require,module,exports){
/**
	$EventTarget mixin
	@author Bart Van Beurden
	@date 26/01/2014
**/

/**
	Events dispatched by $EventTarget have 3 properties:
	- type (string)
	- target (event source)
	- data (user-provided)
**/
var Event = function(type, target, data) {
	this.type = type;
	this.target = target;
	this.data = data;
};

/**
	$EventTarget mixin
	Extends an object with EventTarget methods
	(adds #addEventListener, #removeEventListener, #dispatchEvent)
	@param obj The object to extend
**/
module.exports = function(obj) {

	obj._listeners = {};
	var proto = Object.getPrototypeOf(obj);
	
	// if necessary, extend prototype
	if (!proto.addEventListener) {
	
		/**
			$EventTarget#addEventListener
			@param type The event Type to listen to
			@param callback(event) The listener function
			@returns this
		**/
		Object.defineProperty(proto, "addEventListener", { value: function(type, callback) {
			console.assert(typeof type == "string", "$EventTarget#addEventListener - type must be string");
			console.assert(typeof callback == "function", "$EventTarget#addEventListener - callback must be function");
			
			var listeners = this._listeners[type];
			if (!listeners) listeners = this._listeners[type] = [];
			listeners.push(callback);
			return this;
		}});
		
		/**
			$EventTarget#removeEventListener
			@param type The event Type to remove
			@param callback(event) The listener function to remove
			@returns this
		**/
		Object.defineProperty(proto, "removeEventListener", { value: function(type, callback) {
			console.assert(typeof type == "string", "$EventTarget#removeEventListener - type must be string");
			console.assert(typeof callback == "function", "$EventTarget#removeEventListener - callback must be function");
			
			var listeners = this._listeners[type];
			if (listeners) {
				var index = listeners.indexOf(callback);
				if (index != -1) {
					listeners.splice(index, 1);
					if (listeners.length == 0) delete this._listeners[type];
				}
			}
			return this;
		}});
		
		Object.defineProperty(proto, "clearEventListeners", { value: function(type) {
			
			if (arguments.length == 0) {
				this._listeners = {};
			} else {
				delete this._listeners[type];
			}
			return this;
		}});
		
		var dispatcher = function(event) { 
			return function(callback) { 
				callback(event);
			};
		};
		
		/**
			$EventTarget#dispatchEvent
			@param type The type of the event to dispatch
			@param data [Optional] The data to pass to the listeners
		**/
		Object.defineProperty(proto, "dispatchEvent", { value: function(type, data) {
			console.assert(typeof type == "string", "$EventTarget#dispatchEvent - type must be string");
			
			(this._listeners[type] || []).forEach(dispatcher(new Event(type, this, data)));
		}});
	};
	
	return obj;

};
},{}],7:[function(require,module,exports){
/*!
 * Paper.js v0.9.24 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & http://jonathanpuckey.com/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Fri Aug 21 16:39:41 2015 +0200
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2013 Juerg Lehni
 * http://scratchdisk.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * http://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = new function(undefined) {

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,

		forEach = [].forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++)
				iter.call(bind, this[i], i, this);
		},

		forIn = function(iter, bind) {
			for (var i in this)
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
		},

		create = Object.create || function(proto) {
			return { __proto__: proto };
		},

		describe = Object.getOwnPropertyDescriptor || function(obj, name) {
			var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
			return get
					? { get: get, set: obj.__lookupSetter__(name),
						enumerable: true, configurable: true }
					: obj.hasOwnProperty(name)
						? { value: obj[name], enumerable: true,
							configurable: true, writable: true }
						: null;
		},

		_define = Object.defineProperty || function(obj, name, desc) {
			if ((desc.get || desc.set) && obj.__defineGetter__) {
				if (desc.get)
					obj.__defineGetter__(name, desc.get);
				if (desc.set)
					obj.__defineSetter__(name, desc.set);
			} else {
				obj[name] = desc.value;
			}
			return obj;
		},

		define = function(obj, name, desc) {
			delete obj[name];
			return _define(obj, name, desc);
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc && !val.base
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res))
					res = { value: res, writable: true };
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function each(obj, iter, bind) {
		if (obj)
			('length' in obj && !obj.getLength
					&& typeof obj.length === 'number'
				? forEach
				: forIn).call(obj, iter, bind = bind || obj);
		return bind;
	}

	function set(obj, props, exclude) {
		for (var key in props)
			if (props.hasOwnProperty(key) && !(exclude && exclude[key]))
				obj[key] = props[key];
		return obj;
	}

	return inject(function Base() {
		for (var i = 0, l = arguments.length; i < l; i++)
			set(this, arguments[i]);
	}, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, true, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor,
				proto;
			for (var i = 0, l = arguments.length; i < l; i++)
				if (ctor = arguments[i].initialize)
					break;
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			proto = ctor.prototype = create(this.prototype);
			define(proto, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this, true);
			if (arguments.length)
				this.inject.apply(ctor, arguments);
			ctor.base = base;
			return ctor;
		}
	}, true).inject({
		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src)
					inject(this, src, src.enumerable, src.beans, src.preserve);
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		set: function(props) {
			return set(this, props);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			each: each,
			create: create,
			define: define,
			describe: describe,
			set: set,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function(a, b) {
				return a !== undefined ? a : b;
			}
		}
	});
};

if (typeof module !== 'undefined')
	module.exports = Base;

Base.inject({
	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	getClassName: function() {
		return this._class || '';
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	_set: function(props, exclude, dontCheck) {
		if (props && (dontCheck || Base.isPlainObject(props))) {
			var keys = Object.keys(props._filtering || props);
			for (var i = 0, l = keys.length; i < l; i++) {
				var key = keys[i];
				if (!(exclude && exclude[key])) {
					var value = props[key];
					if (value !== undefined)
						this[key] = value;
				}
			}
			return true;
		}
	},

	statics: {

		exports: {
			enumerable: true
		},

		extend: function extend() {
			var res = extend.base.apply(this, arguments),
				name = res.prototype._class;
			if (name && !Base.exports[name])
				Base.exports[name] = res;
			return res;
		},

		equals: function(obj1, obj2) {
			if (obj1 === obj2)
				return true;
			if (obj1 && obj1.equals)
				return obj1.equals(obj2);
			if (obj2 && obj2.equals)
				return obj2.equals(obj1);
			if (obj1 && obj2
					&& typeof obj1 === 'object' && typeof obj2 === 'object') {
				if (Array.isArray(obj1) && Array.isArray(obj2)) {
					var length = obj1.length;
					if (length !== obj2.length)
						return false;
					while (length--) {
						if (!Base.equals(obj1[length], obj2[length]))
							return false;
					}
				} else {
					var keys = Object.keys(obj1),
						length = keys.length;
					if (length !== Object.keys(obj2).length)
						return false;
					while (length--) {
						var key = keys[length];
						if (!(obj2.hasOwnProperty(key)
								&& Base.equals(obj1[key], obj2[key])))
							return false;
					}
				}
				return true;
			}
			return false;
		},

		read: function(list, start, options, length) {
			if (this === Base) {
				var value = this.peek(list, start);
				list.__index++;
				return value;
			}
			var proto = this.prototype,
				readIndex = proto._readIndex,
				index = start || readIndex && list.__index || 0;
			if (!length)
				length = list.length - index;
			var obj = list[index];
			if (obj instanceof this
				|| options && options.readNull && obj == null && length <= 1) {
				if (readIndex)
					list.__index = index + 1;
				return obj && options && options.clone ? obj.clone() : obj;
			}
			obj = Base.create(this.prototype);
			if (readIndex)
				obj.__read = true;
			obj = obj.initialize.apply(obj, index > 0 || length < list.length
				? Array.prototype.slice.call(list, index, index + length)
				: list) || obj;
			if (readIndex) {
				list.__index = index + obj.__read;
				obj.__read = undefined;
			}
			return obj;
		},

		peek: function(list, start) {
			return list[list.__index = start || list.__index || 0];
		},

		remain: function(list) {
			return list.length - (list.__index || 0);
		},

		readAll: function(list, start, options) {
			var res = [],
				entry;
			for (var i = start || 0, l = list.length; i < l; i++) {
				res.push(Array.isArray(entry = list[i])
						? this.read(entry, 0, options)
						: this.read(list, i, options, 1));
			}
			return res;
		},

		readNamed: function(list, name, start, options, length) {
			var value = this.getNamed(list, name),
				hasObject = value !== undefined;
			if (hasObject) {
				var filtered = list._filtered;
				if (!filtered) {
					filtered = list._filtered = Base.create(list[0]);
					filtered._filtering = list[0];
				}
				filtered[name] = undefined;
			}
			return this.read(hasObject ? [value] : list, start, options, length);
		},

		getNamed: function(list, name) {
			var arg = list[0];
			if (list._hasObject === undefined)
				list._hasObject = list.length === 1 && Base.isPlainObject(arg);
			if (list._hasObject)
				return name ? arg[name] : list._filtered || arg;
		},

		hasNamed: function(list, name) {
			return !!this.getNamed(list, name);
		},

		isPlainValue: function(obj, asString) {
			return this.isPlainObject(obj) || Array.isArray(obj)
					|| asString && typeof obj === 'string';
		},

		serialize: function(obj, options, compact, dictionary) {
			options = options || {};

			var root = !dictionary,
				res;
			if (root) {
				options.formatter = new Formatter(options.precision);
				dictionary = {
					length: 0,
					definitions: {},
					references: {},
					add: function(item, create) {
						var id = '#' + item._id,
							ref = this.references[id];
						if (!ref) {
							this.length++;
							var res = create.call(item),
								name = item._class;
							if (name && res[0] !== name)
								res.unshift(name);
							this.definitions[id] = res;
							ref = this.references[id] = [id];
						}
						return ref;
					}
				};
			}
			if (obj && obj._serialize) {
				res = obj._serialize(options, dictionary);
				var name = obj._class;
				if (name && !compact && !res._compact && res[0] !== name)
					res.unshift(name);
			} else if (Array.isArray(obj)) {
				res = [];
				for (var i = 0, l = obj.length; i < l; i++)
					res[i] = Base.serialize(obj[i], options, compact,
							dictionary);
				if (compact)
					res._compact = true;
			} else if (Base.isPlainObject(obj)) {
				res = {};
				var keys = Object.keys(obj);
				for (var i = 0, l = keys.length; i < l; i++) {
					var key = keys[i];
					res[key] = Base.serialize(obj[key], options, compact,
							dictionary);
				}
			} else if (typeof obj === 'number') {
				res = options.formatter.number(obj, options.precision);
			} else {
				res = obj;
			}
			return root && dictionary.length > 0
					? [['dictionary', dictionary.definitions], res]
					: res;
		},

		deserialize: function(json, create, _data, _isDictionary) {
			var res = json,
				isRoot = !_data;
			_data = _data || {};
			if (Array.isArray(json)) {
				var type = json[0],
					isDictionary = type === 'dictionary';
				if (json.length == 1 && /^#/.test(type))
					return _data.dictionary[type];
				type = Base.exports[type];
				res = [];
				if (_isDictionary)
					_data.dictionary = res;
				for (var i = type ? 1 : 0, l = json.length; i < l; i++)
					res.push(Base.deserialize(json[i], create, _data,
							isDictionary));
				if (type) {
					var args = res;
					if (create) {
						res = create(type, args);
					} else {
						res = Base.create(type.prototype);
						type.apply(res, args);
					}
				}
			} else if (Base.isPlainObject(json)) {
				res = {};
				if (_isDictionary)
					_data.dictionary = res;
				for (var key in json)
					res[key] = Base.deserialize(json[key], create, _data);
			}
			return isRoot && json && json.length && json[0][0] === 'dictionary'
					? res[1]
					: res;
		},

		exportJSON: function(obj, options) {
			var json = Base.serialize(obj, options);
			return options && options.asString === false
					? json
					: JSON.stringify(json);
		},

		importJSON: function(json, target) {
			return Base.deserialize(
					typeof json === 'string' ? JSON.parse(json) : json,
					function(type, args) {
						var obj = target && target.constructor === type
								? target
								: Base.create(type.prototype),
							isTarget = obj === target;
						if (args.length === 1 && obj instanceof Item
								&& (isTarget || !(obj instanceof Layer))) {
							var arg = args[0];
							if (Base.isPlainObject(arg))
								arg.insert = false;
						}
						type.apply(obj, args);
						if (isTarget)
							target = null;
						return obj;
					});
		},

		splice: function(list, items, index, remove) {
			var amount = items && items.length,
				append = index === undefined;
			index = append ? list.length : index;
			if (index > list.length)
				index = list.length;
			for (var i = 0; i < amount; i++)
				items[i]._index = index + i;
			if (append) {
				list.push.apply(list, items);
				return [];
			} else {
				var args = [index, remove];
				if (items)
					args.push.apply(args, items);
				var removed = list.splice.apply(list, args);
				for (var i = 0, l = removed.length; i < l; i++)
					removed[i]._index = undefined;
				for (var i = index + amount, l = list.length; i < l; i++)
					list[i]._index = i;
				return removed;
			}
		},

		capitalize: function(str) {
			return str.replace(/\b[a-z]/g, function(match) {
				return match.toUpperCase();
			});
		},

		camelize: function(str) {
			return str.replace(/-(.)/g, function(all, chr) {
				return chr.toUpperCase();
			});
		},

		hyphenate: function(str) {
			return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
		}
	}
});

var Emitter = {
	on: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.on(key, value);
			}, this);
		} else {
			var types = this._eventTypes,
				entry = types && types[type],
				handlers = this._callbacks = this._callbacks || {};
			handlers = handlers[type] = handlers[type] || [];
			if (handlers.indexOf(func) === -1) {
				handlers.push(func);
				if (entry && entry.install && handlers.length == 1)
					entry.install.call(this, type);
			}
		}
		return this;
	},

	off: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.off(key, value);
			}, this);
			return;
		}
		var types = this._eventTypes,
			entry = types && types[type],
			handlers = this._callbacks && this._callbacks[type],
			index;
		if (handlers) {
			if (!func || (index = handlers.indexOf(func)) !== -1
					&& handlers.length === 1) {
				if (entry && entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._callbacks[type];
			} else if (index !== -1) {
				handlers.splice(index, 1);
			}
		}
		return this;
	},

	once: function(type, func) {
		return this.on(type, function() {
			func.apply(this, arguments);
			this.off(type, func);
		});
	},

	emit: function(type, event) {
		var handlers = this._callbacks && this._callbacks[type];
		if (!handlers)
			return false;
		var args = [].slice.call(arguments, 1);
		handlers = handlers.slice();
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(this, args) === false) {
				if (event && event.stop)
					event.stop();
				break;
			}
		}
		return true;
	},

	responds: function(type) {
		return !!(this._callbacks && this._callbacks[type]);
	},

	attach: '#on',
	detach: '#off',
	fire: '#emit',

	_installEvents: function(install) {
		var handlers = this._callbacks,
			key = install ? 'install' : 'uninstall';
		for (var type in handlers) {
			if (handlers[type].length > 0) {
				var types = this._eventTypes,
					entry = types && types[type],
					func = entry && entry[key];
				if (func)
					func.call(this, type);
			}
		}
	},

	statics: {
		inject: function inject(src) {
			var events = src._events;
			if (events) {
				var types = {};
				Base.each(events, function(entry, key) {
					var isString = typeof entry === 'string',
						name = isString ? entry : key,
						part = Base.capitalize(name),
						type = name.substring(2).toLowerCase();
					types[type] = isString ? {} : entry;
					name = '_' + name;
					src['get' + part] = function() {
						return this[name];
					};
					src['set' + part] = function(func) {
						var prev = this[name];
						if (prev)
							this.off(type, prev);
						if (func)
							this.on(type, func);
						this[name] = func;
					};
				});
				src._eventTypes = types;
			}
			return inject.base.apply(this, arguments);
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope() {
		paper = this;
		this.settings = new Base({
			applyMatrix: true,
			handleSize: 4,
			hitTolerance: 0
		});
		this.project = null;
		this.projects = [];
		this.tools = [];
		this.palettes = [];
		this._id = PaperScope._id++;
		PaperScope._scopes[this._id] = this;
		var proto = PaperScope.prototype;
		if (!this.support) {
			var ctx = CanvasProvider.getContext(1, 1);
			proto.support = {
				nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
				nativeBlendModes: BlendMode.nativeModes
			};
			CanvasProvider.release(ctx);
		}

		if (!this.browser) {
			var agent = navigator.userAgent.toLowerCase(),
				platform = (/(win)/.exec(agent)
						|| /(mac)/.exec(agent)
						|| /(linux)/.exec(agent)
						|| [])[0],
				browser = proto.browser = { platform: platform };
			if (platform)
				browser[platform] = true;
			agent.replace(
				/(opera|chrome|safari|webkit|firefox|msie|trident|atom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:([.\d]+))?/g,
				function(all, n, v1, v2, rv) {
					if (!browser.chrome) {
						var v = n === 'opera' ? v2 : v1;
						if (n === 'trident') {
							v = rv;
							n = 'msie';
						}
						browser.version = v;
						browser.versionNumber = parseFloat(v);
						browser.name = n;
						browser[n] = true;
					}
				}
			);
			if (browser.chrome)
				delete browser.webkit;
			if (browser.atom)
				delete browser.chrome;
		}
	},

	version: '0.9.24',

	getView: function() {
		return this.project && this.project.getView();
	},

	getPaper: function() {
		return this;
	},

	execute: function(code, url, options) {
		paper.PaperScript.execute(code, this, url, options);
		View.updateFocus();
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(element) {
		paper = this;
		this.project = new Project(element);
		return this;
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		for (var i = this.projects.length - 1; i >= 0; i--)
			this.projects[i].remove();
		for (var i = this.tools.length - 1; i >= 0; i--)
			this.tools[i].remove();
		for (var i = this.palettes.length - 1; i >= 0; i--)
			this.palettes[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Emitter, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.emit('deactivate');
		this._scope[this._reference] = this;
		this.emit('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	}
});

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = precision || 5;
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return Math.round(val * this.multiplier) / this.multiplier;
	},

	pair: function(val1, val2, separator) {
		return this.number(val1) + (separator || ',') + this.number(val2);
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		TOLERANCE = 1e-6,
		EPSILON = 1e-12,
		MACHINE_EPSILON = 1.12e-16;

	return {
		TOLERANCE: TOLERANCE,
		EPSILON: EPSILON,
		MACHINE_EPSILON: MACHINE_EPSILON,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return abs(val) <= EPSILON;
		},

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = (b - a) * 0.5,
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0;
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance)
					return nx;
				if (fx > 0) {
					b = x;
					x = nx <= a ? (a + b) * 0.5 : nx;
				} else {
					a = x;
					x = nx >= b ? (a + b) * 0.5 : nx;
				}
			}
			return x;
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var count = 0,
				x1, x2 = Infinity,
				B = b,
				D;
			b /= 2;
			D = b * b - a * c;
			if (D !== 0 && abs(D) < MACHINE_EPSILON) {
				var gmC = pow(abs(a * b * c), 1 / 3);
				if (gmC < 1e-8) {
					var mult = pow(10, abs(
						Math.floor(Math.log(gmC) * Math.LOG10E)));
					if (!isFinite(mult))
						mult = 0;
					a *= mult;
					b *= mult;
					c *= mult;
					D = b * b - a * c;
				}
			}
			if (abs(a) < EPSILON) {
				if (abs(B) < EPSILON)
					return abs(c) < EPSILON ? -1 : 0;
				x1 = -c / B;
			} else {
				if (D >= -MACHINE_EPSILON) {
					D = D < 0 ? 0 : D;
					var R = sqrt(D);
					if (b >= MACHINE_EPSILON && b <= MACHINE_EPSILON) {
						x1 = abs(a) >= abs(c) ? R / a : -c / R;
						x2 = -x1;
					} else {
						var q = -(b + (b < 0 ? -1 : 1) * R);
						x1 = q / a;
						x2 = c / q;
					}
				}
			}
			if (isFinite(x1) && (min == null || x1 >= min && x1 <= max))
				roots[count++] = x1;
			if (x2 !== x1
					&& isFinite(x2) && (min == null || x2 >= min && x2 <= max))
				roots[count++] = x2;
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			var count = 0,
				x, b1, c2;
			if (abs(a) < EPSILON) {
				a = b;
				b1 = c;
				c2 = d;
				x = Infinity;
			} else if (abs(d) < EPSILON) {
				b1 = b;
				c2 = c;
				x = 0;
			} else {
				var ec = 1 + MACHINE_EPSILON,
					x0, q, qd, t, r, s, tmp;
				x = -(b / a) / 3;
				tmp = a * x,
				b1 = tmp + b,
				c2 = b1 * x + c,
				qd = (tmp + b1) * x + c2,
				q = c2 * x + d;
				t = q /a;
				r = pow(abs(t), 1/3);
				s = t < 0 ? -1 : 1;
				t = -qd / a;
				r = t > 0 ? 1.3247179572 * Math.max(r, sqrt(t)) : r;
				x0 = x - s * r;
				if (x0 !== x) {
					do {
						x = x0;
						tmp = a * x,
						b1 = tmp + b,
						c2 = b1 * x + c,
						qd = (tmp + b1) * x + c2,
						q = c2 * x + d;
						x0 = qd === 0 ? x : x - q / qd / ec;
						if (x0 === x) {
							x = x0;
							break;
						}
					} while (s * x0 > s * x);
					if (abs(a) * x * x > abs(d / x)) {
						c2 = -d / x;
						b1 = (c2 - c) / x;
					}
				}
			}
			var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max);
			if (isFinite(x) && (count === 0 || x !== roots[count - 1])
					&& (min == null || x >= min && x <= max))
				roots[count++] = x;
			return count;
		}
	};
};

var UID = {
	_id: 1,
	_pools: {},

	get: function(ctor) {
		if (ctor) {
			var name = ctor._class,
				pool = this._pools[name];
			if (!pool)
				pool = this._pools[name] = { _id: 1 };
			return pool._id++;
		} else {
			return this._id++;
		}
	}
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this.x = arg0;
			this.y = hasY ? arg1 : arg0;
			if (this.__read)
				this.__read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.x != null) {
				this.x = arg0.x;
				this.y = arg0.y;
			} else if (arg0.width != null) {
				this.x = arg0.width;
				this.y = arg0.height;
			} else if (arg0.angle != null) {
				this.x = arg0.length;
				this.y = 0;
				this.setAngle(arg0.angle);
			} else {
				this.x = this.y = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this.set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				var a = this.dot(point) / div;
				return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var point = Point.read(arguments),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(arguments);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			s = Math.sin(angle),
			c = Math.cos(angle);
		point = new Point(
			point.x * c - point.y * s,
			point.x * s + point.y * c
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this);
	},

	isClose: function(point, tolerance) {
		return this.getDistance(point) < tolerance;
	},

	isCollinear: function(point) {
		return Math.abs(this.cross(point)) < 0.000001;
	},

	isColinear: '#isCollinear',

	isOrthogonal: function(point) {
		return Math.abs(this.dot(point)) < 0.000001;
	},

	isZero: function() {
		return Numerical.isZero(this.x) && Numerical.isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments);
		if (point.isZero()) {
			return new Point(0, 0);
		} else {
			var scale = this.dot(point) / point.dot(point);
			return new Point(
				point.x * scale,
				point.y * scale
			);
		}
	},

	statics: {
		min: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this.width = arg0;
			this.height = hasHeight ? arg1 : arg0;
			if (this.__read)
				this.__read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.width = this.height = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.width = arg0[0];
				this.height = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.width != null) {
				this.width = arg0.width;
				this.height = arg0.height;
			} else if (arg0.x != null) {
				this.width = arg0.x;
				this.height = arg0.y;
			} else {
				this.width = this.height = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		return Numerical.isZero(this.width) && Numerical.isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var type = typeof arg0,
			read = 0;
		if (type === 'number') {
			this.x = arg0;
			this.y = arg1;
			this.width = arg2;
			this.height = arg3;
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = this.width = this.height = 0;
			read = arg0 === null ? 1 : 0;
		} else if (arguments.length === 1) {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0[1];
				this.width = arg0[2];
				this.height = arg0[3];
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this.x = arg0.x || 0;
				this.y = arg0.y || 0;
				this.width = arg0.width || 0;
				this.height = arg0.height || 0;
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this.x = this.y = this.width = this.height = 0;
				this._set(arg0);
				read = 1;
			}
		}
		if (!read) {
			var point = Point.readNamed(arguments, 'from'),
				next = Base.peek(arguments);
			this.x = point.x;
			this.y = point.y;
			if (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {
				var to = Point.readNamed(arguments, 'to');
				this.width = to.x - point.x;
				this.height = to.y - point.y;
				if (this.width < 0) {
					this.x = to.x;
					this.width = -this.width;
				}
				if (this.height < 0) {
					this.y = to.y;
					this.height = -this.height;
				}
			} else {
				var size = Size.read(arguments);
				this.width = size.width;
				this.height = size.height;
			}
			read = arguments.__index;
		}
		if (this.__read)
			this.__read = read;
	},

	set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (this._fixX)
			this.x += (this.width - size.width) * this._fixX;
		if (this._fixY)
			this.y += (this.height - size.height) * this._fixY;
		this.width = size.width;
		this.height = size.height;
		this._fixW = 1;
		this._fixH = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fixW)
			this.width -= left - this.x;
		this.x = left;
		this._fixX = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fixH)
			this.height -= top - this.y;
		this.y = top;
		this._fixY = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (this._fixX !== undefined && this._fixX !== 1)
			this._fixW = 0;
		if (this._fixW)
			this.x = right - this.width;
		else
			this.width = right - this.x;
		this._fixX = 1;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (this._fixY !== undefined && this._fixY !== 1)
			this._fixH = 0;
		if (this._fixH)
			this.y = bottom - this.height;
		else
			this.height = bottom - this.y;
		this._fixY = 1;
	},

	getCenterX: function() {
		return this.x + this.width * 0.5;
	},

	setCenterX: function(x) {
		this.x = x - this.width * 0.5;
		this._fixX = 0.5;
	},

	getCenterY: function() {
		return this.y + this.height * 0.5;
	},

	setCenterY: function(y) {
		this.y = y - this.height * 0.5;
		this._fixY = 0.5;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length == 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width > this.x
				&& rect.y + rect.height > this.y
				&& rect.x < this.x + this.width
				&& rect.y < this.y + this.height;
	},

	touches: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width >= this.x
				&& rect.y + rect.height >= this.y
				&& rect.x <= this.x + this.width
				&& rect.y <= this.y + this.height;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, Base.each([
		['Top', 'Left'], ['Top', 'Right'],
		['Bottom', 'Left'], ['Bottom', 'Right'],
		['Left', 'Center'], ['Top', 'Center'],
		['Right', 'Center'], ['Bottom', 'Center']
	],
	function(parts, index) {
		var part = parts.join('');
		var xFirst = /^[RL]/.test(part);
		if (index >= 4)
			parts[1] += xFirst ? 'Y' : 'X';
		var x = parts[xFirst ? 0 : 1],
			y = parts[xFirst ? 1 : 0],
			getX = 'get' + x,
			getY = 'get' + y,
			setX = 'set' + x,
			setY = 'set' + y,
			get = 'get' + part,
			set = 'set' + part;
		this[get] = function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this[getX](), this[getY](), this, set);
		};
		this[set] = function() {
			var point = Point.read(arguments);
			this[setX](point.x);
			this[setY](point.y);
		};
	}, {
		beans: true
	}
));

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this.set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
}, new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key);
		var internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return this._owner._boundsSelected;
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner.setSelected) {
					owner._boundsSelected = selected;
					owner.setSelected(selected || owner._selectedSegmentState > 0);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg) {
		var count = arguments.length,
			ok = true;
		if (count === 6) {
			this.set.apply(this, arguments);
		} else if (count === 1) {
			if (arg instanceof Matrix) {
				this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
			} else if (Array.isArray(arg)) {
				this.set.apply(this, arg);
			} else {
				ok = false;
			}
		} else if (count === 0) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok)
			throw new Error('Unsupported matrix parameters');
	},

	set: function(a, c, b, d, tx, ty, _dontNotify) {
		this._a = a;
		this._c = c;
		this._b = b;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options) {
		return Base.serialize(this.getValues(), options);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(9);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._c, this._b, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._b),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._c), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._c = this._b = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function(recursively, _setApplyMatrix) {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, true, Base.pick(recursively, true),
					_setApplyMatrix);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._b;
		this._ty += x * this._c + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var scale = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._c *= scale.x;
		this._b *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * b;
		this._b = -sin * a + cos * b;
		this._c = cos * c + sin * d;
		this._d = -sin * c + cos * d;
		this._tx += tx * a + ty * b;
		this._ty += tx * c + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var shear = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			c = this._c;
		this._a += shear.y * this._b;
		this._c += shear.y * this._d;
		this._b += shear.x * a;
		this._d += shear.x * c;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var skew = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	concatenate: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		this._a = a2 * a1 + c2 * b1;
		this._b = b2 * a1 + d2 * b1;
		this._c = a2 * c1 + c2 * d1;
		this._d = b2 * c1 + d2 * d1;
		this._tx += tx2 * a1 + ty2 * b1;
		this._ty += tx2 * c1 + ty2 * d1;
		this._changed();
		return this;
	},

	preConcatenate: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			tx1 = this._tx,
			ty1 = this._ty,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		this._a = a2 * a1 + b2 * c1;
		this._b = a2 * b1 + b2 * d1;
		this._c = c2 * a1 + d2 * c1;
		this._d = c2 * b1 + d2 * d1;
		this._tx = a2 * tx1 + b2 * ty1 + tx2;
		this._ty = c2 * tx1 + d2 * ty1 + ty2;
		this._changed();
		return this;
	},

	chain: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			tx1 = this._tx,
			ty1 = this._ty,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		return new Matrix(
				a2 * a1 + c2 * b1,
				a2 * c1 + c2 * d1,
				b2 * a1 + d2 * b1,
				b2 * c1 + d2 * d1,
				tx1 + tx2 * a1 + ty2 * b1,
				ty1 + tx2 * c1 + ty2 * d1);
	},

	isIdentity: function() {
		return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isInvertible: function() {
		return !!this._getDeterminant();
	},

	isSingular: function() {
		return !this._getDeterminant();
	},

	transform: function( src, dst, count) {
		return arguments.length < 3
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, dst, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest.set(
			x * this._a + y * this._b + this._tx,
			x * this._c + y * this._d + this._ty,
			_dontNotify
		);
	},

	_transformCoordinates: function(src, dst, count) {
		var i = 0,
			j = 0,
			max = 2 * count;
		while (i < max) {
			var x = src[i++],
				y = src[i++];
			dst[j++] = x * this._a + y * this._b + this._tx;
			dst[j++] = x * this._c + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, coords, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = coords.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j])
				min[j] = val;
			else if (val > max[j])
				max[j] = val;
		}
		if (!dest)
			dest = new Rectangle();
		return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_getDeterminant: function() {
		var det = this._a * this._d - this._b * this._c;
		return isFinite(det) && !Numerical.isZero(det)
				&& isFinite(this._tx) && isFinite(this._ty)
				? det : null;
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var det = this._getDeterminant();
		if (!det)
			return null;
		var x = point.x - this._tx,
			y = point.y - this._ty;
		if (!dest)
			dest = new Point();
		return dest.set(
			(x * this._d - y * this._b) / det,
			(y * this._a - x * this._c) / det,
			_dontNotify
		);
	},

	decompose: function() {
		var a = this._a, b = this._b, c = this._c, d = this._d;
		if (Numerical.isZero(a * d - b * c))
			return null;

		var scaleX = Math.sqrt(a * a + b * b);
		a /= scaleX;
		b /= scaleX;

		var shear = a * c + b * d;
		c -= a * shear;
		d -= b * shear;

		var scaleY = Math.sqrt(c * c + d * d);
		c /= scaleY;
		d /= scaleY;
		shear /= scaleY;

		if (a * d < b * c) {
			a = -a;
			b = -b;
			shear = -shear;
			scaleX = -scaleX;
		}

		return {
			scaling: new Point(scaleX, scaleY),
			rotation: -Math.atan2(b, a) * 180 / Math.PI,
			shearing: shear
		};
	},

	getValues: function() {
		return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return (this.decompose() || {}).scaling;
	},

	getRotation: function() {
		return (this.decompose() || {}).rotation;
	},

	inverted: function() {
		var det = this._getDeterminant();
		return det && new Matrix(
				this._d / det,
				-this._c / det,
				-this._b / det,
				this._a / det,
				(this._b * this._ty - this._d * this._tx) / det,
				(this._c * this._tx - this._a * this._ty) / det);
	},

	shiftless: function() {
		return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
	},

	applyToContext: function(ctx) {
		ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
	}
}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {
	var part = Base.capitalize(name),
		prop = '_' + name;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true);
	},

	getDistance: function(point) {
		return Math.abs(Line.getSignedDistance(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true));
	},

	statics: {
		intersect: function(apx, apy, avx, avy, bpx, bpy, bvx, bvy, asVector,
				isInfinite) {
			if (!asVector) {
				avx -= apx;
				avy -= apy;
				bvx -= bpx;
				bvy -= bpy;
			}
			var cross = avx * bvy - avy * bvx;
			if (!Numerical.isZero(cross)) {
				var dx = apx - bpx,
					dy = apy - bpy,
					ta = (bvx * dy - bvy * dx) / cross,
					tb = (avx * dy - avy * dx) / cross;
				if (isInfinite || 0 <= ta && ta <= 1 && 0 <= tb && tb <= 1)
					return new Point(
								apx + ta * avx,
								apy + ta * avy);
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx;
			if (ccw === 0) {
				ccw = v2x * vx + v2y * vy;
				if (ccw > 0) {
					v2x -= vx;
					v2y -= vy;
					ccw = v2x * vx + v2y * vy;
					if (ccw < 0)
						ccw = 0;
				}
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			return Numerical.isZero(vx)
					? vy >= 0 ? px - x : x - px
					: Numerical.isZero(vy)
						? vx >= 0 ? y - py : py - y
						: (vx * (y - py) - vy * (x - px)) / Math.sqrt(vx * vx + vy * vy);
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this.layers = [];
		this._activeLayer = null;
		this.symbols = [];
		this._currentStyle = new Style(null, null, this);
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectedItems = {};
		this._selectedItemCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.layers, options, true, dictionary);
	},

	clear: function() {
		for (var i = this.layers.length - 1; i >= 0; i--)
			this.layers[i].remove();
		this.symbols = [];
	},

	isEmpty: function() {
		return this.layers.length === 0;
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.initialize(style);
	},

	getIndex: function() {
		return this._index;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	getActiveLayer: function() {
		return this._activeLayer || new Layer({ project: this });
	},

	getSelectedItems: function() {
		var items = [];
		for (var id in this._selectedItems) {
			var item = this._selectedItems[id];
			if (item.isInserted())
				items.push(item);
		}
		return items;
	},

	insertChild: function(index, item, _preserve) {
		if (item instanceof Layer) {
			item._remove(false, true);
			Base.splice(this.layers, [item], index, 0);
			item._setProject(this, true);
			if (this._changes)
				item._changed(5);
			if (!this._activeLayer)
				this._activeLayer = item;
		} else if (item instanceof Item) {
			(this._activeLayer
				|| this.insertChild(index, new Layer(Item.NO_INSERT)))
					.insertChild(index, item, _preserve);
		} else {
			item = null;
		}
		return item;
	},

	addChild: function(item, _preserve) {
		return this.insertChild(undefined, item, _preserve);
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectedItems = this._selectedItems;
		if (item._selected) {
			if (selectedItems[id] !== item) {
				this._selectedItemCount++;
				selectedItems[id] = item;
			}
		} else if (selectedItems[id] === item) {
			this._selectedItemCount--;
			delete selectedItems[id];
		}
	},

	selectAll: function() {
		var layers = this.layers;
		for (var i = 0, l = layers.length; i < l; i++)
			layers[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectedItems = this._selectedItems;
		for (var i in selectedItems)
			selectedItems[i].setFullySelected(false);
	},

	hitTest: function() {
		var point = Point.read(arguments),
			options = HitResult.getOptions(Base.read(arguments));
		for (var i = this.layers.length - 1; i >= 0; i--) {
			var res = this.layers[i]._hitTest(point, options);
			if (res) return res;
		}
		return null;
	},

	getItems: function(match) {
		return Item._getItems(this.layers, match);
	},

	getItem: function(match) {
		return Item._getItems(this.layers, match, null, null, true)[0] || null;
	},

	importJSON: function(json) {
		this.activate();
		var layer = this._activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var param = new Base({
			offset: new Point(0, 0),
			pixelRatio: pixelRatio,
			viewMatrix: matrix.isIdentity() ? null : matrix,
			matrices: [new Matrix()],
			updateMatrix: true
		});
		for (var i = 0, layers = this.layers, l = layers.length; i < l; i++)
			layers[i].draw(ctx, param);
		ctx.restore();

		if (this._selectedItemCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			var items = this._selectedItems,
				size = this._scope.settings.handleSize,
				version = this._updateVersion;
			for (var id in items)
				items[id]._drawSelection(ctx, matrix, size, items, version);
			ctx.restore();
		}
	}
});

var Symbol = Base.extend({
	_class: 'Symbol',

	initialize: function Symbol(item, dontCenter) {
		this._id = UID.get();
		this.project = paper.project;
		this.project.symbols.push(this);
		if (item)
			this.setDefinition(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._definition],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8) {
			Item._clearBoundsCache(this);
		}
		if (flags & 1) {
			this.project._needsUpdate = true;
		}
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(item, _dontCenter) {
		if (item._parentSymbol)
			item = item.clone();
		if (this._definition)
			this._definition._parentSymbol = null;
		this._definition = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._parentSymbol = this;
		this._changed(9);
	},

	place: function(position) {
		return new PlacedSymbol(this, position);
	},

	clone: function() {
		return new Symbol(this._definition.clone(false));
	},

	equals: function(symbol) {
		return symbol === this
				|| symbol && this.definition.equals(symbol.definition)
				|| false;
	}
});

var Item = Base.extend(Emitter, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = new Base(
						this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_applyMatrix: true,
	_canApplyMatrix: true,
	_boundsSelected: false,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		applyMatrix: null,
		matrix: new Matrix(),
		pivot: null,
		locked: false,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		guide: false,
		selected: false,
		clipMask: false,
		data: {}
	},

	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var hasProps = props && Base.isPlainObject(props),
			internal = hasProps && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = hasProps && props.project || paper.project;
		if (!internal)
			this._id = UID.get();
		this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (!this._project) {
			if (internal || hasProps && props.insert === false) {
				this._setProject(project);
			} else if (hasProps && props.parent) {
				this.setParent(props.parent);
			} else {
				(project._activeLayer || new Layer()).addChild(this);
			}
		}
		if (hasProps && props !== Item.NO_INSERT)
			this._set(props, { insert: true, project: true, parent: true },
					true);
		return hasProps;
	},

	_events: new function() {

		var mouseFlags = {
			mousedown: {
				mousedown: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mouseup: {
				mouseup: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mousemove: {
				mousedrag: 1,
				mousemove: 1,
				mouseenter: 1,
				mouseleave: 1
			}
		};

		var mouseEvent = {
			install: function(type) {
				var counters = this.getView()._eventCounters;
				if (counters) {
					for (var key in mouseFlags) {
						counters[key] = (counters[key] || 0)
								+ (mouseFlags[key][type] || 0);
					}
				}
			},
			uninstall: function(type) {
				var counters = this.getView()._eventCounters;
				if (counters) {
					for (var key in mouseFlags)
						counters[key] -= mouseFlags[key][type] || 0;
				}
			}
		};

		return Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],
			function(name) {
				this[name] = mouseEvent;
			}, {
				onFrame: {
					install: function() {
						this._animateItem(true);
					},
					uninstall: function() {
						this._animateItem(false);
					}
				},

				onLoad: {}
			}
		);
	},

	_animateItem: function(animate) {
		this.getView()._animateItem(this, animate);
	},

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._parentSymbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed =
					this._globalMatrix = this._currentPath = undefined;
		}
		if (cacheParent
				&& (flags & 40)) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project) {
			if (flags & 1) {
				project._needsUpdate = true;
			}
			if (project._changes) {
				var entry = project._changesById[this._id];
				if (entry) {
					entry.flags |= flags;
				} else {
					entry = { item: this, flags: flags };
					project._changesById[this._id] = entry;
					project._changes.push(entry);
				}
			}
		}
		if (symbol)
			symbol._changed(flags);
	},

	set: function(props) {
		if (props)
			this._set(props);
		return this;
	},

	getId: function() {
		return this._id;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name, unique) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		var parent = this._parent;
		if (name && parent) {
			var children = parent._children,
				namedChildren = parent._namedChildren,
				orig = name,
				i = 1;
			while (unique && children[name])
				name = orig + ' ' + (i++);
			(namedChildren[name] = namedChildren[name] || []).push(this);
			children[name] = this;
		}
		this._name = name || undefined;
		this._changed(128);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			name = '_' + name;
		this['get' + part] = function() {
			return this[name];
		};
		this['set' + part] = function(value) {
			if (value != this[name]) {
				this[name] = value;
				this._changed(name === '_locked'
						? 128 : 129);
			}
		};
	},
{}), {
	beans: true,

	_locked: false,

	_visible: true,

	_blendMode: 'normal',

	_opacity: 1,

	_guide: false,

	isSelected: function() {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				if (children[i].isSelected())
					return true;
		}
		return this._selected;
	},

	setSelected: function(selected, noChildren) {
		if (!noChildren && this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setSelected(selected);
		}
		if ((selected = !!selected) ^ this._selected) {
			this._selected = selected;
			this._project._updateSelection(this);
			this._changed(129);
		}
	},

	_selected: false,

	isFullySelected: function() {
		var children = this._children;
		if (children && this._selected) {
			for (var i = 0, l = children.length; i < l; i++)
				if (!children[i].isFullySelected())
					return false;
			return true;
		}
		return this._selected;
	},

	setFullySelected: function(selected) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setFullySelected(selected);
		}
		this.setSelected(selected, true);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(129);
			if (this._parent)
				this._parent._changed(1024);
		}
	},

	_clipMask: false,

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var position = this._position,
			ctor = _dontLink ? Point : LinkedPoint;
		if (!position) {
			var pivot = this._pivot;
			position = this._position = pivot
					? this._matrix._transformPoint(pivot)
					: this.getBounds().getCenter(true);
		}
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	getPivot: function(_dontLink) {
		var pivot = this._pivot;
		if (pivot) {
			var ctor = _dontLink ? Point : LinkedPoint;
			pivot = new ctor(pivot.x, pivot.y, this, 'setPivot');
		}
		return pivot;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments, 0, { clone: true, readNull: true });
		this._position = undefined;
	},

	_pivot: null,
}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',
		'internalBounds', 'internalRoughBounds'],
	function(key) {
		var getter = 'get' + Base.capitalize(key),
			match = key.match(/^internal(.*)$/),
			internalGetter = match ? 'get' + match[1] : null;
		this[getter] = function(_matrix) {
			var boundsGetter = this._boundsGetter,
				name = !internalGetter && (typeof boundsGetter === 'string'
						? boundsGetter : boundsGetter && boundsGetter[getter])
						|| getter,
				bounds = this._getCachedBounds(name, _matrix, this,
						internalGetter);
			return key === 'bounds'
					? new LinkedRectangle(bounds.x, bounds.y, bounds.width,
							bounds.height, this, 'setBounds')
					: bounds;
		};
	},
{
	beans: true,

	_getBounds: function(getter, matrix, cacheItem) {
		var children = this._children;
		if (!children || children.length == 0)
			return new Rectangle();
		Item._updateBoundsCache(this, cacheItem);
		var x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			if (child._visible && !child.isEmpty()) {
				var rect = child._getCachedBounds(getter,
						matrix && matrix.chain(child._matrix), cacheItem);
				x1 = Math.min(rect.x, x1);
				y1 = Math.min(rect.y, y1);
				x2 = Math.max(rect.x + rect.width, x2);
				y2 = Math.max(rect.y + rect.height, y2);
			}
		}
		return isFinite(x1)
				? new Rectangle(x1, y1, x2 - x1, y2 - y1)
				: new Rectangle();
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			matrix.scale(
					bounds.width != 0 ? rect.width / bounds.width : 1,
					bounds.height != 0 ? rect.height / bounds.height : 1);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
		matrix = matrix && matrix.orNullIfIdentity();
		var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
			cache = (!matrix || matrix.equals(_matrix)) && getter;
		Item._updateBoundsCache(this._parent || this._parentSymbol, cacheItem);
		if (cache && this._bounds && this._bounds[cache])
			return this._bounds[cache].clone();
		var bounds = this._getBounds(internalGetter || getter,
				matrix || _matrix, cacheItem);
		if (cache) {
			if (!this._bounds)
				this._bounds = {};
			var cached = this._bounds[cache] = bounds.clone();
			cached._internal = !!internalGetter;
		}
		return bounds;
	},

	statics: {
		_updateBoundsCache: function(parent, item) {
			if (parent) {
				var id = item._id,
					ref = parent._boundsCache = parent._boundsCache || {
						ids: {},
						list: []
					};
				if (!ref.ids[id]) {
					ref.list.push(item);
					ref.ids[id] = item;
				}
			}
		},

		_clearBoundsCache: function(item) {
			var cache = item._boundsCache;
			if (cache) {
				item._bounds = item._position = item._boundsCache = undefined;
				for (var i = 0, list = cache.list, l = list.length; i < l; i++){
					var other = list[i];
					if (other !== item) {
						other._bounds = other._position = undefined;
						if (other._boundsCache)
							Item._clearBoundsCache(other);
					}
				}
			}
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._decomposed = this._matrix.decompose();
	},

	getRotation: function() {
		var decomposed = this._decomposed || this._decompose();
		return decomposed && decomposed.rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			decomposed.rotation = rotation;
			this._decomposed = decomposed;
		}
	},

	getScaling: function(_dontLink) {
		var decomposed = this._decomposed || this._decompose(),
			scaling = decomposed && decomposed.scaling,
			ctor = _dontLink ? Point : LinkedPoint;
		return scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling();
		if (current) {
			var scaling = Point.read(arguments, 0, { clone: true }),
				decomposed = this._decomposed;
			this.scale(scaling.x / current.x, scaling.y / current.y);
			decomposed.scaling = scaling;
			this._decomposed = decomposed;
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.initialize.apply(matrix, arguments);
		if (this._applyMatrix) {
			this.transform(null, true);
		} else {
			this._changed(9);
		}
	},

	getGlobalMatrix: function(_dontClone) {
		var matrix = this._globalMatrix,
			updateVersion = this._project._updateVersion;
		if (matrix && matrix._updateVersion !== updateVersion)
			matrix = null;
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			var parent = this._parent;
			if (parent)
				matrix.preConcatenate(parent.getGlobalMatrix(true));
			matrix._updateVersion = updateVersion;
		}
		return _dontClone ? matrix : matrix.clone();
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(apply) {
		if (this._applyMatrix = this._canApplyMatrix && !!apply)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project.getView();
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		return this._parent && this._parent._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		return this._parent && this._parent._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(insert) {
		return this._clone(new this.constructor(Item.NO_INSERT), insert);
	},

	_clone: function(copy, insert, includeMatrix) {
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide'],
			children = this._children;
		copy.setStyle(this._style);
		for (var i = 0, l = children && children.length; i < l; i++) {
			copy.addChild(children[i].clone(false), true);
		}
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (this.hasOwnProperty(key))
				copy[key] = this[key];
		}
		if (includeMatrix !== false)
			copy._matrix.initialize(this._matrix);
		copy.setApplyMatrix(this._applyMatrix);
		copy.setPivot(this._pivot);
		copy.setSelected(this._selected);
		copy._data = this._data ? Base.clone(this._data) : null;
		if (insert || insert === undefined)
			copy.insertAbove(this);
		if (this._name)
			copy.setName(this._name, true);
		return copy;
	},

	copyTo: function(itemOrProject) {
		return itemOrProject.addChild(this.clone(false));
	},

	rasterize: function(resolution) {
		var bounds = this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			size = new Size(bottomRight.subtract(topLeft)),
			canvas = CanvasProvider.getCanvas(size.multiply(scale)),
			ctx = canvas.getContext('2d'),
			matrix = new Matrix().scale(scale).translate(topLeft.negate());
		ctx.save();
		matrix.applyToContext(ctx);
		this.draw(ctx, new Base({ matrices: [matrix] }));
		ctx.restore();
		var raster = new Raster(Item.NO_INSERT);
		raster.setCanvas(canvas);
		raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
				.scale(1 / scale));
		raster.insertAbove(this);
		return raster;
	},

	contains: function() {
		return !!this._contains(
				this._matrix._inverseTransform(Point.read(arguments)));
	},

	_contains: function(point) {
		if (this._children) {
			for (var i = this._children.length - 1; i >= 0; i--) {
				if (this._children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this.getBounds());
	},

	_asPathItem: function() {
		return new Path.Rectangle({
			rectangle: this.getInternalBounds(),
			matrix: this._matrix,
			insert: false,
		});
	},

	intersects: function(item, _matrix) {
		if (!(item instanceof Item))
			return false;
		return this._asPathItem().getIntersections(item._asPathItem(),
				_matrix || item._matrix).length > 0;
	},

	hitTest: function() {
		return this._hitTest(
				Point.read(arguments),
				HitResult.getOptions(Base.read(arguments)));
	},

	_hitTest: function(point, options) {
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty())
			return null;

		var matrix = this._matrix,
			parentTotalMatrix = options._totalMatrix,
			view = this.getView(),
			totalMatrix = options._totalMatrix = parentTotalMatrix
					? parentTotalMatrix.chain(matrix)
					: this.getGlobalMatrix().preConcatenate(view._matrix),
			tolerancePadding = options._tolerancePadding = new Size(
						Path._getPenPadding(1, totalMatrix.inverted())
					).multiply(
						Math.max(options.tolerance, 0.000001)
					);
		point = matrix._inverseTransform(point);

		if (!this._children && !this.getInternalRoughBounds()
				.expand(tolerancePadding.multiply(2))._containsPoint(point))
			return null;
		var checkSelf = !(options.guides && !this._guide
				|| options.selected && !this._selected
				|| options.type && options.type !== Base.hyphenate(this._class)
				|| options.class && !(this instanceof options.class)),
			that = this,
			res;

		function checkBounds(type, part) {
			var pt = bounds['get' + part]();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1)
				return new HitResult(type, that,
						{ name: Base.hyphenate(part), point: pt });
		}

		if (checkSelf && (options.center || options.bounds) && this._parent) {
			var bounds = this.getInternalBounds();
			if (options.center)
				res = checkBounds('center', 'Center');
			if (!res && options.bounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++)
					res = checkBounds('bounds', points[i]);
			}
		}

		var children = !res && this._children;
		if (children) {
			var opts = this._getChildHitTestOptions(options);
			for (var i = children.length - 1; i >= 0 && !res; i--)
				res = children[i]._hitTest(point, opts);
		}
		if (!res && checkSelf)
			res = this._hitTestSelf(point, options);
		if (res && res.point)
			res.point = matrix.transform(res.point);
		options._totalMatrix = parentTotalMatrix;
		return res;
	},

	_getChildHitTestOptions: function(options) {
		return options;
	},

	_hitTestSelf: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	},

	matches: function(name, compare) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		var type = typeof name;
		if (type === 'object') {
			for (var key in name) {
				if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
					return false;
			}
		} else if (type === 'function') {
			return name(this);
		} else {
			var value = /^(empty|editable)$/.test(name)
					? this['is' + Base.capitalize(name)]()
					: name === 'type'
						? Base.hyphenate(this._class)
						: this[name];
			if (/^(constructor|class)$/.test(name)) {
				if (!(this instanceof compare))
					return false;
			} else if (compare instanceof RegExp) {
				if (!compare.test(value))
					return false;
			} else if (typeof compare === 'function') {
				if (!compare(value))
					return false;
			} else if (Base.isPlainObject(compare)) {
				if (!matchObject(compare, value))
					return false;
			} else if (!Base.equals(value, compare)) {
				return false;
			}
		}
		return true;
	},

	getItems: function(match) {
		return Item._getItems(this._children, match, this._matrix);
	},

	getItem: function(match) {
		return Item._getItems(this._children, match, this._matrix, null, true)
				[0] || null;
	},

	statics: {
		_getItems: function _getItems(children, match, matrix, param,
				firstOnly) {
			if (!param && typeof match === 'object') {
				var overlapping = match.overlapping,
					inside = match.inside,
					bounds = overlapping || inside,
					rect =	bounds && Rectangle.read([bounds]);
				param = {
					items: [],
					inside: !!inside,
					overlapping: !!overlapping,
					rect: rect,
					path: overlapping && new Path.Rectangle({
						rectangle: rect,
						insert: false
					})
				};
				if (bounds)
					match = Base.set({}, match,
							{ inside: true, overlapping: true });
			}
			var items = param && param.items,
				rect = param && param.rect;
			matrix = rect && (matrix || new Matrix());
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i],
					childMatrix = matrix && matrix.chain(child._matrix),
					add = true;
				if (rect) {
					var bounds = child.getBounds(childMatrix);
					if (!rect.intersects(bounds))
						continue;
					if (!(param.inside && rect.contains(bounds))
							&& !(param.overlapping && (bounds.contains(rect)
								|| param.path.intersects(child, childMatrix))))
						add = false;
				}
				if (add && child.matches(match)) {
					items.push(child);
					if (firstOnly)
						break;
				}
				_getItems(child._children, match,
						childMatrix, param,
						firstOnly);
				if (firstOnly && items.length > 0)
					break;
			}
			return items;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this
				? this.addChild(res)
				: res;
	},

	addChild: function(item, _preserve) {
		return this.insertChild(undefined, item, _preserve);
	},

	insertChild: function(index, item, _preserve) {
		var res = item ? this.insertChildren(index, [item], _preserve) : null;
		return res && res[0];
	},

	addChildren: function(items, _preserve) {
		return this.insertChildren(this._children.length, items, _preserve);
	},

	insertChildren: function(index, items, _preserve, _proto) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Array.prototype.slice.apply(items);
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i];
				if (_proto && !(item instanceof _proto)) {
					items.splice(i, 1);
				} else {
					var shift = item._parent === this && item._index < index;
					if (item._remove(false, true) && shift)
						index--;
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project && project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				item._parent = this;
				item._setProject(this._project, true);
				if (item._name)
					item.setName(item._name);
				if (notifySelf)
					this._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insertSibling: function(index, item, _preserve) {
		return this._parent
				? this._parent.insertChild(index, item, _preserve)
				: null;
	},

	insertAbove: function(item, _preserve) {
		return item._insertSibling(item._index + 1, this, _preserve);
	},

	insertBelow: function(item, _preserve) {
		return item._insertSibling(item._index, this, _preserve);
	},

	sendToBack: function() {
		return (this._parent || this instanceof Layer && this._project)
				.insertChild(0, this);
	},

	bringToFront: function() {
		return (this._parent || this instanceof Layer && this._project)
				.addChild(this);
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	reduce: function() {
		if (this._children && this._children.length === 1) {
			var child = this._children[0].reduce();
			child.insertAbove(this);
			child.setStyle(this._style);
			this.remove();
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var parent = this._parent;
		if (parent) {
			var children = parent._children,
				namedChildren = parent._namedChildren,
				name = this._name,
				namedArray = namedChildren[name],
				index = namedArray ? namedArray.indexOf(this) : -1;
			if (index !== -1) {
				if (children[name] == this)
					delete children[name];
				namedArray.splice(index, 1);
				if (namedArray.length) {
					children[name] = namedArray[namedArray.length - 1];
				} else {
					delete namedChildren[name];
				}
			}
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var parent = this._parent;
		if (parent) {
			if (this._name)
				this._removeNamed();
			if (this._index != null)
				Base.splice(parent._children, null, this._index, 1);
			this._installEvents(false);
			if (notifySelf) {
				var project = this._project;
				if (project && project._changes)
					this._changed(5);
			}
			if (notifyParent)
				parent._changed(11);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	replaceWith: function(item) {
		var ok = item && item.insertBelow(this);
		if (ok)
			this.remove();
		return ok;
	},

	removeChildren: function(from, to) {
		if (!this._children)
			return null;
		from = from || 0;
		to = Base.pick(to, this._children.length);
		var removed = Base.splice(this._children, null, from, to - from);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function() {
		return !this._children || this._children.length === 0;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent == item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	rotate: function(angle ) {
		return this.transform(new Matrix().rotate(angle,
				Point.read(arguments, 1, { readNull: true })
					|| this.getPosition(true)));
	}
}, Base.each(['scale', 'shear', 'skew'], function(name) {
	this[name] = function() {
		var point = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		return this.transform(new Matrix()[name](point,
				center || this.getPosition(true)));
	};
}, {

}), {
	transform: function(matrix, _applyMatrix, _applyRecursively,
			_setApplyMatrix) {
		if (matrix && matrix.isIdentity())
			matrix = null;
		var _matrix = this._matrix,
			applyMatrix = (_applyMatrix || this._applyMatrix)
					&& ((!_matrix.isIdentity() || matrix)
						|| _applyMatrix && _applyRecursively && this._children);
		if (!matrix && !applyMatrix)
			return this;
		if (matrix)
			_matrix.preConcatenate(matrix);
		if (applyMatrix = applyMatrix && this._transformContent(_matrix,
					_applyRecursively, _setApplyMatrix)) {
			var pivot = this._pivot,
				style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (pivot)
				_matrix._transformPoint(pivot, pivot, true);
			if (fillColor)
				fillColor.transform(_matrix);
			if (strokeColor)
				strokeColor.transform(_matrix);
			_matrix.reset(true);
			if (_setApplyMatrix && this._canApplyMatrix)
				this._applyMatrix = true;
		}
		var bounds = this._bounds,
			position = this._position;
		this._changed(9);
		var decomp = bounds && matrix && matrix.decompose();
		if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var rect = bounds[key];
				if (applyMatrix || !rect._internal)
					matrix._transformBounds(rect, rect);
			}
			var getter = this._boundsGetter,
				rect = bounds[getter && getter.getBounds || getter || 'getBounds'];
			if (rect)
				this._position = rect.getCenter(true);
			this._bounds = bounds;
		} else if (matrix && position) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix, applyRecursively, setApplyMatrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].transform(matrix, true, applyRecursively,
						setApplyMatrix);
			return true;
		}
	},

	globalToLocal: function() {
		return this.getGlobalMatrix(true)._inverseTransform(
				Point.read(arguments));
	},

	localToGlobal: function() {
		return this.getGlobalMatrix(true)._transformPoint(
				Point.read(arguments));
	},

	parentToLocal: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	localToParent: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	},

	_setStyles: function(ctx) {
		var style = this._style,
			fillColor = style.getFillColor(),
			strokeColor = style.getStrokeColor(),
			shadowColor = style.getShadowColor();
		if (fillColor)
			ctx.fillStyle = fillColor.toCanvasStyle(ctx);
		if (strokeColor) {
			var strokeWidth = style.getStrokeWidth();
			if (strokeWidth > 0) {
				ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
				ctx.lineWidth = strokeWidth;
				var strokeJoin = style.getStrokeJoin(),
					strokeCap = style.getStrokeCap(),
					miterLimit = style.getMiterLimit();
				if (strokeJoin)
					ctx.lineJoin = strokeJoin;
				if (strokeCap)
					ctx.lineCap = strokeCap;
				if (miterLimit)
					ctx.miterLimit = miterLimit;
				if (paper.support.nativeDash) {
					var dashArray = style.getDashArray(),
						dashOffset = style.getDashOffset();
					if (dashArray && dashArray.length) {
						if ('setLineDash' in ctx) {
							ctx.setLineDash(dashArray);
							ctx.lineDashOffset = dashOffset;
						} else {
							ctx.mozDash = dashArray;
							ctx.mozDashOffset = dashOffset;
						}
					}
				}
			}
		}
		if (shadowColor) {
			var shadowBlur = style.getShadowBlur();
			if (shadowBlur > 0) {
				ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
				ctx.shadowBlur = shadowBlur;
				var offset = this.getShadowOffset();
				ctx.shadowOffsetX = offset.x;
				ctx.shadowOffsetY = offset.y;
			}
		}
	},

	draw: function(ctx, param, parentStrokeMatrix) {
		var updateVersion = this._updateVersion = this._project._updateVersion;
		if (!this._visible || this._opacity === 0)
			return;
		var matrices = param.matrices,
			viewMatrix = param.viewMatrix,
			matrix = this._matrix,
			globalMatrix = matrices[matrices.length - 1].chain(matrix);
		if (!globalMatrix.isInvertible())
			return;

		function getViewMatrix(matrix) {
			return viewMatrix ? viewMatrix.chain(matrix) : matrix;
		}

		matrices.push(globalMatrix);
		if (param.updateMatrix) {
			globalMatrix._updateVersion = updateVersion;
			this._globalMatrix = globalMatrix;
		}

		var blendMode = this._blendMode,
			opacity = this._opacity,
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.dontStart
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			pixelRatio = param.pixelRatio || 1,
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));
			if (!bounds.width || !bounds.height)
				return;
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
					.multiply(pixelRatio));
			if (pixelRatio !== 1)
				ctx.scale(pixelRatio, pixelRatio);
		}
		ctx.save();
		var strokeMatrix = parentStrokeMatrix
				? parentStrokeMatrix.chain(matrix)
				: !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),
			clip = !direct && param.clipItem,
			transform = !strokeMatrix || clip;
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else if (transform) {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		if (transform)
			(direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);
		if (clip)
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		if (strokeMatrix) {
			ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
			var offset = param.offset;
			if (offset)
				ctx.translate(-offset.x, -offset.y);
		}
		this._draw(ctx, param, strokeMatrix);
		ctx.restore();
		matrices.pop();
		if (param.clip && !param.dontFinish)
			ctx.clip();
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_isUpdated: function(updateVersion) {
		var parent = this._parent;
		if (parent instanceof CompoundPath)
			return parent._isUpdated(updateVersion);
		var updated = this._updateVersion === updateVersion;
		if (!updated && parent && parent._visible
				&& parent._isUpdated(updateVersion)) {
			this._updateVersion = updateVersion;
			updated = true;
		}
		return updated;
	},

	_drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {
		if ((this._drawSelected || this._boundsSelected)
				&& this._isUpdated(updateVersion)) {
			var color = this.getSelectedColor(true)
					|| this.getLayer().getSelectedColor(true),
				mx = matrix.chain(this.getGlobalMatrix(true));
			ctx.strokeStyle = ctx.fillStyle = color
					? color.toCanvasStyle(ctx) : '#009dec';
			if (this._drawSelected)
				this._drawSelected(ctx, mx, selectedItems);
			if (this._boundsSelected) {
				var half = size / 2;
					coords = mx._transformCorners(this.getInternalBounds());
				ctx.beginPath();
				for (var i = 0; i < 8; i++)
					ctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
				ctx.closePath();
				ctx.stroke();
				for (var i = 0; i < 8; i++)
					ctx.fillRect(coords[i] - half, coords[++i] - half,
							size, size);
			}
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(name) {
	this['removeOn' + Base.capitalize(name)] = function() {
		var hash = {};
		hash[name] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}));

var Group = Item.extend({
	_class: 'Group',
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 1026) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			for (var i = 0, l = this._children.length; i < l; i++) {
				var child = this._children[i];
				if (child._clipMask) {
					clipItem = child;
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem(),
			draw = true;
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			if (this._currentPath) {
				ctx.currentPath = this._currentPath;
				draw = false;
			} else {
				ctx.beginPath();
				param.dontStart = param.dontFinish = true;
			}
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (draw) {
			for (var i = 0, l = this._children.length; i < l; i++) {
				var item = this._children[i];
				if (item !== clipItem)
					item.draw(ctx, param);
			}
		}
		if (clip) {
			this._currentPath = ctx.currentPath;
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer(arg) {
		var props = Base.isPlainObject(arg)
				? new Base(arg)
				: { children: Array.isArray(arg) ? arg : arguments },
			insert = props.insert;
		props.insert = false;
		Group.call(this, props);
		if (insert || insert === undefined) {
			this._project.addChild(this);
			this.activate();
		}
	},

	_remove: function _remove(notifySelf, notifyParent) {
		if (this._parent)
			return _remove.base.call(this, notifySelf, notifyParent);
		if (this._index != null) {
			var project = this._project;
			if (project._activeLayer === this)
				project._activeLayer = this.getNextSibling()
						|| this.getPreviousSibling();
			Base.splice(project.layers, null, this._index, 1);
			this._installEvents(false);
			if (notifySelf && project._changes)
				this._changed(5);
			if (notifyParent) {
				project._needsUpdate = true;
			}
			return true;
		}
		return false;
	},

	getNextSibling: function getNextSibling() {
		return this._parent ? getNextSibling.base.call(this)
				: this._project.layers[this._index + 1] || null;
	},

	getPreviousSibling: function getPreviousSibling() {
		return this._parent ? getPreviousSibling.base.call(this)
				: this._project.layers[this._index - 1] || null;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project._activeLayer = this;
	},

	_insertSibling: function _insertSibling(index, item, _preserve) {
		return !this._parent
				? this._project.insertChild(index, item, _preserve)
				: _insertSibling.base.call(this, index, item, _preserve);
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsSelected: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props) {
		this._initialize(props);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	clone: function(insert) {
		var copy = new Shape(Item.NO_INSERT);
		copy.setType(this._type);
		copy.setSize(this._size);
		copy.setRadius(this._radius);
		return this._clone(copy, insert);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				var radius = Size.min(this._radius, size.divide(2));
				this._radius.set(radius.width, radius.height);
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius.set(width / 2, height / 2);
			}
			this._size.set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size.set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius.width, radius.height);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size.width, size.height);
				} else if (type === 'ellipse') {
					this._size.set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = this._clone(new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		}), insert);
		if (paper.settings.applyMatrix)
			path.setApplyMatrix(true);
		return path;
	},

	_draw: function(ctx, param, strokeMatrix) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip,
			untransformed = !strokeMatrix;
		if (hasFill || hasStroke || dontPaint) {
			var type = this._type,
				radius = this._radius,
				isCircle = type === 'circle';
			if (!param.dontStart)
				ctx.beginPath();
			if (untransformed && isCircle) {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = isCircle ? radius : radius.width,
					ry = isCircle ? radius : radius.height,
					size = this._size,
					width = size.width,
					height = size.height;
				if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
					ctx.rect(-width / 2, -height / 2, width, height);
				} else {
					var x = width / 2,
						y = height / 2,
						kappa = 1 - 0.5522847498307936,
						cx = rx * kappa,
						cy = ry * kappa,
						c = [
							-x, -y + ry,
							-x, -y + cy,
							-x + cx, -y,
							-x + rx, -y,
							x - rx, -y,
							x - cx, -y,
							x, -y + cy,
							x, -y + ry,
							x, y - ry,
							x, y - cy,
							x - cx, y,
							x - rx, y,
							-x + rx, y,
							-x + cx, y,
							-x, y - cy,
							-x, y - ry
						];
					if (strokeMatrix)
						strokeMatrix.transform(c, c, 32);
					ctx.moveTo(c[0], c[1]);
					ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
					if (x !== rx)
						ctx.lineTo(c[8], c[9]);
					ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
					if (y !== ry)
						ctx.lineTo(c[16], c[17]);
					ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
					if (x !== rx)
						ctx.lineTo(c[24], c[25]);
					ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx);
			if (hasFill) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		if (getter !== 'getBounds' && this.hasStroke())
			rect = rect.expand(this.getStrokeWidth());
		return matrix ? matrix._transformBounds(rect) : rect;
	}
},
new function() {

	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var i = 0; i < 4; i++) {
				var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(corner, center);
				if ((expand ? rect.expand(expand) : rect).contains(point))
					return center;
			}
		}
	}

	function getEllipseRadius(point, radius) {
		var angle = point.getAngleInRadians(),
			width = radius.width * 2,
			height = radius.height * 2,
			x = width * Math.sin(angle),
			y = height * Math.cos(angle);
		return width * height / (2 * Math.sqrt(x * x + y * y));
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTestSelf: function _hitTestSelf(point, options) {
			var hit = false;
			if (this.hasStroke()) {
				var type = this._type,
					radius = this._radius,
					strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
				if (type === 'rectangle') {
					var center = getCornerCenter(this, point, strokeWidth);
					if (center) {
						var pt = point.subtract(center);
						hit = 2 * Math.abs(pt.getLength()
								- getEllipseRadius(pt, radius)) <= strokeWidth;
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(strokeWidth),
							inner = rect.expand(-strokeWidth);
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					if (type === 'ellipse')
						radius = getEllipseRadius(point, radius);
					hit = 2 * Math.abs(point.getLength() - radius)
							<= strokeWidth;
				}
			}
			return hit
					? new HitResult('stroke', this)
					: _hitTestSelf.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = new Shape(Base.getNamed(args));
		item._type = type;
		item._size = size;
		item._radius = radius;
		return item.translate(point);
	}

	return {
		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.min(Size.readNamed(arguments, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, arguments);
		},

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, arguments);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: 'getBounds',
	_boundsSelected: true,
	_serializeFields: {
		crossOrigin: null,
		source: null
	},

	initialize: function Raster(object, position) {
		if (!this._initialize(object,
				position !== undefined && Point.read(arguments, 1))) {
			if (typeof object === 'string') {
				this.setSource(object);
			} else {
				this.setImage(object);
			}
		}
		if (!this._size) {
			this._size = new Size();
			this._loaded = false;
		}
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	clone: function(insert) {
		var copy = new Raster(Item.NO_INSERT),
			image = this._image,
			canvas = this._canvas;
		if (image) {
			copy.setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(this._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			copy.setImage(copyCanvas);
		}
		copy._crossOrigin = this._crossOrigin;
		return this._clone(copy, insert);
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size ? size.width : 0, size ? size.height : 0,
				this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!size.equals(this._size)) {
			if (size.width > 0 && size.height > 0) {
				var element = this.getElement();
				this.setImage(CanvasProvider.getCanvas(size));
				if (element)
					this.getContext(true).drawImage(element, 0, 0,
							size.width, size.height);
			} else {
				if (this._canvas)
					CanvasProvider.release(this._canvas);
				this._size = size.clone();
			}
		}
	},

	getWidth: function() {
		return this._size ? this._size.width : 0;
	},

	setWidth: function(width) {
		this.setSize(width, this.getHeight());
	},

	getHeight: function() {
		return this._size ? this._size.height : 0;
	},

	setHeight: function(height) {
		this.setSize(this.getWidth(), height);
	},

	isEmpty: function() {
		var size = this._size;
		return !size || size.width === 0 && size.height === 0;
	},

	getResolution: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getPpi: '#getResolution',

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image && image.getContext) {
			this._image = null;
			this._canvas = image;
			this._loaded = true;
		} else {
			this._image = image;
			this._canvas = null;
			this._loaded = image && image.complete;
		}
		this._size = new Size(
				image ? image.naturalWidth || image.width : 0,
				image ? image.naturalHeight || image.height : 0);
		this._context = null;
		this._changed(521);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(modify) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (modify) {
			this._image = null;
			this._changed(513);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		return this._image && this._image.src || this.toDataURL();
	},

	setSource: function(src) {
		var that = this,
			crossOrigin = this._crossOrigin,
			image;

		function loaded() {
			var view = that.getView();
			if (view) {
				paper = view._scope;
				that.setImage(image);
				that.emit('load');
				view.update();
			}
		}

		image = document.getElementById(src) || new Image();
		if (crossOrigin)
			image.crossOrigin = crossOrigin;
		if (image.naturalWidth && image.naturalHeight) {
			setTimeout(loaded, 0);
		} else {
			DomEvent.add(image, { load: loaded });
			if (!image.src)
				image.src = src;
		}
		this.setImage(image);
	},

	getCrossOrigin: function() {
		return this._image && this._image.crossOrigin || this._crossOrigin || '';
	},

	setCrossOrigin: function(crossOrigin) {
		this._crossOrigin = crossOrigin;
		if (this._image)
			this._image.crossOrigin = crossOrigin;
	},

	getElement: function() {
		return this._canvas || this._loaded && this._image;
	}
}, {
	beans: false,

	getSubCanvas: function() {
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		ctx.drawImage(this.getCanvas(), rect.x, rect.y,
				rect.width, rect.height, 0, 0, rect.width, rect.height);
		return ctx.canvas;
	},

	getSubRaster: function() {
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster.setImage(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.preConcatenate(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var src = this._image && this._image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL() : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (object.width) {
			bounds = new Rectangle(object);
		} else if (object.x) {
			bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
		}
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
		this._matrix.applyToContext(ctx);
		var element = this.getElement(),
			size = this._size;
		if (element)
			ctx.drawImage(element, -size.width / 2, -size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function() {
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var point = Point.read(arguments),
			color = Color.read(arguments),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function() {
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTestSelf: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx) {
		var element = this.getElement();
		if (element) {
			ctx.globalAlpha = this._opacity;
			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var PlacedSymbol = Item.extend({
	_class: 'PlacedSymbol',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: { getBounds: 'getStrokeBounds' },
	_boundsSelected: true,
	_serializeFields: {
		symbol: null
	},

	initialize: function PlacedSymbol(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
	},

	_equals: function(item) {
		return this._symbol === item._symbol;
	},

	getSymbol: function() {
		return this._symbol;
	},

	setSymbol: function(symbol) {
		this._symbol = symbol;
		this._changed(9);
	},

	clone: function(insert) {
		var copy = new PlacedSymbol(Item.NO_INSERT);
		copy.setSymbol(this._symbol);
		return this._clone(copy, insert);
	},

	isEmpty: function() {
		return this._symbol._definition.isEmpty();
	},

	_getBounds: function(getter, matrix, cacheItem) {
		var definition = this.symbol._definition;
		return definition._getCachedBounds(getter,
				matrix && matrix.chain(definition._matrix), cacheItem);
	},

	_hitTestSelf: function(point, options) {
		var res = this._symbol._definition._hitTest(point, options);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this.symbol._definition.draw(ctx, param);
	}

});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values) {
			values.enumerable = true;
			this.inject(values);
		}
	},

	statics: {
		getOptions: function(options) {
			return new Base({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut;
		if (count === 0) {
		} else if (count === 1) {
			if (arg0.point) {
				point = arg0.point;
				handleIn = arg0.handleIn;
				handleOut = arg0.handleOut;
			} else {
				point = arg0;
			}
		} else if (count === 2 && typeof arg0 === 'number') {
			point = arguments;
		} else if (count <= 3) {
			point = arg0;
			handleIn = arg1;
			handleOut = arg2;
		} else {
			point = arg0 !== undefined ? [ arg0, arg1 ] : null;
			handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
			handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
	},

	_serialize: function(options) {
		return Base.serialize(this.isStraight() ? this._point
				: [this._point, this._handleIn, this._handleOut],
				options, true);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curve;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curve = index > 0 ? curves[index - 1] : path._closed
						? curves[curves.length - 1] : null))
				curve._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curve = curves[index]))
				curve._changed();
		}
		path._changed(25);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this._point.set(point.x, point.y);
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		var point = Point.read(arguments);
		this._handleIn.set(point.x, point.y);
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		var point = Point.read(arguments);
		this._handleOut.set(point.x, point.y);
	},

	hasHandles: function() {
		return !this.isStraight();
	},

	isStraight: function() {
		return this._handleIn.isZero() && this._handleOut.isZero();
	},

	isLinear: function() {
		return Segment.isLinear(this, this.getNext());
	},

	isCollinear: function(segment) {
		return Segment.isCollinear(this, this.getNext(),
				segment, segment.getNext());
	},

	isColinear: '#isCollinear',

	isOrthogonal: function() {
		return Segment.isOrthogonal(this.getPrevious(), this, this.getNext());
	},

	isOrthogonalArc: function() {
		return Segment.isOrthogonalArc(this, this.getNext());
	},

	isArc: '#isOrthogonalArc',

	_selectionState: 0,

	isSelected: function(_point) {
		var state = this._selectionState;
		return !_point ? !!(state & 7)
			: _point === this._point ? !!(state & 4)
			: _point === this._handleIn ? !!(state & 1)
			: _point === this._handleOut ? !!(state & 2)
			: false;
	},

	setSelected: function(selected, _point) {
		var path = this._path,
			selected = !!selected,
			state = this._selectionState,
			oldState = state,
			flag = !_point ? 7
					: _point === this._point ? 4
					: _point === this._handleIn ? 1
					: _point === this._handleOut ? 2
					: 0;
		if (selected) {
			state |= flag;
		} else {
			state &= ~flag;
		}
		this._selectionState = state;
		if (path && state !== oldState) {
			path._updateSelection(this, oldState, state);
			path._changed(129);
		}
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	reverse: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn = !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, coords, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i  = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	},

   statics: {

		isLinear: function(seg1, seg2) {
			var l = seg2._point.subtract(seg1._point);
			return l.isCollinear(seg1._handleOut)
					&& l.isCollinear(seg2._handleIn);
		},

		isCollinear: function(seg1, seg2, seg3, seg4) {
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg3._handleOut.isZero() && seg4._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isCollinear(
						seg4._point.subtract(seg3._point));
		},

		isOrthogonal: function(seg1, seg2, seg3) {
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
				&& seg2._handleOut.isZero() && seg3._handleIn.isZero()
				&& seg2._point.subtract(seg1._point).isOrthogonal(
						seg3._point.subtract(seg2._point));
		},

		isOrthogonalArc: function(seg1, seg2) {
			var handle1 = seg1._handleOut,
				handle2 = seg2._handleIn,
				kappa = 0.5522847498307936;
			if (handle1.isOrthogonal(handle2)) {
				var pt1 = seg1._point,
					pt2 = seg2._point,
					corner = new Line(pt1, handle1, true).intersect(
							new Line(pt2, handle2, true), true);
				return corner && Numerical.isZero(handle1.getLength() /
						corner.subtract(pt1).getLength() - kappa)
					&& Numerical.isZero(handle2.getLength() /
						corner.subtract(pt2).getLength() - kappa);
			}
			return false;
		},
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y, selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) {
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	_serialize: function(options) {
		var f = options.formatter,
			x = f.number(this._x),
			y = f.number(this._y);
		return this.isSelected()
				? { x: x, y: y, selected: true }
				: [x, y];
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		return Numerical.isZero(this._x) && Numerical.isZero(this._y);
	},

	setSelected: function(selected) {
		this._owner.setSelected(selected, this);
	},

	isSelected: function() {
		return this._owner.isSelected(this);
	}
});

var Curve = Base.extend({
	_class: 'Curve',

	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length;
		if (count === 3) {
			this._path = arg0;
			this._segment1 = arg1;
			this._segment2 = arg2;
		} else if (count === 0) {
			this._segment1 = new Segment();
			this._segment2 = new Segment();
		} else if (count === 1) {
			this._segment1 = new Segment(arg0.segment1);
			this._segment2 = new Segment(arg0.segment2);
		} else if (count === 2) {
			this._segment1 = new Segment(arg0);
			this._segment2 = new Segment(arg1);
		} else {
			var point1, handle1, handle2, point2;
			if (count === 4) {
				point1 = arg0;
				handle1 = arg1;
				handle2 = arg2;
				point2 = arg3;
			} else if (count === 8) {
				point1 = [arg0, arg1];
				point2 = [arg6, arg7];
				handle1 = [arg2 - arg0, arg3 - arg1];
				handle2 = [arg4 - arg6, arg5 - arg7];
			}
			this._segment1 = new Segment(point1, null, handle1);
			this._segment2 = new Segment(point2, handle2, null);
		}
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		var point = Point.read(arguments);
		this._segment1._point.set(point.x, point.y);
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		var point = Point.read(arguments);
		this._segment2._point.set(point.x, point.y);
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		var point = Point.read(arguments);
		this._segment1._handleOut.set(point.x, point.y);
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		var point = Point.read(arguments);
		this._segment2._handleIn.set(point.x, point.y);
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	},

	getLength: function() {
		if (this._length == null) {
			this._length = this.isLinear()
				? this._segment2._point.getDistance(this._segment1._point)
				: Curve.getLength(this.getValues(), 0, 1);
		}
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	hasHandles: function() {
		return !this._segment1._handleOut.isZero()
				|| !this._segment2._handleIn.isZero();
	},

	isLinear: function() {
		return Segment.isLinear(this._segment1, this._segment2);
	},

	isCollinear: function(curve) {
		return Ssegment.isCollinear(this._segment1, this._segment2,
				curve._segment1, curve._segment2);
	},

	isOrthogonalArc: function() {
		return Segment.isOrthogonalArc(this._segment1, this._segment2);
	},

	getIntersections: function(curve) {
		return Curve.filterIntersections(Curve.getIntersections(
				this.getValues(), curve.getValues(), this, curve, []));
	},

	_getParameter: function(offset, isParameter) {
		return isParameter
				? offset
				: offset && offset.curve === this
					? offset.parameter
					: offset === undefined && isParameter === undefined
						? 0.5
						: this.getParameterAt(offset, 0);
	},

	divide: function(offset, isParameter, ignoreLinear) {
		var parameter = this._getParameter(offset, isParameter),
			tolerance = 0.000001,
			res = null;
		if (parameter > tolerance && parameter < 1 - tolerance) {
			var parts = Curve.subdivide(this.getValues(), parameter),
				isLinear = ignoreLinear ? false : this.isLinear(),
				left = parts[0],
				right = parts[1];

			if (!isLinear) {
				this._segment1._handleOut.set(left[2] - left[0],
						left[3] - left[1]);
				this._segment2._handleIn.set(right[4] - right[6],
						right[5] - right[7]);
			}

			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						!isLinear && new Point(left[4] - x, left[5] - y),
						!isLinear && new Point(right[2] - x, right[3] - y));

			if (this._path) {
				if (this._segment1._index > 0 && this._segment2._index === 0) {
					this._path.add(segment);
				} else {
					this._path.insert(this._segment2._index, segment);
				}
				res = this;
			} else {
				var end = this._segment2;
				this._segment2 = segment;
				res = new Curve(segment, end);
			}
		}
		return res;
	},

	split: function(offset, isParameter) {
		return this._path
			? this._path.split(this._segment1._index,
					this._getParameter(offset, isParameter))
			: null;
	},

	reverse: function() {
		return new Curve(this._segment2.reverse(), this._segment1.reverse());
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut.x, handleOut.y);
		}
		return removed;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

statics: {
	getValues: function(segment1, segment2, matrix) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			values = [
				p1._x, p1._y,
				p1._x + h1._x, p1._y + h1._y,
				p2._x + h2._x, p2._y + h2._y,
				p2._x, p2._y
			];
		if (matrix)
			matrix._transformCoordinates(values, values, 4);
		return values;
	},

	subdivide: function(v, t) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			p3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,
			p4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,
			p5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,
			p6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,
			p7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,
			p8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;
		return [
			[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y],
			[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]
		];
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var p1 = v[coord],
			c1 = v[coord + 2],
			c2 = v[coord + 4],
			p2 = v[coord + 6],
			c = 3 * (c1 - p1),
			b = 3 * (c2 - c1) - c,
			a = p2 - p1 - c - b;
		return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
	},

	getParameterOf: function(v, x, y) {
		var tolerance = 0.000001;
		if (Math.abs(v[0] - x) < tolerance && Math.abs(v[1] - y) < tolerance)
			return 0;
		if (Math.abs(v[6] - x) < tolerance && Math.abs(v[7] - y) < tolerance)
			return 1;
		var txs = [],
			tys = [],
			sx = Curve.solveCubic(v, 0, x, txs, 0, 1),
			sy = Curve.solveCubic(v, 1, y, tys, 0, 1),
			tx, ty;
		for (var cx = 0;  sx === -1 || cx < sx;) {
			if (sx === -1 || (tx = txs[cx++]) > 0 && tx < 1) {
				for (var cy = 0; sy === -1 || cy < sy;) {
					if (sy === -1 || (ty = tys[cy++]) > 0 && ty < 1) {
						if (sx === -1) {
							tx = ty;
						} else if (sy === -1) {
							ty = tx;
						}
						if (Math.abs(tx - ty) < tolerance)
							return (tx + ty) * 0.5;
					}
				}
				if (sx === -1)
					break;
			}
		}
		return null;
	},

	getPart: function(v, from, to) {
		if (from > 0)
			v = Curve.subdivide(v, from)[1];
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0];
		return v;
	},

	hasHandles: function(v) {
		var isZero = Numerical.isZero;
		return !(isZero(v[0] - v[2]) && isZero(v[1] - v[3])
				&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]));
	},

	isLinear: function(v) {
		var p1x = v[0], p1y = v[1],
			p2x = v[6], p2y = v[7],
			l = new Point(p2x - p1x, p2y - p1y);
		return l.isCollinear(new Point(v[2] - p1x, v[3] - p1y))
				&& l.isCollinear(new Point(v[4] - p2x, v[5] - p2y));
	},

	isFlatEnough: function(v, tolerance) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			ux = 3 * c1x - 2 * p1x - p2x,
			uy = 3 * c1y - 2 * p1y - p2y,
			vx = 3 * c2x - 2 * p2x - p1x,
			vy = 3 * c2y - 2 * p2y - p1y;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				< 10 * tolerance * tolerance;
	},

	getArea: function(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		return (  3.0 * c1y * p1x - 1.5 * c1y * c2x
				- 1.5 * c1y * p2x - 3.0 * p1y * c1x
				- 1.5 * p1y * c2x - 0.5 * p1y * p2x
				+ 1.5 * c2y * p1x + 1.5 * c2y * c1x
				- 3.0 * c2y * p2x + 0.5 * p2y * p1x
				+ 1.5 * p2y * c1x + 3.0 * p2y * c2x) / 10;
	},

	getEdgeSum: function(v) {
		return	  (v[0] - v[2]) * (v[3] + v[1])
				+ (v[2] - v[4]) * (v[5] + v[3])
				+ (v[4] - v[6]) * (v[7] + v[5]);
	},

	getBounds: function(v) {
		var min = v.slice(0, 2),
			max = min.slice(),
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}
		var a = 3 * (v1 - v2) - v0 + v3,
			b = 2 * (v0 + v2) - 4 * v1,
			c = v1 - v0,
			count = Numerical.solveQuadratic(a, b, c, roots),
			tMin = 0.000001,
			tMax = 1 - tMin;
		add(v3, 0);
		for (var i = 0; i < count; i++) {
			var t = roots[i],
				u = 1 - t;
			if (tMin < t && t < tMax)
				add(u * u * u * v0
					+ 3 * u * u * t * v1
					+ 3 * u * t * t * v2
					+ t * t * t * v3,
					padding);
		}
	}
}}, Base.each(
	['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				bounds = this._bounds[name] = Path[name]([this._segment1,
						this._segment2], false, this._path.getStyle());
			}
			return bounds.clone();
		};
	},
{

}), {
	beans: false,

	getParameterAt: function(offset, start) {
		return Curve.getParameterAt(this.getValues(), offset, start);
	},

	getParameterOf: function() {
		var point = Point.read(arguments);
		return Curve.getParameterOf(this.getValues(), point.x, point.y);
	},

	getLocationAt: function(offset, isParameter) {
		var t = isParameter ? offset : this.getParameterAt(offset);
		return t != null && t >= 0 && t <= 1
				? new CurveLocation(this, t)
				: null;
	},

	getLocationOf: function() {
		return this.getLocationAt(this.getParameterOf(Point.read(arguments)),
				true);
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			values = this.getValues(),
			count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(Curve.getPoint(values, t), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 0.000001) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		var pt = Curve.getPoint(values, minT);
		return new CurveLocation(this, minT, pt, null, null, null,
				point.getDistance(pt));
	},

	getNearestPoint: function() {
		return this.getNearestLocation.apply(this, arguments).getPoint();
	}

},
new function() {
	var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',
		'getWeightedNormal', 'getCurvature'];
	return Base.each(methods,
	function(name) {
		this[name + 'At'] = function(offset, isParameter) {
			var values = this.getValues();
			return Curve[name](values, isParameter ? offset
					: Curve.getParameterAt(values, offset, 0));
		};
	}, {
		statics: {
			evaluateMethods: methods
		}
	})
},
new function() {

	function getLengthIntegrand(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],

			ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
			bx = 6 * (p1x + c2x) - 12 * c1x,
			cx = 3 * (c1x - p1x),

			ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
			by = 6 * (p1y + c2y) - 12 * c1y,
			cy = 3 * (c1y - p1y);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	function evaluate(v, t, type, normalized) {
		if (t == null || t < 0 || t > 1)
			return null;
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			tolerance = 0.000001,
			x, y;

		if (type === 0 && (t < tolerance || t > 1 - tolerance)) {
			var isZero = t < tolerance;
			x = isZero ? p1x : p2x;
			y = isZero ? p1y : p2y;
		} else {
			var cx = 3 * (c1x - p1x),
				bx = 3 * (c2x - c1x) - cx,
				ax = p2x - p1x - cx - bx,

				cy = 3 * (c1y - p1y),
				by = 3 * (c2y - c1y) - cy,
				ay = p2y - p1y - cy - by;
			if (type === 0) {
				x = ((ax * t + bx) * t + cx) * t + p1x;
				y = ((ay * t + by) * t + cy) * t + p1y;
			} else {
				if (t < tolerance) {
					x = cx;
					y = cy;
				} else if (t > 1 - tolerance) {
					x = 3 * (p2x - c2x);
					y = 3 * (p2y - c2y);
				} else {
					x = (3 * ax * t + 2 * bx) * t + cx;
					y = (3 * ay * t + 2 * by) * t + cy;
				}
				if (normalized) {
					if (x === 0 && y === 0
							&& (t < tolerance || t > 1 - tolerance)) {
						x = c2x - c1x;
						y = c2y - c1y;
					}
					var len = Math.sqrt(x * x + y * y);
					x /= len;
					y /= len;
				}
				if (type === 3) {
					var x2 = 6 * ax * t + 2 * bx,
						y2 = 6 * ay * t + 2 * by,
						d = Math.pow(x * x + y * y, 3 / 2);
					x = d !== 0 ? (x * y2 - y * x2) / d : 0;
					y = 0;
				}
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	}

	return {
		statics: true,

		getLength: function(v, a, b) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			var isZero = Numerical.isZero;
			if (a === 0 && b === 1
					&& isZero(v[0] - v[2]) && isZero(v[1] - v[3])
					&& isZero(v[6] - v[4]) && isZero(v[7] - v[5])) {
				var dx = v[6] - v[0],
					dy = v[7] - v[1];
				return Math.sqrt(dx * dx + dy * dy);
			}
			var ds = getLengthIntegrand(v);
			return Numerical.integrate(ds, a, b, getIterations(a, b));
		},

		getParameterAt: function(v, offset, start) {
			if (start === undefined)
				start = offset < 0 ? 1 : 0
			if (offset === 0)
				return start;
			var tolerance = 0.000001,
				abs = Math.abs,
				forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				ds = getLengthIntegrand(v),
				rangeLength = Numerical.integrate(ds, a, b,
						getIterations(a, b));
			if (abs(offset - rangeLength) < tolerance) {
				return forward ? b : a;
			} else if (abs(offset) > rangeLength) {
				return null;
			}
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				length += Numerical.integrate(ds, start, t,
						getIterations(start, t));
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds, start + guess, a, b, 16,
					tolerance);
		},

		getPoint: function(v, t) {
			return evaluate(v, t, 0, false);
		},

		getTangent: function(v, t) {
			return evaluate(v, t, 1, true);
		},

		getWeightedTangent: function(v, t) {
			return evaluate(v, t, 1, false);
		},

		getNormal: function(v, t) {
			return evaluate(v, t, 2, true);
		},

		getWeightedNormal: function(v, t) {
			return evaluate(v, t, 2, false);
		},

		getCurvature: function(v, t) {
			return evaluate(v, t, 3, false).x;
		}
	};
}, new function() {
	function addLocation(locations, include, curve1, t1, point1, curve2, t2,
			point2) {
		var loc = new CurveLocation(curve1, t1, point1, curve2, t2, point2);
		if (!include || include(loc))
			locations.push(loc);
	}

	function addCurveIntersections(v1, v2, curve1, curve2, locations, include,
			tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
		if (recursion > 32)
			return;
		var q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			tolerance = 0.000001,
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]) || 0,
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]) || 0,
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			tMinNew, tMaxNew, tDiff;
		if (q0x === q3x && uMax - uMin < tolerance && recursion > 3) {
			tMaxNew = tMinNew = (tMax + tMin) / 2;
			tDiff = 0;
		} else {
			var hull = getConvexHull(dp0, dp1, dp2, dp3),
				top = hull[0],
				bottom = hull[1],
				tMinClip, tMaxClip;
			tMinClip = clipConvexHull(top, bottom, dMin, dMax);
			top.reverse();
			bottom.reverse();
			tMaxClip = clipConvexHull(top, bottom, dMin, dMax);
			if (tMinClip == null || tMaxClip == null)
				return;
			v1 = Curve.getPart(v1, tMinClip, tMaxClip);
			tDiff = tMaxClip - tMinClip;
			tMinNew = tMax * tMinClip + tMin * (1 - tMinClip);
			tMaxNew = tMax * tMaxClip + tMin * (1 - tMaxClip);
		}
		if (oldTDiff > 0.5 && tDiff > 0.5) {
			if (tMaxNew - tMinNew > uMax - uMin) {
				var parts = Curve.subdivide(v1, 0.5),
					t = tMinNew + (tMaxNew - tMinNew) / 2;
				addCurveIntersections(
					v2, parts[0], curve2, curve1, locations, include,
					uMin, uMax, tMinNew, t, tDiff, !reverse, ++recursion);
				addCurveIntersections(
					v2, parts[1], curve2, curve1, locations, include,
					uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
			} else {
				var parts = Curve.subdivide(v2, 0.5),
					t = uMin + (uMax - uMin) / 2;
				addCurveIntersections(
					parts[0], v1, curve2, curve1, locations, include,
					uMin, t, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
				addCurveIntersections(
					parts[1], v1, curve2, curve1, locations, include,
					t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
			}
		} else if (Math.max(uMax - uMin, tMaxNew - tMinNew) < tolerance) {
			var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
				t2 = uMin + (uMax - uMin) / 2;
			if (reverse) {
				addLocation(locations, include,
						curve2, t2, Curve.getPoint(v2, t2),
						curve1, t1, Curve.getPoint(v1, t1));
			} else {
				addLocation(locations, include,
						curve1, t1, Curve.getPoint(v1, t1),
						curve2, t2, Curve.getPoint(v2, t2));
			}
		} else if (tDiff > 0) {
			addCurveIntersections(v2, v1, curve2, curve1, locations, include,
					uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
		}
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			getSignedDistance = Line.getSignedDistance,
			dist1 = getSignedDistance(0, dq0, 1, dq3, 1 / 3, dq1),
			dist2 = getSignedDistance(0, dq0, 1, dq3, 2 / 3, dq2),
			flip = false,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
			flip = dist1 < 0;
		} else {
			var pmax, cross = 0,
				distZero = dist1 === 0 || dist2 === 0;
			if (Math.abs(dist1) > Math.abs(dist2)) {
				pmax = p1;
				cross = (dq3 - dq2 - (dq3 - dq0) / 3)
						* (2 * (dq3 - dq2) - dq3 + dq1) / 3;
			} else {
				pmax = p2;
				cross = (dq1 - dq0 + (dq0 - dq3) / 3)
						* (-2 * (dq0 - dq1) + dq0 - dq2) / 3;
			}
			hull = cross < 0 || distZero
					? [[p0, pmax, p3], [p0, p3]]
					: [[p0, p1, p2, p3], [p0, p3]];
			flip = dist1 ? dist1 < 0 : dist2 < 0;
		}
		return flip ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		if (hullTop[0][1] < dMin) {
			return clipConvexHullPart(hullTop, true, dMin);
		} else if (hullBottom[0][1] > dMax) {
			return clipConvexHullPart(hullBottom, false, dMax);
		} else {
			return hullTop[0][0];
		}
	}

	function clipConvexHullPart(part, top, threshold) {
		var px = part[0][0],
			py = part[0][1];
		for (var i = 1, l = part.length; i < l; i++) {
			var qx = part[i][0],
				qy = part[i][1];
			if (top ? qy >= threshold : qy <= threshold)
				return px + (threshold - py) * (qx - px) / (qy - py);
			px = qx;
			py = qy;
		}
		return null;
	}

	function addCurveLineIntersections(v1, v2, curve1, curve2, locations,
			include) {
		var flip = Curve.isLinear(v1),
			vc = flip ? v2 : v1,
			vl = flip ? v1 : v2,
			lx1 = vl[0], ly1 = vl[1],
			lx2 = vl[6], ly2 = vl[7],
			ldx = lx2 - lx1,
			ldy = ly2 - ly1,
			angle = Math.atan2(-ldy, ldx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rlx2 = ldx * cos - ldy * sin,
			rvl = [0, 0, 0, 0, rlx2, 0, rlx2, 0],
			rvc = [];
		for(var i = 0; i < 8; i += 2) {
			var x = vc[i] - lx1,
				y = vc[i + 1] - ly1;
			rvc.push(
				x * cos - y * sin,
				y * cos + x * sin);
		}
		var roots = [],
			count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
		for (var i = 0; i < count; i++) {
			var tc = roots[i],
				x = Curve.getPoint(rvc, tc).x;
			if (x >= 0 && x <= rlx2) {
				var tl = Curve.getParameterOf(rvl, x, 0),
					t1 = flip ? tl : tc,
					t2 = flip ? tc : tl;
				addLocation(locations, include,
						curve1, t1, Curve.getPoint(v1, t1),
						curve2, t2, Curve.getPoint(v2, t2));
			}
		}
	}

	function addLineIntersection(v1, v2, curve1, curve2, locations, include) {
		var point = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (point) {
			var x = point.x,
				y = point.y;
			addLocation(locations, include,
					curve1, Curve.getParameterOf(v1, x, y), point,
					curve2, Curve.getParameterOf(v2, x, y), point);
		}
	}

	return { statics: {
		getIntersections: function(v1, v2, c1, c2, locations, include) {
			var linear1 = Curve.isLinear(v1),
				linear2 = Curve.isLinear(v2),
				c1p1 = c1.getPoint1(),
				c1p2 = c1.getPoint2(),
				c2p1 = c2.getPoint1(),
				c2p2 = c2.getPoint2(),
				tolerance = 0.000001;
			if (c1p1.isClose(c2p1, tolerance))
				addLocation(locations, include, c1, 0, c1p1, c2, 0, c1p1);
			if (c1p1.isClose(c2p2, tolerance))
				addLocation(locations, include, c1, 0, c1p1, c2, 1, c1p1);
			(linear1 && linear2
				? addLineIntersection
				: linear1 || linear2
					? addCurveLineIntersections
					: addCurveIntersections)(
						v1, v2, c1, c2, locations, include,
						0, 1, 0, 1, 0, false, 0);
			if (c1p2.isClose(c2p1, tolerance))
				addLocation(locations, include, c1, 1, c1p2, c2, 0, c1p2);
			if (c1p2.isClose(c2p2, tolerance))
				addLocation(locations, include, c1, 1, c1p2, c2, 1, c1p2);
			return locations;
		},

		filterIntersections: function(locations, _expand) {
			var last = locations.length - 1,
				tMax = 1 - 0.000001;
			for (var i = last; i >= 0; i--) {
				var loc = locations[i],
					next = loc._curve.getNext(),
					next2 = loc._curve2.getNext();
				if (next && loc._parameter >= tMax) {
					loc._parameter = 0;
					loc._curve = next;
				}
				if (next2 && loc._parameter2 >= tMax) {
					loc._parameter2 = 0;
					loc._curve2 = next2;
				}
			}

			function compare(loc1, loc2) {
				var path1 = loc1.getPath(),
					path2 = loc2.getPath();
				return path1 === path2
						? (loc1.getIndex() + loc1.getParameter())
								- (loc2.getIndex() + loc2.getParameter())
						: path1._id - path2._id;
			}

			if (last > 0) {
				locations.sort(compare);
				for (var i = last; i > 0; i--) {
					if (locations[i].equals(locations[i - 1])) {
						locations.splice(i, 1);
						last--;
					}
				}
			}
			if (_expand) {
				for (var i = last; i >= 0; i--)
					locations.push(locations[i].getIntersection());
				locations.sort(compare);
			}
			return locations;
		}
	}};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',
	beans: true,

	initialize: function CurveLocation(curve, parameter, point, _curve2,
			_parameter2, _point2, _distance) {
		this._id = UID.get(CurveLocation);
		var path = curve._path;
		this._version = path ? path._version : 0;
		this._curve = curve;
		this._parameter = parameter;
		this._point = point || curve.getPointAt(parameter, true);
		this._curve2 = _curve2;
		this._parameter2 = _parameter2;
		this._point2 = _point2;
		this._distance = _distance;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
	},

	getSegment: function(_preferFirst) {
		if (!this._segment) {
			var curve = this.getCurve(),
				parameter = this.getParameter();
			if (parameter === 1) {
				this._segment = curve._segment2;
			} else if (parameter === 0 || _preferFirst) {
				this._segment = curve._segment1;
			} else if (parameter == null) {
				return null;
			} else {
				this._segment = curve.getPartLength(0, parameter)
					< curve.getPartLength(parameter, 1)
						? curve._segment1
						: curve._segment2;
			}
		}
		return this._segment;
	},

	getCurve: function() {
		var curve = this._curve,
			path = curve && curve._path;
		if (path && path._version !== this._version) {
			curve = null;
			this._parameter = null;
		}
		if (!curve) {
			curve = this._segment1.getCurve();
			if (curve.getParameterOf(this._point) == null)
				curve = this._segment2.getPrevious().getCurve();
			this._curve = curve;
			path = curve._path;
			this._version = path ? path._version : 0;
		}
		return curve;
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getParameter: function() {
		var curve = this.getCurve(),
			parameter = this._parameter;
		return curve && parameter == null
			? this._parameter = curve.getParameterOf(this._point)
			: parameter;
	},

	getPoint: function() {
		return this._point;
	},

	getOffset: function() {
		var path = this.getPath();
		return path ? path._getOffset(this) : this.getCurveOffset();
	},

	getCurveOffset: function() {
		var curve = this.getCurve(),
			parameter = this.getParameter();
		return parameter != null && curve && curve.getPartLength(0, parameter);
	},

	getIntersection: function() {
		var intersection = this._intersection;
		if (!intersection && this._curve2) {
			this._intersection = intersection = new CurveLocation(this._curve2,
					this._parameter2, this._point2 || this._point, this);
			intersection._intersection = this;
		}
		return intersection;
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve();
		return curve && curve.divide(this.getParameter(), true);
	},

	split: function() {
		var curve = this.getCurve();
		return curve && curve.split(this.getParameter(), true);
	},

	equals: function(loc) {
		var abs = Math.abs,
			tolerance = 0.000001;
		return this === loc
				|| loc instanceof CurveLocation
					&& this.getCurve() === loc.getCurve()
					&& abs(this.getParameter() - loc.getParameter()) < tolerance
					&& this._curve2 === loc._curve2
					&& abs(this._parameter2 - loc._parameter2) < tolerance
				|| false;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var parameter = this.getParameter();
		if (parameter != null)
			parts.push('parameter: ' + f.number(parameter));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	}
}, Base.each(Curve.evaluateMethods, function(name) {
	if (name !== 'getPoint') {
		var get = name + 'At';
		this[name] = function() {
			var parameter = this.getParameter(),
				curve = this.getCurve();
			return parameter != null && curve && curve[get](parameter, true);
		};
	}
}, {}));

var PathItem = Item.extend({
	_class: 'PathItem',

	initialize: function PathItem() {
	},

	getIntersections: function(path, _matrix, _expand) {
		if (this === path)
			path = null;
		var locations = [],
			curves1 = this.getCurves(),
			curves2 = path ? path.getCurves() : curves1,
			matrix1 = this._matrix.orNullIfIdentity(),
			matrix2 = path ? (_matrix || path._matrix).orNullIfIdentity()
				: matrix1,
			length1 = curves1.length,
			length2 = path ? curves2.length : length1,
			values2 = [],
			tMin = 0.000001,
			tMax = 1 - tMin;
		if (path && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))
			return [];
		for (var i = 0; i < length2; i++)
			values2[i] = curves2[i].getValues(matrix2);
		for (var i = 0; i < length1; i++) {
			var curve1 = curves1[i],
				values1 = path ? curve1.getValues(matrix1) : values2[i];
			if (!path) {
				var seg1 = curve1.getSegment1(),
					seg2 = curve1.getSegment2(),
					h1 = seg1._handleOut,
					h2 = seg2._handleIn;
				if (new Line(seg1._point.subtract(h1), h1.multiply(2), true)
						.intersect(new Line(seg2._point.subtract(h2),
						h2.multiply(2), true), false)) {
					var parts = Curve.subdivide(values1);
					Curve.getIntersections(
						parts[0], parts[1], curve1, curve1, locations,
						function(loc) {
							if (loc._parameter <= tMax) {
								loc._parameter /= 2;
								loc._parameter2 = 0.5 + loc._parameter2 / 2;
								return true;
							}
						}
					);
				}
			}
			for (var j = path ? 0 : i + 1; j < length2; j++) {
				Curve.getIntersections(
					values1, values2[j], curve1, curves2[j], locations,
					!path && (j === i + 1 || j === length2 - 1 && i === 0)
						&& function(loc) {
							var t = loc._parameter;
							return t >= tMin && t <= tMax;
						}
				);
			}
		}
		return Curve.filterIntersections(locations, _expand);
	},

	_asPathItem: function() {
		return this;
	},

	setPathData: function(data) {

		var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts && parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current = start);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				for (var j = 0; j < length; j += 2)
					this[j === 0 && move ? 'moveTo' : 'lineTo'](
							current = getPoint(j));
				control = current;
				if (move)
					start = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[j], +coords[j + 1]),
							+coords[j + 2], +coords[j + 4], +coords[j + 3]);
				}
				break;
			case 'z':
				this.closePath(true);
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = this._getWinding(point, false, true);
		return !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);
	}

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		this._version = 0;
		var segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: arguments
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? arguments
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined;
			this._selectedSegmentState = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return this._closed === item._closed
				&& Base.equals(this._segments, item._segments);
	},

	clone: function(insert) {
		var copy = new Path(Item.NO_INSERT);
		copy.setSegments(this._segments);
		copy._closed = this._closed;
		if (this._clockwise !== undefined)
			copy._clockwise = this._clockwise;
		return this._clone(copy, insert);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			var parent = this._parent;
			if (parent)
				parent._currentPath = undefined;
			this._length = this._clockwise = undefined;
			if (flags & 16) {
				this._version++;
			} else if (this._curves) {
			   for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
			this._monoCurves = undefined;
		} else if (flags & 32) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected();
		this._segments.length = 0;
		this._selectedSegmentState = 0;
		this._curves = undefined;
		if (segments && segments.length > 0)
			this._add(Segment.readAll(segments));
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(25);
		}
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var segments = this._segments,
			length = segments.length,
			f = new Formatter(_precision),
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY,
			parts = [];

		function addSegment(segment, skipLine) {
			segment._transformCoordinates(_matrix, coords, false);
			curX = coords[0];
			curY = coords[1];
			if (first) {
				parts.push('M' + f.pair(curX, curY));
				first = false;
			} else {
				inX = coords[2];
				inY = coords[3];
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					if (!skipLine)
						parts.push('l' + f.pair(curX - prevX, curY - prevY));
				} else {
					parts.push('c' + f.pair(outX - prevX, outY - prevY)
							+ ' ' + f.pair(inX - prevX, inY - prevY)
							+ ' ' + f.pair(curX - prevX, curY - prevY));
				}
			}
			prevX = curX;
			prevY = curY;
			outX = coords[4];
			outY = coords[5];
		}

		if (length === 0)
			return '';

		for (var i = 0; i < length; i++)
			addSegment(segments[i]);
		if (this._closed && length > 0) {
			addSegment(segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	}
}, {

	isEmpty: function() {
		return this._segments.length === 0;
	},

	isLinear: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++) {
			if (!segments[i].isLinear())
				return false;
		}
		return true;
	},

	hasHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++) {
			if (segments[i].hasHandles())
				return true;
		}
		return false;
	},

	_transformContent: function(matrix) {
		var coords = new Array(6);
		for (var i = 0, l = this._segments.length; i < l; i++)
			this._segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selectionState)
				this._updateSelection(segment, 0, segment._selectionState);
		}
		if (append) {
			segments.push.apply(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves || segs._curves) {
			if (!curves)
				curves = this._curves = [];
			var from = index > 0 ? index - 1 : index,
				start = from,
				to = Math.min(from + amount, this._countCurves());
			if (segs._curves) {
				curves.splice.apply(curves, [from, 0].concat(segs._curves));
				start += segs._curves.length;
			}
			for (var i = start; i < to; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(from, to);
		}
		this._changed(25);
		return segs;
	},

	_adjustCurves: function(from, to) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = from; i < to; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
			curve._changed();
		}
		if (curve = curves[this._closed && from === 0 ? segments.length - 1
				: from - 1]) {
			curve._segment2 = segments[from] || segments[0];
			curve._changed();
		}
		if (curve = curves[to]) {
			curve._segment1 = segments[to];
			curve._changed();
		}
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		return arguments.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments))
			: this._add([ Segment.read(arguments) ])[0];
	},

	insert: function(index, segment1 ) {
		return arguments.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments, 1), index)
			: this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readAll(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readAll(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(from, to, _includeCurves) {
		from = from || 0;
		to = Base.pick(to, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length,
			removed = segments.splice(from, to - from),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selectionState)
				this._updateSelection(segment, segment._selectionState, 0);
			segment._index = segment._path = null;
		}
		for (var i = from, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = from > 0 && to === count + (this._closed ? 1 : 0)
					? from - 1
					: from,
				curves = curves.splice(index, amount);
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(25);
		return removed;
	},

	clear: '#removeSegments',

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves();
			this._length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				this._length += curves[i].getLength();
		}
		return this._length;
	},

	getArea: function() {
		var curves = this.getCurves();
		var area = 0;
		for (var i = 0, l = curves.length; i < l; i++)
			area += curves[i].getArea();
		return area;
	},

	isFullySelected: function() {
		var length = this._segments.length;
		return this._selected && length > 0 && this._selectedSegmentState
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelected: function setSelected(selected) {
		if (!selected)
			this._selectSegments(false);
		setSelected.base.call(this, selected);
	},

	_selectSegments: function(selected) {
		var length = this._segments.length;
		this._selectedSegmentState = selected
				? length * 7 : 0;
		for (var i = 0; i < length; i++)
			this._segments[i]._selectionState = selected
					? 7 : 0;
	},

	_updateSelection: function(segment, oldState, newState) {
		segment._selectionState = newState;
		var total = this._selectedSegmentState += newState - oldState;
		if (total > 0)
			this.setSelected(true);
	},

	flatten: function(maxDistance) {
		var iterator = new PathIterator(this, 64, 0.1),
			pos = 0,
			step = iterator.length / Math.ceil(iterator.length / maxDistance),
			end = iterator.length + (this._closed ? -step : step) / 2;
		var segments = [];
		while (pos <= end) {
			segments.push(new Segment(iterator.getPointAt(pos)));
			pos += step;
		}
		this.setSegments(segments);
	},

	reduce: function() {
		var curves = this.getCurves();
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (curve.isLinear() && curve.getLength() === 0)
				curve.remove();
		}
		return this;
	},

	simplify: function(tolerance) {
		if (this._segments.length > 2) {
			var fitter = new PathFitter(this, tolerance || 2.5);
			this.setSegments(fitter.fit());
		}
	},

	split: function(index, parameter) {
		if (parameter === null)
			return null;
		if (arguments.length === 1) {
			var arg = index;
			if (typeof arg === 'number')
				arg = this.getLocationAt(arg);
			if (!arg)
				return null
			index = arg.index;
			parameter = arg.parameter;
		}
		var tolerance = 0.000001;
		if (parameter >= 1 - tolerance) {
			index++;
			parameter--;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (parameter > tolerance) {
				curves[index++].divide(parameter, true);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else {
				path = this._clone(new Path().insertAbove(this, true));
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	isClockwise: function() {
		if (this._clockwise !== undefined)
			return this._clockwise;
		return Path.isClockwise(this._segments);
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
		this._clockwise = clockwise;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		if (this._clockwise !== undefined)
			this._clockwise = !this._clockwise;
		this._changed(9);
	},

	join: function(path) {
		if (path) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (!last2)
				return this;
			if (last1 && last1._point.equals(last2._point))
				path.reverse();
			var first2 = path.getFirstSegment();
			if (last1 && last1._point.equals(first2._point)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				var first1 = this.getFirstSegment();
				if (first1 && first1._point.equals(first2._point))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1 && first1._point.equals(last2._point)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path.closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.equals(last._point)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
		return this;
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isCollinear(i, j) {
			return segments[i].isCollinear(segments[j]);
		}

		function isOrthogonal(i) {
			return segments[i].isOrthogonal();
		}

		function isArc(i) {
			return segments[i].isOrthogonalArc();
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (!this.hasHandles() && segments.length === 4
				&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = this._clone(new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				}), insert, false);
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			return shape;
		}
		return null;
	},

	_hitTestSelf: function(point, options) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hitStroke = options.stroke && style.hasStroke(),
			hitFill = options.fill && style.hasFill(),
			hitCurves = options.curves,
			radius = hitStroke
					? style.getStrokeWidth() / 2
					: hitFill && options.tolerance > 0 || hitCurves
						? 0 : null;
		if (radius !== null) {
			if (radius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = radius * style.getMiterLimit();
				strokePadding = tolerancePadding.add(new Point(radius, radius));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			if (join !== 'round' || cap !== 'round') {
				area = new Path({ internal: true, closed: true });
				if (closed || segment._index > 0
						&& segment._index < numSegments - 1) {
					if (join !== 'round' && (segment._handleIn.isZero()
							|| segment._handleOut.isZero()))
						Path._addBevelJoin(segment, join, radius, miterLimit,
								addToArea, true);
				} else if (cap !== 'round') {
					Path._addSquareCap(segment, cap, radius, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
			return isCloseEnough(segment._point, strokePadding);
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (radius !== null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var parameter = loc.getParameter();
				if (parameter === 0 || parameter === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point) <= miterLimit
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hitFill && this._contains(point)
				|| loc && !hitStroke && !hitCurves
					? new HitResult('fill', this)
					: loc
						? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
							location: loc,
							point: loc.getPoint()
						})
						: null;
	}

}, Base.each(Curve.evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset, isParameter) {
			var loc = this.getLocationAt(offset, isParameter);
			return loc && loc[name]();
		};
	},
{
	beans: false,

	_getOffset: function(location) {
		var index = location && location.getIndex();
		if (index != null) {
			var curves = this.getCurves(),
				offset = 0;
			for (var i = 0; i < index; i++)
				offset += curves[i].getLength();
			var curve = curves[index],
				parameter = location.getParameter();
			if (parameter > 0)
				offset += curve.getPartLength(0, parameter);
			return offset;
		}
		return null;
	},

	getLocationOf: function() {
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getLocationAt: function(offset, isParameter) {
		var curves = this.getCurves(),
			length = 0;
		if (isParameter) {
			var index = ~~offset,
				curve = curves[index];
			return curve ? curve.getLocationAt(offset - index, true) : null;
		}
		for (var i = 0, l = curves.length; i < l; i++) {
			var start = length,
				curve = curves[i];
			length += curve.getLength();
			if (length > offset) {
				return curve.getLocationAt(offset - start);
			}
		}
		if (offset <= this.getLength())
			return new CurveLocation(curves[curves.length - 1], 1);
		return null;
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function() {
		return this.getNearestLocation.apply(this, arguments).getPoint();
	}
}), new function() {

	function drawHandles(ctx, segments, matrix, size) {
		var half = size / 2;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
				ctx.fill();
			}
		}

		var coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			var state = segment._selectionState,
				pX = coords[0],
				pY = coords[1];
			if (state & 1)
				drawHandle(2);
			if (state & 2)
				drawHandle(4);
			ctx.fillRect(pX - half, pY - half, size, size);
			if (!(state & 4)) {
				var fillStyle = ctx.fillStyle;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
				ctx.fillStyle = fillStyle;
			}
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(segment) {
			if (matrix) {
				segment._transformCoordinates(matrix, coords, false);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(segments[i]);
		if (path._closed && length > 0)
			drawSegment(segments[0]);
	}

	return {
		_draw: function(ctx, param, strokeMatrix) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip,
				style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			if (!dontStart)
				ctx.beginPath();

			if (!dontStart && this._currentPath) {
				ctx.currentPath = this._currentPath;
			} else if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this, strokeMatrix);
				if (this._closed)
					ctx.closePath();
				if (!dontStart)
					this._currentPath = ctx.currentPath;
			}

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx);
				if (hasFill) {
					ctx.fill(style.getWindingRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var iterator = new PathIterator(this, 32, 0.25,
								strokeMatrix),
							length = iterator.length,
							from = -style.getDashOffset(), to,
							i = 0;
						from = from % length;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								iterator.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
		}
	};
}, new function() {

	function getFirstControlPoints(rhs) {
		var n = rhs.length,
			x = [],
			tmp = [],
			b = 2;
		x[0] = rhs[0] / b;
		for (var i = 1; i < n; i++) {
			tmp[i] = 1 / b;
			b = (i < n - 1 ? 4 : 2) - tmp[i];
			x[i] = (rhs[i] - x[i - 1]) / b;
		}
		for (var i = 1; i < n; i++) {
			x[n - i - 1] -= tmp[n - i] * x[n - i];
		}
		return x;
	}

	return {
		smooth: function() {
			var segments = this._segments,
				size = segments.length,
				closed = this._closed,
				n = size,
				overlap = 0;
			if (size <= 2)
				return;
			if (closed) {
				overlap = Math.min(size, 4);
				n += Math.min(size, overlap) * 2;
			}
			var knots = [];
			for (var i = 0; i < size; i++)
				knots[i + overlap] = segments[i]._point;
			if (closed) {
				for (var i = 0; i < overlap; i++) {
					knots[i] = segments[i + size - overlap]._point;
					knots[i + size + overlap] = segments[i]._point;
				}
			} else {
				n--;
			}
			var rhs = [];

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
			rhs[0] = knots[0]._x + 2 * knots[1]._x;
			rhs[n - 1] = 3 * knots[n - 1]._x;
			var x = getFirstControlPoints(rhs);

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
			rhs[0] = knots[0]._y + 2 * knots[1]._y;
			rhs[n - 1] = 3 * knots[n - 1]._y;
			var y = getFirstControlPoints(rhs);

			if (closed) {
				for (var i = 0, j = size; i < overlap; i++, j++) {
					var f1 = i / overlap,
						f2 = 1 - f1,
						ie = i + overlap,
						je = j + overlap;
					x[j] = x[i] * f1 + x[j] * f2;
					y[j] = y[i] * f1 + y[j] * f2;
					x[je] = x[ie] * f2 + x[je] * f1;
					y[je] = y[ie] * f2 + y[je] * f1;
				}
				n--;
			}
			var handleIn = null;
			for (var i = overlap; i <= n - overlap; i++) {
				var segment = segments[i - overlap];
				if (handleIn)
					segment.setHandleIn(handleIn.subtract(segment._point));
				if (i < n) {
					segment.setHandleOut(
							new Point(x[i], y[i]).subtract(segment._point));
					handleIn = i < n - 1
							? new Point(
								2 * knots[i + 1]._x - x[i + 1],
								2 * knots[i + 1]._y - y[i + 1])
							: new Point(
								(knots[n]._x + x[n - 1]) / 2,
								(knots[n]._y + y[n - 1]) / 2);
				}
			}
			if (closed && handleIn) {
				var segment = this._segments[0];
				segment.setHandleIn(handleIn.subtract(segment._point));
			}
		}
	};
}, new function() {
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (segments.length === 0)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				t = Base.pick(Base.read(arguments), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(arguments),
				through,
				peek = Base.peek(arguments),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(arguments) <= 2) {
				through = to;
				to = Point.read(arguments);
			} else {
				var radius = Size.read(arguments);
				if (radius.isZero())
					return this.lineTo(to);
				var rotation = Base.read(arguments),
					clockwise = !!Base.read(arguments),
					large = !!Base.read(arguments),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					abs = Math.abs,
					epsilon = 1e-12,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq =  x * x,
					ySq =  y * y;
				var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < epsilon)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1)
							* Math.sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center);
				if (centerSide === 0) {
					extent = throughSide * Math.abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			var ext = Math.abs(extent),
				count = ext >= 360 ? 4 : Math.ceil(ext / 90),
				inc = extent / count,
				half = inc * Math.PI / 360,
				z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
				segments = [];
			for (var i = 0; i <= count; i++) {
				var pt = to,
					out = null;
				if (i < count) {
					out = vector.rotate(90).multiply(z);
					if (matrix) {
						pt = matrix._transformPoint(vector);
						out = matrix._transformPoint(vector.add(out))
								.subtract(pt);
					} else {
						pt = center.add(vector);
					}
				}
				if (i === 0) {
					current.setHandleOut(out);
				} else {
					var _in = vector.rotate(-90).multiply(z);
					if (matrix) {
						_in = matrix._transformPoint(vector.add(_in))
								.subtract(pt);
					}
					segments.push(new Segment(pt, _in, out));
				}
				vector = vector.rotate(inc);
			}
			this._add(segments);
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				parameter = Base.read(arguments),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var current = getCurrentSegment(this)._point,
				point = current.add(Point.read(arguments)),
				clockwise = Base.pick(Base.peek(arguments), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(arguments)));
			}
		},

		closePath: function(join) {
			this.setClosed(true);
			if (join)
				this.join();
		}
	};
}, {

	_getBounds: function(getter, matrix) {
		return Path[getter](this._segments, this._closed, this.getStyle(),
				matrix);
	},

statics: {
	isClockwise: function(segments) {
		var sum = 0;
		for (var i = 0, l = segments.length; i < l; i++)
			sum += Curve.getEdgeSum(Curve.getValues(
					segments[i], segments[i + 1 < l ? i + 1 : 0]));
		return sum > 0;
	},

	getBounds: function(segments, closed, style, matrix, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6), false),
			min = prevCoords.slice(0, 2),
			max = min.slice(),
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords, false);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i],
					prevCoords[i + 4],
					coords[i + 2],
					coords[i],
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, style, matrix) {
		if (!style.hasStroke())
			return Path.getBounds(segments, closed, style, matrix);
		var length = segments.length - (closed ? 0 : 1),
			radius = style.getStrokeWidth() / 2,
			padding = Path._getPenPadding(radius, matrix),
			bounds = Path.getBounds(segments, closed, style, matrix, padding),
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = radius * style.getMiterLimit();
		var joinBounds = new Rectangle(new Size(padding).multiply(2));

		function add(point) {
			bounds = bounds.include(matrix
				? matrix._transformPoint(point, point) : point);
		}

		function addRound(segment) {
			bounds = bounds.unite(joinBounds.setCenter(matrix
				? matrix._transformPoint(segment._point) : segment._point));
		}

		function addJoin(segment, join) {
			var handleIn = segment._handleIn,
				handleOut = segment._handleOut;
			if (join === 'round' || !handleIn.isZero() && !handleOut.isZero()
					&& handleIn.isCollinear(handleOut)) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, radius, miterLimit, add);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, radius, add);
			}
		}

		for (var i = 1; i < length; i++)
			addJoin(segments[i], join);
		if (closed) {
			addJoin(segments[0], join);
		} else if (length > 0) {
			addCap(segments[0], cap);
			addCap(segments[segments.length - 1], cap);
		}
		return bounds;
	},

	_getPenPadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var mx = matrix.shiftless(),
			hor = mx.transform(new Point(radius, 0)),
			ver = mx.transform(new Point(0, radius)),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = -Math.atan(b * tan / a),
			ty = Math.atan(b / (tan * a));
		return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPointAt(0, true),
			normal1 = curve1.getNormalAt(1, true),
			normal2 = curve2.getNormalAt(0, true),
			step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
		normal1.setLength(step);
		normal2.setLength(step);
		if (area) {
			addPoint(point);
			addPoint(point.add(normal1));
		}
		if (join === 'miter') {
			var corner = new Line(
					point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(
					point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit) {
				addPoint(corner);
				if (!area)
					return;
			}
		}
		if (!area)
			addPoint(point.add(normal1));
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, addPoint, area) {
		var point = segment._point,
			loc = segment.getLocation(),
			normal = loc.getNormal().multiply(radius);
		if (area) {
			addPoint(point.subtract(normal));
			addPoint(point.add(normal));
		}
		if (cap === 'square')
			point = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, style, matrix, strokePadding,
			joinPadding) {
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			for (var j = 0; j < 6; j += 2) {
				var padding = j === 0 ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	getRoughBounds: function(segments, closed, style, matrix) {
		var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
			joinRadius = strokeRadius;
		if (strokeRadius > 0) {
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
		}
		return Path.getHandleBounds(segments, closed, style, matrix,
				Path._getPenPadding(strokeRadius, matrix),
				Path._getPenPadding(joinRadius, matrix));
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert === false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props);
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			return createPath([
				new Segment(Point.readNamed(arguments, 'from')),
				new Segment(Point.readNamed(arguments, 'to'))
			], false, arguments);
		},

		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createEllipse(center, new Size(radius), arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.readNamed(arguments, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, arguments);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments);
			return createEllipse(ellipse.center, ellipse.radius, arguments);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var from = Point.readNamed(arguments, 'from'),
				through = Point.readNamed(arguments, 'through'),
				to = Point.readNamed(arguments, 'to'),
				props = Base.getNamed(arguments),
				path = new Path(props && props.insert === false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var center = Point.readNamed(arguments, 'center'),
				sides = Base.readNamed(arguments, 'sides'),
				radius = Base.readNamed(arguments, 'radius'),
				step = 360 / sides,
				three = !(sides % 3),
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, arguments);
		},

		Star: function() {
			var center = Point.readNamed(arguments, 'center'),
				points = Base.readNamed(arguments, 'points') * 2,
				radius1 = Base.readNamed(arguments, 'radius1'),
				radius2 = Base.readNamed(arguments, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, arguments);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items, _preserve) {
		items = insertChildren.base.call(this, index, items, _preserve, Path);
		for (var i = 0, l = !_preserve && items && items.length; i < l; i++) {
			var item = items[i];
			if (item._clockwise === undefined)
				item.setClockwise(item._index === 0);
		}
		return items;
	},

	reverse: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].reverse();
	},

	smooth: function() {
		for (var i = 0, l = this._children.length; i < l; i++)
			this._children[i].smooth();
	},

	reduce: function reduce() {
		if (this._children.length === 0) {
			var path = new Path(Item.NO_INSERT);
			path.insertAbove(this);
			path.setStyle(this._style);
			this.remove();
			return path;
		} else {
			return reduce.base.call(this);
		}
	},

	isClockwise: function() {
		var child = this.getFirstChild();
		return child && child.isClockwise();
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() !== !!clockwise)
			this.reverse();
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++)
			curves.push.apply(curves, children[i].getCurves());
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getFirstCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			paths.push(child.getPathData(_matrix && !mx.isIdentity()
					? _matrix.chain(mx) : mx, _precision));
		}
		return paths.join(' ');
	}
}, {
	_getChildHitTestOptions: function(options) {
		return options.class === Path || options.type === 'path'
				? options
				: new Base(options, { fill: false });
	},

	_draw: function(ctx, param, strokeMatrix) {
		var children = this._children;
		if (children.length === 0)
			return;

		if (this._currentPath) {
			ctx.currentPath = this._currentPath;
		} else {
			param = param.extend({ dontStart: true, dontFinish: true });
			ctx.beginPath();
			for (var i = 0, l = children.length; i < l; i++)
				children[i].draw(ctx, param, strokeMatrix);
			this._currentPath = ctx.currentPath;
		}

		if (!param.clip) {
			this._setStyles(ctx);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix, selectedItems) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			if (!selectedItems[child._id])
				child._drawSelected(ctx, mx.isIdentity() ? matrix
						: matrix.chain(mx));
		}
	}
}, new function() {
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && children.length === 0)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	var fields = {
		moveTo: function() {
			var current = getCurrentPath(this),
				path = current && current.isEmpty() ? current : new Path();
			if (path !== current)
				this.addChild(path);
			path.moveTo.apply(path, arguments);
		},

		moveBy: function() {
			var current = getCurrentPath(this, true),
				last = current && current.getLastSegment(),
				point = Point.read(arguments);
			this.moveTo(last ? point.add(last._point) : point);
		},

		closePath: function(join) {
			getCurrentPath(this, true).closePath(join);
		}
	};

	Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',
			'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],
			function(key) {
				fields[key] = function() {
					var path = getCurrentPath(this, true);
					path[key].apply(path, arguments);
				};
			}
	);

	return fields;
});

PathItem.inject(new function() {
	var operators = {
		unite: function(w) {
			return w === 1 || w === 0;
		},

		intersect: function(w) {
			return w === 2;
		},

		subtract: function(w) {
			return w === 1;
		},

		exclude: function(w) {
			return w === 1;
		}
	};

	function computeBoolean(path1, path2, operation) {
		var operator = operators[operation];
		function preparePath(path) {
			return path.clone(false).reduce().reorient().transform(null, true,
					true);
		}

		var _path1 = preparePath(path1),
			_path2 = path2 && path1 !== path2 && preparePath(path2);
		if (_path2 && /^(subtract|exclude)$/.test(operation)
				^ (_path2.isClockwise() !== _path1.isClockwise()))
			_path2.reverse();
		splitPath(_path1.getIntersections(_path2, null, true));

		var chain = [],
			segments = [],
			monoCurves = [],
			tolerance = 0.000001;

		function collect(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				segments.push.apply(segments, path._segments);
				monoCurves.push.apply(monoCurves, path._getMonoCurves());
			}
		}

		collect(_path1._children || [_path1]);
		if (_path2)
			collect(_path2._children || [_path2]);
		segments.sort(function(a, b) {
			var _a = a._intersection,
				_b = b._intersection;
			return !_a && !_b || _a && _b ? 0 : _a ? -1 : 1;
		});
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			if (segment._winding != null)
				continue;
			chain.length = 0;
			var startSeg = segment,
				totalLength = 0,
				windingSum = 0;
			do {
				var length = segment.getCurve().getLength();
				chain.push({ segment: segment, length: length });
				totalLength += length;
				segment = segment.getNext();
			} while (segment && !segment._intersection && segment !== startSeg);
			for (var j = 0; j < 3; j++) {
				var length = totalLength * (j + 1) / 4;
				for (var k = 0, m = chain.length; k < m; k++) {
					var node = chain[k],
						curveLength = node.length;
					if (length <= curveLength) {
						if (length < tolerance
								|| curveLength - length < tolerance)
							length = curveLength / 2;
						var curve = node.segment.getCurve(),
							pt = curve.getPointAt(length),
							hor = curve.isLinear() && Math.abs(curve
									.getTangentAt(0.5, true).y) < tolerance,
							path = curve._path;
						if (path._parent instanceof CompoundPath)
							path = path._parent;
						windingSum += operation === 'subtract' && _path2
							&& (path === _path1 && _path2._getWinding(pt, hor)
							|| path === _path2 && !_path1._getWinding(pt, hor))
							? 0
							: getWinding(pt, monoCurves, hor);
						break;
					}
					length -= curveLength;
				}
			}
			var winding = Math.round(windingSum / 3);
			for (var j = chain.length - 1; j >= 0; j--)
				chain[j].segment._winding = winding;
		}
		var result = new CompoundPath(Item.NO_INSERT);
		result.insertAbove(path1);
		result.addChildren(tracePaths(segments, operator), true);
		result = result.reduce();
		result.setStyle(path1._style);
		return result;
	}

	function splitPath(intersections) {
		var tMin = 0.000001,
			tMax = 1 - tMin,
			linearHandles;

		function resetLinear() {
			for (var i = 0, l = linearHandles.length; i < l; i++)
				linearHandles[i].set(0, 0);
		}

		for (var i = intersections.length - 1, curve, prev; i >= 0; i--) {
			var loc = intersections[i],
				t = loc._parameter;
			if (prev && prev._curve === loc._curve && prev._parameter > 0) {
				t /= prev._parameter;
			} else {
				curve = loc._curve;
				if (linearHandles)
					resetLinear();
				linearHandles = curve.isLinear() ? [
						curve._segment1._handleOut,
						curve._segment2._handleIn
					] : null;
			}
			var newCurve,
				segment;
			if (newCurve = curve.divide(t, true, true)) {
				segment = newCurve._segment1;
				curve = newCurve.getPrevious();
				if (linearHandles)
					linearHandles.push(segment._handleOut, segment._handleIn);
			} else {
				segment = t < tMin
					? curve._segment1
					: t > tMax
						? curve._segment2
						: curve.getPartLength(0, t) < curve.getPartLength(t, 1)
							? curve._segment1
							: curve._segment2;
			}
			segment._intersection = loc.getIntersection();
			loc._segment = segment;
			prev = loc;
		}
		if (linearHandles)
			resetLinear();
	}

	function getWinding(point, curves, horizontal, testContains) {
		var tolerance = 0.000001,
			tMin = tolerance,
			tMax = 1 - tMin,
			px = point.x,
			py = point.y,
			windLeft = 0,
			windRight = 0,
			roots = [],
			abs = Math.abs;
		if (horizontal) {
			var yTop = -Infinity,
				yBottom = Infinity,
				yBefore = py - tolerance,
				yAfter = py + tolerance;
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if (Curve.solveCubic(values, 0, px, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--) {
						var y = Curve.getPoint(values, roots[j]).y;
						if (y < yBefore && y > yTop) {
							yTop = y;
						} else if (y > yAfter && y < yBottom) {
							yBottom = y;
						}
					}
				}
			}
			yTop = (yTop + py) / 2;
			yBottom = (yBottom + py) / 2;
			if (yTop > -Infinity)
				windLeft = getWinding(new Point(px, yTop), curves);
			if (yBottom < Infinity)
				windRight = getWinding(new Point(px, yBottom), curves);
		} else {
			var xBefore = px - tolerance,
				xAfter = px + tolerance;
			var startCounted = false,
				prevCurve,
				prevT;
			for (var i = 0, l = curves.length; i < l; i++) {
				var curve = curves[i],
					values = curve.values,
					winding = curve.winding;
				if (winding && (winding === 1
						&& py >= values[1] && py <= values[7]
						|| py >= values[7] && py <= values[1])
					&& Curve.solveCubic(values, 1, py, roots, 0, 1) === 1) {
					var t = roots[0];
					if (!(
						t > tMax && startCounted && curve.next !== curves[i + 1]
						|| t < tMin && prevT > tMax
							&& curve.previous === prevCurve)) {
						var x = Curve.getPoint(values, t).x,
							slope = Curve.getTangent(values, t).y,
							counted = false;
						if (Numerical.isZero(slope) && !Curve.isLinear(values)
								|| t < tMin && slope * Curve.getTangent(
									curve.previous.values, 1).y < 0
								|| t > tMax && slope * Curve.getTangent(
									curve.next.values, 0).y < 0) {
							if (testContains && x >= xBefore && x <= xAfter) {
								++windLeft;
								++windRight;
								counted = true;
							}
						} else if (x <= xBefore) {
							windLeft += winding;
							counted = true;
						} else if (x >= xAfter) {
							windRight += winding;
							counted = true;
						}
						if (curve.previous !== curves[i - 1])
							startCounted = t < tMin && counted;
					}
					prevCurve = curve;
					prevT = t;
				}
			}
		}
		return Math.max(abs(windLeft), abs(windRight));
	}

	function tracePaths(segments, operator, selfOp) {
		var paths = [],
			tMin = 0.000001,
			tMax = 1 - tMin;
		for (var i = 0, seg, startSeg, l = segments.length; i < l; i++) {
			seg = startSeg = segments[i];
			if (seg._visited || !operator(seg._winding))
				continue;
			var path = new Path(Item.NO_INSERT),
				inter = seg._intersection,
				startInterSeg = inter && inter._segment,
				added = false,
				dir = 1;
			do {
				var handleIn = dir > 0 ? seg._handleIn : seg._handleOut,
					handleOut = dir > 0 ? seg._handleOut : seg._handleIn,
					interSeg;
				if (added && (!operator(seg._winding) || selfOp)
						&& (inter = seg._intersection)
						&& (interSeg = inter._segment)
						&& interSeg !== startSeg) {
					if (selfOp) {
						seg._visited = interSeg._visited;
						seg = interSeg;
						dir = 1;
					} else {
						var c1 = seg.getCurve();
						if (dir > 0)
							c1 = c1.getPrevious();
						var t1 = c1.getTangentAt(dir < 1 ? tMin : tMax, true),
							c4 = interSeg.getCurve(),
							c3 = c4.getPrevious(),
							t3 = c3.getTangentAt(tMax, true),
							t4 = c4.getTangentAt(tMin, true),
							w3 = t1.cross(t3),
							w4 = t1.cross(t4);
						if (w3 * w4 !== 0) {
							var curve = w3 < w4 ? c3 : c4,
								nextCurve = operator(curve._segment1._winding)
									? curve
									: w3 < w4 ? c4 : c3,
								nextSeg = nextCurve._segment1;
							dir = nextCurve === c3 ? -1 : 1;
							if (nextSeg._visited && seg._path !== nextSeg._path
										|| !operator(nextSeg._winding)) {
								dir = 1;
							} else {
								seg._visited = interSeg._visited;
								seg = interSeg;
								if (nextSeg._visited)
									dir = 1;
							}
						} else {
							dir = 1;
						}
					}
					handleOut = dir > 0 ? seg._handleOut : seg._handleIn;
				}
				path.add(new Segment(seg._point, added && handleIn, handleOut));
				added = true;
				seg._visited = true;
				seg = dir > 0 ? seg.getNext() : seg. getPrevious();
			} while (seg && !seg._visited
					&& seg !== startSeg && seg !== startInterSeg
					&& (seg._intersection || operator(seg._winding)));
			if (seg && (seg === startSeg || seg === startInterSeg)) {
				path.firstSegment.setHandleIn((seg === startInterSeg
						? startInterSeg : seg)._handleIn);
				path.setClosed(true);
			} else {
				path.lastSegment._handleOut.set(0, 0);
			}
			if (path._segments.length >
					(path._closed ? path.isLinear() ? 2 : 0 : 1))
				paths.push(path);
		}
		return paths;
	}

	return {
		_getWinding: function(point, horizontal, testContains) {
			return getWinding(point, this._getMonoCurves(),
					horizontal, testContains);
		},

		unite: function(path) {
			return computeBoolean(this, path, 'unite');
		},

		intersect: function(path) {
			return computeBoolean(this, path, 'intersect');
		},

		subtract: function(path) {
			return computeBoolean(this, path, 'subtract');
		},

		exclude: function(path) {
			return computeBoolean(this, path, 'exclude');
		},

		divide: function(path) {
			return new Group([this.subtract(path), this.intersect(path)]);
		}
	};
});

Path.inject({
	_getMonoCurves: function() {
		var monoCurves = this._monoCurves,
			prevCurve;

		function insertCurve(v) {
			var y0 = v[1],
				y1 = v[7],
				curve = {
					values: v,
					winding: y0 === y1
						? 0
						: y0 > y1
							? -1
							: 1,
					previous: prevCurve,
					next: null
				};
			if (prevCurve)
				prevCurve.next = curve;
			monoCurves.push(curve);
			prevCurve = curve;
		}

		function handleCurve(v) {
			if (Curve.getLength(v) === 0)
				return;
			var y0 = v[1],
				y1 = v[3],
				y2 = v[5],
				y3 = v[7];
			if (Curve.isLinear(v)) {
				insertCurve(v);
			} else {
				var a = 3 * (y1 - y2) - y0 + y3,
					b = 2 * (y0 + y2) - 4 * y1,
					c = y1 - y0,
					tolerance = 0.000001,
					roots = [];
				var count = Numerical.solveQuadratic(a, b, c, roots, tolerance,
						1 - tolerance);
				if (count === 0) {
					insertCurve(v);
				} else {
					roots.sort();
					var t = roots[0],
						parts = Curve.subdivide(v, t);
					insertCurve(parts[0]);
					if (count > 1) {
						t = (roots[1] - t) / (1 - t);
						parts = Curve.subdivide(parts[1], t);
						insertCurve(parts[0]);
					}
					insertCurve(parts[1]);
				}
			}
		}

		if (!monoCurves) {
			monoCurves = this._monoCurves = [];
			var curves = this.getCurves(),
				segments = this._segments;
			for (var i = 0, l = curves.length; i < l; i++)
				handleCurve(curves[i].getValues());
			if (!this._closed && segments.length > 1) {
				var p1 = segments[segments.length - 1]._point,
					p2 = segments[0]._point,
					p1x = p1._x, p1y = p1._y,
					p2x = p2._x, p2y = p2._y;
				handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);
			}
			if (monoCurves.length > 0) {
				var first = monoCurves[0],
					last = monoCurves[monoCurves.length - 1];
				first.previous = last;
				last.next = first;
			}
		}
		return monoCurves;
	},

	getInteriorPoint: function() {
		var bounds = this.getBounds(),
			point = bounds.getCenter(true);
		if (!this.contains(point)) {
			var curves = this._getMonoCurves(),
				roots = [],
				y = point.y,
				xIntercepts = [];
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if ((curves[i].winding === 1
						&& y >= values[1] && y <= values[7]
						|| y >= values[7] && y <= values[1])
						&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--)
						xIntercepts.push(Curve.getPoint(values, roots[j]).x);
				}
				if (xIntercepts.length > 1)
					break;
			}
			point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
		}
		return point;
	},

	reorient: function() {
		this.setClockwise(true);
		return this;
	}
});

CompoundPath.inject({
	_getMonoCurves: function() {
		var children = this._children,
			monoCurves = [];
		for (var i = 0, l = children.length; i < l; i++)
			monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
		return monoCurves;
	},

	reorient: function() {
		var children = this.removeChildren().sort(function(a, b) {
			return b.getBounds().getArea() - a.getBounds().getArea();
		});
		if (children.length > 0) {
			this.addChildren(children);
			var clockwise = children[0].isClockwise();
			for (var i = 1, l = children.length; i < l; i++) {
				var point = children[i].getInteriorPoint(),
					counters = 0;
				for (var j = i - 1; j >= 0; j--) {
					if (children[j].contains(point))
						counters++;
				}
				children[i].setClockwise(counters % 2 === 0 && clockwise);
			}
		}
		return this;
	}
});

var PathIterator = Base.extend({
	_class: 'PathIterator',

	initialize: function(path, maxRecursion, tolerance, matrix) {
		var curves = [],
			parts = [],
			length = 0,
			minDifference = 1 / (maxRecursion || 32),
			segments = path._segments,
			segment1 = segments[0],
			segment2;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2, matrix);
			curves.push(curve);
			computeParts(curve, segment1._index, 0, 1);
		}

		function computeParts(curve, index, minT, maxT) {
			if ((maxT - minT) > minDifference
					&& !Curve.isFlatEnough(curve, tolerance || 0.25)) {
				var split = Curve.subdivide(curve),
					halfT = (minT + maxT) / 2;
				computeParts(split[0], index, minT, halfT);
				computeParts(split[1], index, halfT, maxT);
			} else {
				var x = curve[6] - curve[0],
					y = curve[7] - curve[1],
					dist = Math.sqrt(x * x + y * y);
				if (dist > 0.000001) {
					length += dist;
					parts.push({
						offset: length,
						value: maxT,
						index: index
					});
				}
			}
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2, segments[0]);

		this.curves = curves;
		this.parts = parts;
		this.length = length;
		this.index = 0;
	},

	getParameterAt: function(offset) {
		var i, j = this.index;
		for (;;) {
			i = j;
			if (j == 0 || this.parts[--j].offset < offset)
				break;
		}
		for (var l = this.parts.length; i < l; i++) {
			var part = this.parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = this.parts[i - 1];
				var prevVal = prev && prev.index == part.index ? prev.value : 0,
					prevLen = prev ? prev.offset : 0;
				return {
					value: prevVal + (part.value - prevVal)
						* (offset - prevLen) / (part.offset - prevLen),
					index: part.index
				};
			}
		}
		var part = this.parts[this.parts.length - 1];
		return {
			value: 1,
			index: part.index
		};
	},

	drawPart: function(ctx, from, to) {
		from = this.getParameterAt(from);
		to = this.getParameterAt(to);
		for (var i = from.index; i <= to.index; i++) {
			var curve = Curve.getPart(this.curves[i],
					i == from.index ? from.value : 0,
					i == to.index ? to.value : 1);
			if (i == from.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
}, Base.each(Curve.evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset, weighted) {
			var param = this.getParameterAt(offset);
			return Curve[name](this.curves[param.index], param.value, weighted);
		};
	}, {})
);

var PathFitter = Base.extend({
	initialize: function(path, error) {
		var points = this.points = [],
			segments = path._segments,
			prev;
		for (var i = 0, l = segments.length; i < l; i++) {
			var point = segments[i].point.clone();
			if (!prev || !prev.equals(point)) {
				points.push(point);
				prev = point;
			}
		}

		if (path._closed) {
			this.closed = true;
			points.unshift(points[points.length - 1]);
			points.push(points[1]);
		}

		this.error = error;
	},

	fit: function() {
		var points = this.points,
			length = points.length,
			segments = this.segments = length > 0
					? [new Segment(points[0])] : [];
		if (length > 1)
			this.fitCubic(0, length - 1,
				points[1].subtract(points[0]).normalize(),
				points[length - 2].subtract(points[length - 1]).normalize());

		if (this.closed) {
			segments.shift();
			segments.pop();
		}

		return segments;
	},

	fitCubic: function(first, last, tan1, tan2) {
		if (last - first == 1) {
			var pt1 = this.points[first],
				pt2 = this.points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve([pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(this.error, this.error * this.error),
			split,
			parametersInOrder = true;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < this.error && parametersInOrder) {
				this.addCurve(curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			parametersInOrder = this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var V1 = this.points[split - 1].subtract(this.points[split]),
			V2 = this.points[split].subtract(this.points[split + 1]),
			tanCenter = V1.add(V2).divide(2).normalize();
		this.fitCubic(first, split, tan1, tanCenter);
		this.fitCubic(split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(curve) {
		var prev = this.segments[this.segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		this.segments.push(
				new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-12,
			pt1 = this.points[first],
			pt2 = this.points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = this.points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1, alpha2;
		if (Math.abs(detC0C1) > epsilon) {
			var detC0X	= C[0][0] * X[1]	- C[1][0] * X[0],
				detXC1	= X[0]	  * C[1][1] - X[1]	  * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			if (Math.abs(c0) > epsilon) {
				alpha1 = alpha2 = X[0] / c0;
			} else if (Math.abs(c1) > epsilon) {
				alpha1 = alpha2 = X[1] / c1;
			} else {
				alpha1 = alpha2 = 0;
			}
		}

		var segLength = pt2.getDistance(pt1),
			eps = epsilon * segLength,
			handle1,
			handle2;
		if (alpha1 < eps || alpha2 < eps) {
			alpha1 = alpha2 = segLength / 3;
		} else {
			var line = pt2.subtract(pt1);
			handle1 = tan1.normalize(alpha1);
			handle2 = tan2.normalize(alpha2);
			if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
				alpha1 = alpha2 = segLength / 3;
				handle1 = handle2 = null;
			}
		}

		return [pt1, pt1.add(handle1 || tan1.normalize(alpha1)),
				pt2.add(handle2 || tan2.normalize(alpha2)), pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
		for (var i = 1, l = u.length; i < l; i++) {
			if (u[i] <= u[i - 1])
				return false;
		}
		return true;
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		if (Math.abs(df) < 0.000001)
			return u;
		return u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y;
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_boundsSelected: true,
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsGetter: 'getBounds',

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	_clone: function _clone(copy, insert, includeMatrix) {
		copy.setContent(this._content);
		return _clone.base.call(this, copy, insert, includeMatrix);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(265);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	clone: function(insert) {
		return this._clone(new PointText(Item.NO_INSERT), insert);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx) {
		if (!this._content)
			return;
		this._setStyles(ctx);
		var style = this._style,
			lines = this._lines,
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (style.hasFill()) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(getter, matrix) {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		var bounds = new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
		return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
	}
});

var Color = Base.extend(new function() {
	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		colorCache = {},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
			components;
		if (match) {
			components = [0, 0, 0];
			for (var i = 0; i < 3; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^rgba?\((.*)\)$/)) {
			components = match[1].split(',');
			for (var i = 0, l = components.length; i < l; i++) {
				var value = +components[i];
				components[i] = i < 3 ? value / 255 : value;
			}
		} else {
			var cached = colorCache[string];
			if (!cached) {
				if (!colorCtx) {
					colorCtx = CanvasProvider.getContext(1, 1);
					colorCtx.globalCompositeOperation = 'copy';
				}
				colorCtx.fillStyle = 'rgba(0,0,0,0)';
				colorCtx.fillStyle = string;
				colorCtx.fillRect(0, 0, 1, 1);
				var data = colorCtx.getImageData(0, 0, 1, 1).data;
				cached = colorCache[string] = [
					data[0] / 255,
					data[1] / 255,
					data[2] / 255
				];
			}
			components = cached.slice();
		}
		return components;
	}

	var hsbIndices = [
		[0, 3, 1],
		[2, 0, 1],
		[1, 0, 3],
		[1, 2, 0],
		[3, 1, 0],
		[0, 1, 2]
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:			 (r - g) / delta + 4) * 60;
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h),
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,
					b * (1 - s),
					b * (1 - s * f),
					b * (1 - s * (1 - f))
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:			 (r - g) / delta + 4) * 60,
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = name === 'gradient'
					? function(value) {
						var current = this._components[0];
						value = Gradient.read(Array.isArray(value) ? value
								: arguments, 0, { readNull: true });
						if (current !== value) {
							if (current)
								current._removeOwner(this);
							if (value)
								value._addOwner(this);
						}
						return value;
					}
					: type === 'gradient'
						? function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
						: function(value) {
							return value == null || isNaN(value) ? 0 : value;
						};

			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				this._components[index] = parser.call(this, value);
				this._changed();
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var slice = Array.prototype.slice,
				args = arguments,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (this.__read)
						read = 1;
					args = slice.call(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (this.__read)
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					if (values.length > length)
						values = slice.call(values, 0, length);
				} else if (argType === 'string') {
					type = 'rgb';
					components = fromCSS(arg);
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type];
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && i === 0 && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (this.__read && type)
					read = 1;
			}
			this._type = type || 'rgb';
			this._id = UID.get(Color);
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (this.__read)
				this.__read = read;
		},

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner)
				this._owner._changed(65);
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color, true)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this._alpha === col._alpha
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx) {
			if (this._canvasStyle)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				canvasGradient;
			if (gradient._radial) {
				var radius = destination.getDistance(origin),
					highlight = components[3];
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i];
				canvasGradient.addColorStop(stop._rampPoint,
						stop._color.toCanvasStyle());
			}
			return this._canvasStyle = canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			}
		}
	});
}, new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

Base.each(Color._types, function(properties, type) {
	var ctor = this[Base.capitalize(type) + 'Color'] = function(arg) {
			var argType = arg != null && typeof arg,
				components = argType === 'object' && arg.length != null
					? arg
					: argType === 'string'
						? null
						: arguments;
			return components
					? new Color(type, components)
					: new Color(arg);
		};
	if (type.length == 3) {
		var acronym = type.toUpperCase();
		Color[acronym] = this[acronym + 'Color'] = ctor;
	}
}, Base.exports);

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = UID.get();
		if (stops && this._set(stops))
			stops = radial = null;
		if (!this._stops)
			this.setStops(stops || ['white', 'black']);
		if (this._radial == null)
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++)
			this._owners[i]._changed();
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (this._owners.length === 0)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++)
			stops[i] = this._stops[i].clone();
		return new Gradient(stops, this._radial);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (this.stops) {
			for (var i = 0, l = this._stops.length; i < l; i++)
				this._stops[i]._owner = undefined;
		}
		if (stops.length < 2)
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		this._stops = GradientStop.readAll(stops, 0, { clone: true });
		for (var i = 0, l = this._stops.length; i < l; i++) {
			var stop = this._stops[i];
			stop._owner = this;
			if (stop._defaultRamp)
				stop.setRampPoint(i / (l - 1));
		}
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient && this._class === gradient._class
				&& this._stops.length === gradient._stops.length) {
			for (var i = 0, l = this._stops.length; i < l; i++) {
				if (!this._stops[i].equals(gradient._stops[i]))
					return false;
			}
			return true;
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		if (arg0) {
			var color, rampPoint;
			if (arg1 === undefined && Array.isArray(arg0)) {
				color = arg0[0];
				rampPoint = arg0[1];
			} else if (arg0.color) {
				color = arg0.color;
				rampPoint = arg0.rampPoint;
			} else {
				color = arg0;
				rampPoint = arg1;
			}
			this.setColor(color);
			this.setRampPoint(rampPoint);
		}
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._rampPoint);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize([this._color, this._rampPoint], options, true,
				dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(65);
	},

	getRampPoint: function() {
		return this._rampPoint;
	},

	setRampPoint: function(rampPoint) {
		this._defaultRamp = rampPoint == null;
		this._rampPoint = rampPoint || 0;
		this._changed();
	},

	getColor: function() {
		return this._color;
	},

	setColor: function(color) {
		this._color = Color.read(arguments);
		if (this._color === color)
			this._color = color.clone();
		this._color._owner = this;
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._rampPoint == stop._rampPoint
				|| false;
	}
});

var Style = Base.extend(new function() {
	var defaults = {
		fillColor: undefined,
		strokeColor: undefined,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		strokeScaling: true,
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		windingRule: 'nonzero',
		shadowColor: undefined,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: undefined,
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		font: 'sans-serif',
		leading: null,
		justification: 'left'
	};

	var flags = {
		strokeWidth: 97,
		strokeCap: 97,
		strokeJoin: 97,
		strokeScaling: 105,
		miterLimit: 97,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9,
		leading: 9,
		justification: 9
	};

	var item = { beans: true },
		fields = {
			_defaults: defaults,
			_textDefaults: new Base(defaults, {
				fillColor: new Color()
			}),
			beans: true
		};

	Base.each(defaults, function(value, key) {
		var isColor = /Color$/.test(key),
			isPoint = key === 'shadowOffset',
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children;
			if (children && children.length > 0
					&& !(owner instanceof CompoundPath)) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			} else {
				var old = this._values[key];
				if (old !== value) {
					if (isColor) {
						if (old)
							old._owner = undefined;
						if (value && value.constructor === Color) {
							if (value._owner)
								value = value.clone();
							value._owner = owner;
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 65);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				value;
			if (!children || children.length === 0 || _dontMerge
					|| owner instanceof CompoundPath) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone)
						value = value.clone();
				} else {
					var ctor = isColor ? Color : isPoint ? Point : null;
					if (ctor && !(value && value.constructor === ctor)) {
						this._values[key] = value = ctor.read([value], 0,
								{ readNull: true, clone: true });
						if (value && isColor)
							value._owner = owner;
					}
				}
				return value;
			}
			for (var i = 0, l = children.length; i < l; i++) {
				var childValue = children[i]._style[get]();
				if (i === 0) {
					value = childValue;
				} else if (!Base.equals(value, childValue)) {
					return undefined;
				}
			}
			return value;
		};

		item[get] = function(_dontMerge) {
			return this._style[get](_dontMerge);
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Item.inject(item);
	return fields;
}, {
	_class: 'Style',

	initialize: function Style(style, _owner, _project) {
		this._values = {};
		this._owner = _owner;
		this._project = _owner && _owner._project || _project || paper.project;
		if (_owner instanceof TextItem)
			this._defaults = this._textDefaults;
		if (style)
			this.set(style);
	},

	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		return style === this || style && this._class === style._class
				&& Base.equals(this._values, style._values)
				|| false;
	},

	hasFill: function() {
		return !!this.getFillColor();
	},

	hasStroke: function() {
		return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		return !!this.getShadowColor() && this.getShadowBlur() > 0;
	},

	getView: function() {
		return this._project.getView();
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {
	function handlePrefix(el, name, set, value) {
		var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop || body.clientTop || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return DomElement.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return DomElement.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return DomElement.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !DomElement.isInvisible(el)
					&& DomElement.getViewportBounds(el).intersects(
						DomElement.getBounds(el, true));
		},

		getPrefixed: function(el, name) {
			return handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var DomEvent = {
	add: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.addEventListener(parts[i], func, false);
		}
	},

	remove: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.removeEventListener(parts[i], func, false);
		}
	},

	getPoint: function(event) {
		var pos = event.targetTouches
				? event.targetTouches.length
					? event.targetTouches[0]
					: event.changedTouches[0]
				: event;
		return new Point(
			pos.pageX || pos.clientX + document.documentElement.scrollLeft,
			pos.pageY || pos.clientY + document.documentElement.scrollTop
		);
	},

	getTarget: function(event) {
		return event.target || event.srcElement;
	},

	getRelatedTarget: function(event) {
		return event.relatedTarget || event.toElement;
	},

	getOffset: function(event, target) {
		return DomEvent.getPoint(event).subtract(DomElement.getOffset(
				target || DomEvent.getTarget(event)));
	},

	stop: function(event) {
		event.stopPropagation();
		event.preventDefault();
	}
};

DomEvent.requestAnimationFrame = new function() {
	var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
		requested = false,
		callbacks = [],
		focused = true,
		timer;

	DomEvent.add(window, {
		focus: function() {
			focused = true;
		},
		blur: function() {
			focused = false;
		}
	});

	function handleCallbacks() {
		for (var i = callbacks.length - 1; i >= 0; i--) {
			var entry = callbacks[i],
				func = entry[0],
				el = entry[1];
			if (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'
					|| focused) && DomElement.isInView(el)) {
				callbacks.splice(i, 1);
				func();
			}
		}
		if (nativeRequest) {
			if (callbacks.length) {
				nativeRequest(handleCallbacks);
			} else {
				requested = false;
			}
		}
	}

	return function(callback, element) {
		callbacks.push([callback, element]);
		if (nativeRequest) {
			if (!requested) {
				nativeRequest(handleCallbacks);
				requested = true;
			}
		} else if (!timer) {
			timer = setInterval(handleCallbacks, 1000 / 60);
		}
	};
};

var View = Base.extend(Emitter, {
	_class: 'View',

	initialize: function View(project, element) {
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		var size;
		if (!this._pixelRatio)
			this._pixelRatio = window.devicePixelRatio || 1;
		this._id = element.getAttribute('id');
		if (this._id == null)
			element.setAttribute('id', this._id = 'view-' + View._id++);
		DomEvent.add(element, this._viewEvents);
		var none = 'none';
		DomElement.setPrefixed(element.style, {
			userSelect: none,
			touchAction: none,
			touchCallout: none,
			contentZooming: none,
			userDrag: none,
			tapHighlightColor: 'rgba(0,0,0,0)'
		});

		function getSize(name) {
			return element[name] || parseInt(element.getAttribute(name), 10);
		};

		function getCanvasSize() {
			var size = DomElement.getSize(element);
			return size.isNaN() || size.isZero()
					? new Size(getSize('width'), getSize('height'))
					: size;
		};

		if (PaperScope.hasAttribute(element, 'resize')) {
			var that = this;
			DomEvent.add(window, this._windowEvents = {
				resize: function() {
					that.setViewSize(getCanvasSize());
				}
			});
		}
		this._setViewSize(size = getCanvasSize());
		if (PaperScope.hasAttribute(element, 'stats')
				&& typeof Stats !== 'undefined') {
			this._stats = new Stats();
			var stats = this._stats.domElement,
				style = stats.style,
				offset = DomElement.getOffset(element);
			style.position = 'absolute';
			style.left = offset.x + 'px';
			style.top = offset.y + 'px';
			document.body.appendChild(stats);
		}
		View._views.push(this);
		View._viewsById[this._id] = this;
		this._viewSize = size;
		(this._matrix = new Matrix())._owner = this;
		this._zoom = 1;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		if (this._project._view === this)
			this._project._view = null;
		DomEvent.remove(this._element, this._viewEvents);
		DomEvent.remove(window, this._windowEvents);
		this._element = this._project = null;
		this.off('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: {
		onFrame: {
			install: function() {
				this.play();
			},

			uninstall: function() {
				this.pause();
			}
		},

		onResize: {}
	},

	_animate: false,
	_time: 0,
	_count: 0,

	_requestFrame: function() {
		var that = this;
		DomEvent.requestAnimationFrame(function() {
			that._requested = false;
			if (!that._animate)
				return;
			that._requestFrame();
			that._handleFrame();
		}, this._element);
		this._requested = true;
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._before ? now - this._before : 0;
		this._before = now;
		this._handlingFrame = true;
		this.emit('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
		this._handlingFrame = false;
		this.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.on('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.off('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.emit('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_update: function() {
		this._project._needsUpdate = true;
		if (this._handlingFrame)
			return;
		if (this._animate) {
			this._handleFrame();
		} else {
			this.update();
		}
	},

	_changed: function(flags) {
		if (flags & 1)
			this._project._needsUpdate = true;
	},

	_transform: function(matrix) {
		this._matrix.concatenate(matrix);
		this._bounds = null;
		this._update();
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._viewSize.set(size.width, size.height);
		this._setViewSize(size);
		this._bounds = null;
		this.emit('resize', {
			size: size,
			delta: delta
		});
		this._update();
	},

	_setViewSize: function(size) {
		var element = this._element;
		element.width = size.width;
		element.height = size.height;
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function() {
		var center = Point.read(arguments);
		this.scrollBy(center.subtract(this.getCenter()));
	},

	getZoom: function() {
		return this._zoom;
	},

	setZoom: function(zoom) {
		this._transform(new Matrix().scale(zoom / this._zoom,
			this.getCenter()));
		this._zoom = zoom;
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	scrollBy: function() {
		this._transform(new Matrix().translate(Point.read(arguments).negate()));
	},

	play: function() {
		this._animate = true;
		if (!this._requested)
			this._requestFrame();
	},

	pause: function() {
		this._animate = false;
	},

	draw: function() {
		this.update();
	},

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	}

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			if (typeof element === 'string')
				element = document.getElementById(element);
			return new CanvasView(project, element);
		}
	}
}, new function() {
	var tool,
		prevFocus,
		tempFocus,
		dragging = false;

	function getView(event) {
		var target = DomEvent.getTarget(event);
		return target.getAttribute && View._viewsById[target.getAttribute('id')];
	}

	function viewToProject(view, event) {
		return view.viewToProject(DomEvent.getOffset(event, view._element));
	}

	function updateFocus() {
		if (!View._focused || !View._focused.isVisible()) {
			for (var i = 0, l = View._views.length; i < l; i++) {
				var view = View._views[i];
				if (view && view.isVisible()) {
					View._focused = tempFocus = view;
					break;
				}
			}
		}
	}

	function handleMouseMove(view, point, event) {
		view._handleEvent('mousemove', point, event);
		var tool = view._scope.tool;
		if (tool) {
			tool._handleEvent(dragging && tool.responds('mousedrag')
					? 'mousedrag' : 'mousemove', point, event);
		}
		view.update();
		return tool;
	}

	var navigator = window.navigator,
		mousedown, mousemove, mouseup;
	if (navigator.pointerEnabled || navigator.msPointerEnabled) {
		mousedown = 'pointerdown MSPointerDown';
		mousemove = 'pointermove MSPointerMove';
		mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
	} else {
		mousedown = 'touchstart';
		mousemove = 'touchmove';
		mouseup = 'touchend touchcancel';
		if (!('ontouchstart' in window && navigator.userAgent.match(
				/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
			mousedown += ' mousedown';
			mousemove += ' mousemove';
			mouseup += ' mouseup';
		}
	}

	var viewEvents = {
		'selectstart dragstart': function(event) {
			if (dragging)
				event.preventDefault();
		}
	};

	var docEvents = {
		mouseout: function(event) {
			var view = View._focused,
				target = DomEvent.getRelatedTarget(event);
			if (view && (!target || target.nodeName === 'HTML'))
				handleMouseMove(view, viewToProject(view, event), event);
		},

		scroll: updateFocus
	};

	viewEvents[mousedown] = function(event) {
		var view = View._focused = getView(event),
			point = viewToProject(view, event);
		dragging = true;
		view._handleEvent('mousedown', point, event);
		if (tool = view._scope.tool)
			tool._handleEvent('mousedown', point, event);
		view.update();
	};

	docEvents[mousemove] = function(event) {
		var view = View._focused;
		if (!dragging) {
			var target = getView(event);
			if (target) {
				if (view !== target)
					handleMouseMove(view, viewToProject(view, event), event);
				prevFocus = view;
				view = View._focused = tempFocus = target;
			} else if (tempFocus && tempFocus === view) {
				view = View._focused = prevFocus;
				updateFocus();
			}
		}
		if (view) {
			var point = viewToProject(view, event);
			if (dragging || view.getBounds().contains(point))
				tool = handleMouseMove(view, point, event);
		}
	};

	docEvents[mouseup] = function(event) {
		var view = View._focused;
		if (!view || !dragging)
			return;
		var point = viewToProject(view, event);
		dragging = false;
		view._handleEvent('mouseup', point, event);
		if (tool)
			tool._handleEvent('mouseup', point, event);
		view.update();
	};

	DomEvent.add(document, docEvents);

	DomEvent.add(window, {
		load: updateFocus
	});

	return {
		_viewEvents: viewEvents,

		_handleEvent: function() {},

		statics: {
			updateFocus: updateFocus
		}
	};
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		if (!(canvas instanceof HTMLCanvasElement)) {
			var size = Size.read(arguments, 1);
			if (size.isZero())
				throw new Error(
						'Cannot create CanvasView with the provided argument: '
						+ [].slice.call(arguments, 1));
			canvas = CanvasProvider.getCanvas(size);
		}
		this._context = canvas.getContext('2d');
		this._eventCounters = {};
		this._pixelRatio = 1;
		if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
			var deviceRatio = window.devicePixelRatio || 1,
				backingStoreRatio = DomElement.getPrefixed(this._context,
						'backingStorePixelRatio') || 1;
			this._pixelRatio = deviceRatio / backingStoreRatio;
		}
		View.call(this, project, canvas);
	},

	_setViewSize: function(size) {
		var element = this._element,
			pixelRatio = this._pixelRatio,
			width = size.width,
			height = size.height;
		element.width = width * pixelRatio;
		element.height = height * pixelRatio;
		if (pixelRatio !== 1) {
			if (!PaperScope.hasAttribute(element, 'resize')) {
				var style = element.style;
				style.width = width + 'px';
				style.height = height + 'px';
			}
			this._context.scale(pixelRatio, pixelRatio);
		}
	},

	getPixelSize: function(size) {
		var browser = paper.browser,
			pixels;
		if (browser && browser.firefox) {
			var parent = this._element.parentNode,
				temp = document.createElement('div');
			temp.style.fontSize = size;
			parent.appendChild(temp);
			pixels = parseFloat(DomElement.getStyles(temp).fontSize);
			parent.removeChild(temp);
		} else {
			var ctx = this._context,
				prevFont = ctx.font;
			ctx.font = size + ' serif';
			pixels = parseFloat(ctx.font);
			ctx.font = prevFont;
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function(force) {
		var project = this._project;
		if (!project || !force && !project._needsUpdate)
			return false;
		var ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		project.draw(ctx, this._matrix, this._pixelRatio);
		project._needsUpdate = false;
		return true;
	}
}, new function() {

	var downPoint,
		lastPoint,
		overPoint,
		downItem,
		lastItem,
		overItem,
		dragItem,
		dblClick,
		clickTime;

	function callEvent(view, type, event, point, target, lastPoint) {
		var item = target,
			mouseEvent;

		function call(obj) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point, target,
							lastPoint ? point.subtract(lastPoint) : null);
				}
				if (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {
					event.preventDefault();
					return true;
				}
			}
		}

		while (item) {
			if (call(item))
				return true;
			item = item.getParent();
		}
		if (call(view))
			return true;
		return false;
	}

	return {
		_handleEvent: function(type, point, event) {
			if (!this._eventCounters[type])
				return;
			var project = this._project,
				hit = project.hitTest(point, {
					tolerance: 0,
					fill: true,
					stroke: true
				}),
				item = hit && hit.item,
				stopped = false;
			switch (type) {
			case 'mousedown':
				stopped = callEvent(this, type, event, point, item);
				dblClick = lastItem == item && (Date.now() - clickTime < 300);
				downItem = lastItem = item;
				downPoint = lastPoint = overPoint = point;
				dragItem = !stopped && item;
				while (dragItem && !dragItem.responds('mousedrag'))
					dragItem = dragItem._parent;
				break;
			case 'mouseup':
				stopped = callEvent(this, type, event, point, item, downPoint);
				if (dragItem) {
					if (lastPoint && !lastPoint.equals(point))
						callEvent(this, 'mousedrag', event, point, dragItem,
								lastPoint);
					if (item !== dragItem) {
						overPoint = point;
						callEvent(this, 'mousemove', event, point, item,
								overPoint);
					}
				}
				if (!stopped && item && item === downItem) {
					clickTime = Date.now();
					callEvent(this, dblClick && downItem.responds('doubleclick')
							? 'doubleclick' : 'click', event, downPoint, item);
					dblClick = false;
				}
				downItem = dragItem = null;
				break;
			case 'mousemove':
				if (dragItem)
					stopped = callEvent(this, 'mousedrag', event, point,
							dragItem, lastPoint);
				if (!stopped) {
					if (item !== overItem)
						overPoint = point;
					stopped = callEvent(this, type, event, point, item,
							overPoint);
				}
				lastPoint = overPoint = point;
				if (item !== overItem) {
					callEvent(this, 'mouseleave', event, point, overItem);
					overItem = item;
					callEvent(this, 'mouseenter', event, point, item);
				}
				break;
			}
			return stopped;
		}
	};
});

var Event = Base.extend({
	_class: 'Event',

	initialize: function Event(event) {
		this.event = event;
	},

	isPrevented: false,
	isStopped: false,

	preventDefault: function() {
		this.isPrevented = true;
		this.event.preventDefault();
	},

	stopPropagation: function() {
		this.isStopped = true;
		this.event.stopPropagation();
	},

	stop: function() {
		this.stopPropagation();
		this.preventDefault();
	},

	getModifiers: function() {
		return Key.modifiers;
	}
});

var KeyEvent = Event.extend({
	_class: 'KeyEvent',

	initialize: function KeyEvent(down, key, character, event) {
		Event.call(this, event);
		this.type = down ? 'keydown' : 'keyup';
		this.key = key;
		this.character = character;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', key: '" + this.key
				+ "', character: '" + this.character
				+ "', modifiers: " + this.getModifiers()
				+ " }";
	}
});

var Key = new function() {

	var specialKeys = {
		8: 'backspace',
		9: 'tab',
		13: 'enter',
		16: 'shift',
		17: 'control',
		18: 'option',
		19: 'pause',
		20: 'caps-lock',
		27: 'escape',
		32: 'space',
		35: 'end',
		36: 'home',
		37: 'left',
		38: 'up',
		39: 'right',
		40: 'down',
		46: 'delete',
		91: 'command',
		93: 'command',
		224: 'command'
	},

	specialChars = {
		9: true,
		13: true,
		32: true
	},

	modifiers = new Base({
		shift: false,
		control: false,
		option: false,
		command: false,
		capsLock: false,
		space: false
	}),

	charCodeMap = {},
	keyMap = {},
	commandFixMap,
	downCode;

	function handleKey(down, keyCode, charCode, event) {
		var character = charCode ? String.fromCharCode(charCode) : '',
			specialKey = specialKeys[keyCode],
			key = specialKey || character.toLowerCase(),
			type = down ? 'keydown' : 'keyup',
			view = View._focused,
			scope = view && view.isVisible() && view._scope,
			tool = scope && scope.tool,
			name;
		keyMap[key] = down;
		if (down) {
			charCodeMap[keyCode] = charCode;
		} else {
			delete charCodeMap[keyCode];
		}
		if (specialKey && (name = Base.camelize(specialKey)) in modifiers) {
			modifiers[name] = down;
			var browser = paper.browser;
			if (name === 'command' && browser && browser.mac) {
				if (down) {
					commandFixMap = {};
				} else {
					for (var code in commandFixMap) {
						if (code in charCodeMap)
							handleKey(false, code, commandFixMap[code], event);
					}
					commandFixMap = null;
				}
			}
		} else if (down && commandFixMap) {
			commandFixMap[keyCode] = charCode;
		}
		if (tool && tool.responds(type)) {
			paper = scope;
			tool.emit(type, new KeyEvent(down, key, character, event));
			if (view)
				view.update();
		}
	}

	DomEvent.add(document, {
		keydown: function(event) {
			var code = event.which || event.keyCode;
			if (code in specialKeys || modifiers.command) {
				handleKey(true, code,
						code in specialChars || modifiers.command ? code : 0,
						event);
			} else {
				downCode = code;
			}
		},

		keypress: function(event) {
			if (downCode != null) {
				handleKey(true, downCode, event.which || event.keyCode, event);
				downCode = null;
			}
		},

		keyup: function(event) {
			var code = event.which || event.keyCode;
			if (code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	DomEvent.add(window, {
		blur: function(event) {
			for (var code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	return {
		modifiers: modifiers,

		isDown: function(key) {
			return !!keyMap[key];
		}
	};
};

var MouseEvent = Event.extend({
	_class: 'MouseEvent',

	initialize: function MouseEvent(type, event, point, target, delta) {
		Event.call(this, event);
		this.type = type;
		this.point = point;
		this.target = target;
		this.delta = delta;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', point: " + this.point
				+ ', target: ' + this.target
				+ (this.delta ? ', delta: ' + this.delta : '')
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var ToolEvent = Event.extend({
	_class: 'ToolEvent',
	_item: null,

	initialize: function ToolEvent(tool, type, event) {
		this.tool = tool;
		this.type = type;
		this.event = event;
	},

	_choosePoint: function(point, toolPoint) {
		return point ? point : toolPoint ? toolPoint.clone() : null;
	},

	getPoint: function() {
		return this._choosePoint(this._point, this.tool._point);
	},

	setPoint: function(point) {
		this._point = point;
	},

	getLastPoint: function() {
		return this._choosePoint(this._lastPoint, this.tool._lastPoint);
	},

	setLastPoint: function(lastPoint) {
		this._lastPoint = lastPoint;
	},

	getDownPoint: function() {
		return this._choosePoint(this._downPoint, this.tool._downPoint);
	},

	setDownPoint: function(downPoint) {
		this._downPoint = downPoint;
	},

	getMiddlePoint: function() {
		if (!this._middlePoint && this.tool._lastPoint) {
			return this.tool._point.add(this.tool._lastPoint).divide(2);
		}
		return this._middlePoint;
	},

	setMiddlePoint: function(middlePoint) {
		this._middlePoint = middlePoint;
	},

	getDelta: function() {
		return !this._delta && this.tool._lastPoint
				? this.tool._point.subtract(this.tool._lastPoint)
				: this._delta;
	},

	setDelta: function(delta) {
		this._delta = delta;
	},

	getCount: function() {
		return /^mouse(down|up)$/.test(this.type)
				? this.tool._downCount
				: this.tool._count;
	},

	setCount: function(count) {
		this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
			= count;
	},

	getItem: function() {
		if (!this._item) {
			var result = this.tool._scope.project.hitTest(this.getPoint());
			if (result) {
				var item = result.item,
					parent = item._parent;
				while (/^(Group|CompoundPath)$/.test(parent._class)) {
					item = parent;
					parent = parent._parent;
				}
				this._item = item;
			}
		}
		return this._item;
	},

	setItem: function(item) {
		this._item = item;
	},

	toString: function() {
		return '{ type: ' + this.type
				+ ', point: ' + this.getPoint()
				+ ', count: ' + this.getCount()
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var Tool = PaperScopeItem.extend({
	_class: 'Tool',
	_list: 'tools',
	_reference: 'tool',
	_events: [ 'onActivate', 'onDeactivate', 'onEditOptions',
			'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
			'onKeyDown', 'onKeyUp' ],

	initialize: function Tool(props) {
		PaperScopeItem.call(this);
		this._firstMove = true;
		this._count = 0;
		this._downCount = 0;
		this._set(props);
	},

	getMinDistance: function() {
		return this._minDistance;
	},

	setMinDistance: function(minDistance) {
		this._minDistance = minDistance;
		if (minDistance != null && this._maxDistance != null
				&& minDistance > this._maxDistance) {
			this._maxDistance = minDistance;
		}
	},

	getMaxDistance: function() {
		return this._maxDistance;
	},

	setMaxDistance: function(maxDistance) {
		this._maxDistance = maxDistance;
		if (this._minDistance != null && maxDistance != null
				&& maxDistance < this._minDistance) {
			this._minDistance = maxDistance;
		}
	},

	getFixedDistance: function() {
		return this._minDistance == this._maxDistance
			? this._minDistance : null;
	},

	setFixedDistance: function(distance) {
		this._minDistance = distance;
		this._maxDistance = distance;
	},

	_updateEvent: function(type, point, minDistance, maxDistance, start,
			needsChange, matchMaxDistance) {
		if (!start) {
			if (minDistance != null || maxDistance != null) {
				var minDist = minDistance != null ? minDistance : 0,
					vector = point.subtract(this._point),
					distance = vector.getLength();
				if (distance < minDist)
					return false;
				if (maxDistance != null && maxDistance != 0) {
					if (distance > maxDistance) {
						point = this._point.add(vector.normalize(maxDistance));
					} else if (matchMaxDistance) {
						return false;
					}
				}
			}
			if (needsChange && point.equals(this._point))
				return false;
		}
		this._lastPoint = start && type == 'mousemove' ? point : this._point;
		this._point = point;
		switch (type) {
		case 'mousedown':
			this._lastPoint = this._downPoint;
			this._downPoint = this._point;
			this._downCount++;
			break;
		case 'mouseup':
			this._lastPoint = this._downPoint;
			break;
		}
		this._count = start ? 0 : this._count + 1;
		return true;
	},

	_fireEvent: function(type, event) {
		var sets = paper.project._removeSets;
		if (sets) {
			if (type === 'mouseup')
				sets.mousedrag = null;
			var set = sets[type];
			if (set) {
				for (var id in set) {
					var item = set[id];
					for (var key in sets) {
						var other = sets[key];
						if (other && other != set)
							delete other[item._id];
					}
					item.remove();
				}
				sets[type] = null;
			}
		}
		return this.responds(type)
				&& this.emit(type, new ToolEvent(this, type, event));
	},

	_handleEvent: function(type, point, event) {
		paper = this._scope;
		var called = false;
		switch (type) {
		case 'mousedown':
			this._updateEvent(type, point, null, null, true, false, false);
			called = this._fireEvent(type, event);
			break;
		case 'mousedrag':
			var needsChange = false,
				matchMaxDistance = false;
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, false, needsChange, matchMaxDistance)) {
				called = this._fireEvent(type, event) || called;
				needsChange = true;
				matchMaxDistance = true;
			}
			break;
		case 'mouseup':
			if (!point.equals(this._point)
					&& this._updateEvent('mousedrag', point, this.minDistance,
							this.maxDistance, false, false, false)) {
				called = this._fireEvent('mousedrag', event);
			}
			this._updateEvent(type, point, null, this.maxDistance, false,
					false, false);
			called = this._fireEvent(type, event) || called;
			this._updateEvent(type, point, null, null, true, false, false);
			this._firstMove = true;
			break;
		case 'mousemove':
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, this._firstMove, true, false)) {
				called = this._fireEvent(type, event) || called;
				this._firstMove = false;
			}
			break;
		}
		if (called)
			event.preventDefault();
		return called;
	}

});

var Http = {
	request: function(method, url, callback, async) {
		async = (async === undefined) ? true : async;
		var xhr = new (window.ActiveXObject || XMLHttpRequest)(
					'Microsoft.XMLHTTP');
		xhr.open(method.toUpperCase(), url, async);
		if ('overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain');
		xhr.onreadystatechange = function() {
			if (xhr.readyState === 4) {
				var status = xhr.status;
				if (status === 0 || status === 200) {
					callback.call(xhr, xhr.responseText);
				} else {
					throw new Error('Could not load ' + url + ' (Error '
							+ status + ')');
				}
			}
		};
		return xhr.send(null);
	}
};

var CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height) {
		var canvas,
			clear = true;
		if (typeof width === 'object') {
			height = width.height;
			width = width.width;
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			canvas = document.createElement('canvas');
		}
		var ctx = canvas.getContext('2d');
		if (canvas.width === width && canvas.height === height) {
			if (clear)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		return canvas;
	},

	getContext: function(width, height) {
		return this.getCanvas(width, height).getContext('2d');
	},

	release: function(obj) {
		var canvas = obj.canvas ? obj.canvas : obj;
		canvas.getContext('2d').restore();
		this.canvases.push(canvas);
	}
};

var BlendMode = new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		sr, sg, sb, sa,
		br, bg, bb, ba,
		dr, dg, db;

	function getLum(r, g, b) {
		return 0.2989 * r + 0.587 * g + 0.114 * b;
	}

	function setLum(r, g, b, l) {
		var d = l - getLum(r, g, b);
		dr = r + d;
		dg = g + d;
		db = b + d;
		var l = getLum(dr, dg, db),
			mn = min(dr, dg, db),
			mx = max(dr, dg, db);
		if (mn < 0) {
			var lmn = l - mn;
			dr = l + (dr - l) * l / lmn;
			dg = l + (dg - l) * l / lmn;
			db = l + (db - l) * l / lmn;
		}
		if (mx > 255) {
			var ln = 255 - l,
				mxl = mx - l;
			dr = l + (dr - l) * ln / mxl;
			dg = l + (dg - l) * ln / mxl;
			db = l + (db - l) * ln / mxl;
		}
	}

	function getSat(r, g, b) {
		return max(r, g, b) - min(r, g, b);
	}

	function setSat(r, g, b, s) {
		var col = [r, g, b],
			mx = max(r, g, b),
			mn = min(r, g, b),
			md;
		mn = mn === r ? 0 : mn === g ? 1 : 2;
		mx = mx === r ? 0 : mx === g ? 1 : 2;
		md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
		if (col[mx] > col[mn]) {
			col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
			col[mx] = s;
		} else {
			col[md] = col[mx] = 0;
		}
		col[mn] = 0;
		dr = col[0];
		dg = col[1];
		db = col[2];
	}

	var modes = {
		multiply: function() {
			dr = br * sr / 255;
			dg = bg * sg / 255;
			db = bb * sb / 255;
		},

		screen: function() {
			dr = br + sr - (br * sr / 255);
			dg = bg + sg - (bg * sg / 255);
			db = bb + sb - (bb * sb / 255);
		},

		overlay: function() {
			dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
			dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
			db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
		},

		'soft-light': function() {
			var t = sr * br / 255;
			dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
			t = sg * bg / 255;
			dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
			t = sb * bb / 255;
			db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
		},

		'hard-light': function() {
			dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
			dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
			db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
		},

		'color-dodge': function() {
			dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
			dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
			db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
		},

		'color-burn': function() {
			dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
			dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
			db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
		},

		darken: function() {
			dr = br < sr ? br : sr;
			dg = bg < sg ? bg : sg;
			db = bb < sb ? bb : sb;
		},

		lighten: function() {
			dr = br > sr ? br : sr;
			dg = bg > sg ? bg : sg;
			db = bb > sb ? bb : sb;
		},

		difference: function() {
			dr = br - sr;
			if (dr < 0)
				dr = -dr;
			dg = bg - sg;
			if (dg < 0)
				dg = -dg;
			db = bb - sb;
			if (db < 0)
				db = -db;
		},

		exclusion: function() {
			dr = br + sr * (255 - br - br) / 255;
			dg = bg + sg * (255 - bg - bg) / 255;
			db = bb + sb * (255 - bb - bb) / 255;
		},

		hue: function() {
			setSat(sr, sg, sb, getSat(br, bg, bb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		saturation: function() {
			setSat(br, bg, bb, getSat(sr, sg, sb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		luminosity: function() {
			setLum(br, bg, bb, getLum(sr, sg, sb));
		},

		color: function() {
			setLum(sr, sg, sb, getLum(br, bg, bb));
		},

		add: function() {
			dr = min(br + sr, 255);
			dg = min(bg + sg, 255);
			db = min(bb + sb, 255);
		},

		subtract: function() {
			dr = max(br - sr, 0);
			dg = max(bg - sg, 0);
			db = max(bb - sb, 0);
		},

		average: function() {
			dr = (br + sr) / 2;
			dg = (bg + sg) / 2;
			db = (bb + sb) / 2;
		},

		negation: function() {
			dr = 255 - abs(255 - sr - br);
			dg = 255 - abs(255 - sg - bg);
			db = 255 - abs(255 - sb - bb);
		}
	};

	var nativeModes = this.nativeModes = Base.each([
		'source-over', 'source-in', 'source-out', 'source-atop',
		'destination-over', 'destination-in', 'destination-out',
		'destination-atop', 'lighter', 'darker', 'copy', 'xor'
	], function(mode) {
		this[mode] = true;
	}, {});

	var ctx = CanvasProvider.getContext(1, 1);
	Base.each(modes, function(func, mode) {
		var darken = mode === 'darken',
			ok = false;
		ctx.save();
		try {
			ctx.fillStyle = darken ? '#300' : '#a00';
			ctx.fillRect(0, 0, 1, 1);
			ctx.globalCompositeOperation = mode;
			if (ctx.globalCompositeOperation === mode) {
				ctx.fillStyle = darken ? '#a00' : '#300';
				ctx.fillRect(0, 0, 1, 1);
				ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
			}
		} catch (e) {}
		ctx.restore();
		nativeModes[mode] = ok;
	});
	CanvasProvider.release(ctx);

	this.process = function(mode, srcContext, dstContext, alpha, offset) {
		var srcCanvas = srcContext.canvas,
			normal = mode === 'normal';
		if (normal || nativeModes[mode]) {
			dstContext.save();
			dstContext.setTransform(1, 0, 0, 1, 0, 0);
			dstContext.globalAlpha = alpha;
			if (!normal)
				dstContext.globalCompositeOperation = mode;
			dstContext.drawImage(srcCanvas, offset.x, offset.y);
			dstContext.restore();
		} else {
			var process = modes[mode];
			if (!process)
				return;
			var dstData = dstContext.getImageData(offset.x, offset.y,
					srcCanvas.width, srcCanvas.height),
				dst = dstData.data,
				src = srcContext.getImageData(0, 0,
					srcCanvas.width, srcCanvas.height).data;
			for (var i = 0, l = dst.length; i < l; i += 4) {
				sr = src[i];
				br = dst[i];
				sg = src[i + 1];
				bg = dst[i + 1];
				sb = src[i + 2];
				bb = dst[i + 2];
				sa = src[i + 3];
				ba = dst[i + 3];
				process();
				var a1 = sa * alpha / 255,
					a2 = 1 - a1;
				dst[i] = a1 * dr + a2 * br;
				dst[i + 1] = a1 * dg + a2 * bg;
				dst[i + 2] = a1 * db + a2 * bb;
				dst[i + 3] = sa * alpha + a2 * ba;
			}
			dstContext.putImageData(dstData, offset.x, offset.y);
		}
	};
};

var SVGStyles = Base.each({
	fillColor: ['fill', 'color'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	strokeScaling: ['vector-effect', 'lookup', {
		true: 'none',
		false: 'non-scaling-stroke'
	}, function(item, value) {
		return !value
				&& (item instanceof PathItem
					|| item instanceof Shape
					|| item instanceof TextItem);
	}],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'string']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		exportFilter: entry[3],
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

var SVGNamespaces = {
	href: 'http://www.w3.org/1999/xlink',
	xlink: 'http://www.w3.org/2000/xmlns'
};

new function() {
	var formatter;

	function setAttributes(node, attrs) {
		for (var key in attrs) {
			var val = attrs[key],
				namespace = SVGNamespaces[key];
			if (typeof val === 'number')
				val = formatter.number(val);
			if (namespace) {
				node.setAttributeNS(namespace, key, val);
			} else {
				node.setAttribute(key, val);
			}
		}
		return node;
	}

	function createElement(tag, attrs) {
		return setAttributes(
			document.createElementNS('http://www.w3.org/2000/svg', tag), attrs);
	}

	function getTransform(matrix, coordinates, center) {
		var attrs = new Base(),
			trans = matrix.getTranslation();
		if (coordinates) {
			matrix = matrix.shiftless();
			var point = matrix._inverseTransform(trans);
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
			trans = null;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed && !decomposed.shearing) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item._matrix),
			children = item._children;
		var node = createElement('g', attrs);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = createElement('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					setAttributes(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item, options) {
		var attrs = getTransform(item._matrix, true),
			size = item.getSize(),
			image = item.getImage();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = options.embedImages === false && image && image.src
				|| item.toDataURL();
		return createElement('image', attrs);
	}

	function exportPath(item, options) {
		var matchShapes = options.matchShapes;
		if (matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			type,
			attrs = getTransform(item._matrix);
		if (segments.length === 0)
			return null;
		if (matchShapes && !item.hasHandles()) {
			if (segments.length >= 3) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for(var i = 0, l = segments.length; i < l; i++)
					parts.push(formatter.point(segments[i]._point));
				attrs.points = parts.join(' ');
			} else {
				type = 'line';
				var first = segments[0]._point,
					last = segments[segments.length - 1]._point;
				attrs.set({
					x1: first.x,
					y1: first.y,
					x2: last.x,
					y2: last.y
				});
			}
		} else {
			type = 'path';
			attrs.d = item.getPathData(null, options.precision);
		}
		return createElement(type, attrs);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item._matrix, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect';
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return createElement(type, attrs);
	}

	function exportCompoundPath(item, options) {
		var attrs = getTransform(item._matrix);
		var data = item.getPathData(null, options.precision);
		if (data)
			attrs.d = data;
		return createElement('path', attrs);
	}

	function exportPlacedSymbol(item, options) {
		var attrs = getTransform(item._matrix, true),
			symbol = item.getSymbol(),
			symbolNode = getDefinition(symbol, 'symbol'),
			definition = symbol.getDefinition(),
			bounds = definition.getBounds();
		if (!symbolNode) {
			symbolNode = createElement('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			symbolNode.appendChild(exportSVG(definition, options));
			setDefinition(symbol, symbolNode, 'symbol');
		}
		attrs.href = '#' + symbolNode.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = formatter.number(bounds.width);
		attrs.height = formatter.number(bounds.height);
		attrs.overflow = 'visible';
		return createElement('use', attrs);
	}

	function exportGradient(color) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin().transform(),
				destination = color.getDestination().transform(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					highlight = highlight.transform();
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = createElement(
					(radial ? 'radial' : 'linear') + 'Gradient', attrs);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha();
				attrs = {
					offset: stop._rampPoint,
					'stop-color': stopColor.toCSS(true)
				};
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(createElement('stop', attrs));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = createElement('text', getTransform(item._matrix, true));
		node.textContent = item._content;
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		PlacedSymbol: exportPlacedSymbol,
		PointText: exportText
	};

	function applyStyle(item, node, isRoot) {
		var attrs = {},
			parent = !isRoot && item.getParent();

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SVGStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();
			if (entry.exportFilter
					? entry.exportFilter(item, value)
					: !parent || !Base.equals(parent[get](), value)) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				attrs[entry.attribute] = value == null
					? 'none'
					: type === 'number'
						? formatter.number(value)
						: type === 'color'
							? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array'
								? value.join(',')
								: type === 'lookup'
									? entry.toSVG[value]
									: value;
			}
		});

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (!item._visible)
			attrs.visibility = 'hidden';

		return setAttributes(node, attrs);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-' + item._id];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + id;
		definitions.svgs[type + '-' + item._id] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = createElement('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(createElement('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options, isRoot) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node) {
			var onExport = options.onExport;
			if (onExport)
				node = onExport(item, node, options) || node;
			var data = JSON.stringify(item._data);
			if (data && data !== '{}' && data !== 'null')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node, isRoot);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options, true), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var layers = this.layers,
				view = this.getView(),
				size = view.getViewSize(),
				node = createElement('svg', {
					x: 0,
					y: 0,
					width: size.width,
					height: size.height,
					version: '1.1',
					xmlns: 'http://www.w3.org/2000/svg',
					'xmlns:xlink': 'http://www.w3.org/1999/xlink'
				}),
				parent = node,
				matrix = view._matrix;
			if (!matrix.isIdentity())
				parent = node.appendChild(
						createElement('g', getTransform(matrix)));
			for (var i = 0, l = layers.length; i < l; i++)
				parent.appendChild(exportSVG(layers[i], options, true));
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	function getValue(node, name, isString, allowNull) {
		var namespace = SVGNamespaces[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		if (value === 'null')
			value = null;
		return value == null
				? allowNull
					? null
					: isString
						? ''
						: 0
				: isString
					? value
					: parseFloat(value);
	}

	function getPoint(node, x, y, allowNull) {
		x = getValue(node, x, false, allowNull);
		y = getValue(node, y, false, allowNull);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull) {
		w = getValue(node, w, false, allowNull);
		h = getValue(node, h, false, allowNull);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none'
				? null
				: type === 'number'
					? parseFloat(value)
					: type === 'array'
						? value ? value.split(/[\s,]+/g).map(parseFloat) : []
						: type === 'color'
							? getDefinition(value) || value
							: type === 'lookup'
								? lookup[value]
								: value;
	}

	function importGroup(node, type, options, isRoot) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		if (isRoot) {
			var defs = node.querySelectorAll('defs');
			for (var i = 0, l = defs.length; i < l; i++) {
				importSVG(defs[i], options, false);
			}
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& childNode.nodeName.toLowerCase() !== 'defs'
					&& (child = importSVG(childNode, options, false))
					&& !(child instanceof Symbol))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || type === 'defs') {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		var data = node.getAttribute('d'),
			param = { pathData: data };
		return (data.match(/m/gi) || []).length > 1 || /z\S+/i.test(data)
				? new CompoundPath(param)
				: new Path(param);
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			isRadial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, isRadial);
		}
		var origin, destination, highlight;
		if (isRadial) {
			origin = getPoint(node, 'cx', 'cy');
			destination = origin.add(getValue(node, 'r'), 0);
			highlight = getPoint(node, 'fx', 'fy', true);
		} else {
			origin = getPoint(node, 'x1', 'y1');
			destination = getPoint(node, 'x2', 'y2');
		}
		applyAttributes(
			new Color(gradient, origin, destination, highlight), node);
		return null;
	}

	var importers = {
		'#document': function (node, type, options, isRoot) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1) {
					var next = child.nextSibling;
					document.body.appendChild(child);
					var item = importSVG(child, options, isRoot);
					if (next) {
						node.insertBefore(child, next);
					} else {
						node.appendChild(child);
					}
					return item;
				}
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.on('load', function() {
				var size = getSize(node, 'width', 'height');
				this.setSize(size);
				var center = this._matrix._transformPoint(
						getPoint(node, 'x', 'y').add(size.divide(2)));
				this.translate(center);
			});
			return raster;
		},

		symbol: function(node, type, options, isRoot) {
			return new Symbol(importGroup(node, type, options, isRoot), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node, 'x', 'y');
			return definition
					? definition instanceof Symbol
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			var point = getPoint(node, 'x', 'y'),
				size = getSize(node, 'width', 'height'),
				radius = getSize(node, 'rx', 'ry');
			return new Shape.Rectangle(new Rectangle(point, size), radius);
		},

		line: function(node) {
			return new Path.Line(getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {
			var text = new PointText(getPoint(node, 'x', 'y')
					.add(getPoint(node, 'dx', 'dy')));
			text.setContent(node.textContent.trim() || '');
			return text;
		}
	};

	function applyTransform(item, value, name, node) {
		var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
			matrix = new Matrix();
		for (var i = 0, l = transforms.length; i < l; i++) {
			var transform = transforms[i];
			if (!transform)
				break;
			var parts = transform.split(/\(\s*/),
				command = parts[0],
				v = parts[1].split(/[\s,]+/g);
			for (var j = 0, m = v.length; j < m; j++)
				v[j] = parseFloat(v[j]);
			switch (command) {
			case 'matrix':
				matrix.concatenate(
						new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
				break;
			case 'rotate':
				matrix.rotate(v[0], v[1], v[2]);
				break;
			case 'translate':
				matrix.translate(v[0], v[1]);
				break;
			case 'scale':
				matrix.scale(v);
				break;
			case 'skewX':
				matrix.skew(v[0], 0);
				break;
			case 'skewY':
				matrix.skew(0, v[0]);
				break;
			}
		}
		item.transform(matrix);
	}

	function applyOpacity(item, value, name) {
		var color = item[name === 'fill-opacity' ? 'getFillColor'
				: 'getStrokeColor']();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.set(Base.each(SVGStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			item[entry.set](convertValue(value, entry.type, entry.fromSVG));
			if (entry.type === 'color' && item instanceof Shape) {
				var color = item[entry.get]();
				if (color)
					color.transform(new Matrix().translate(
							item.getPosition(true).negate()));
			}
		};
	}, {}), {
		id: function(item, value) {
			definitions[value] = item;
			if (item.setName)
				item.setName(value);
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			item.setVisible(value === 'visible');
		},

		display: function(item, value) {
			item.setVisible(value !== null);
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			var percentage = value.match(/(.*)%$/);
			item.setRampPoint(percentage
					? percentage[1] / 100
					: parseFloat(value));
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, 'width', 'height', true);
			if (item instanceof Group) {
				var scale = size ? rect.getSize().divide(size) : 1,
					matrix = new Matrix().translate(rect.getPoint()).scale(scale);
				item.transform(matrix.inverted());
			} else if (item instanceof Symbol) {
				if (size)
					rect.setSize(size);
				var clip = getAttribute(node, 'overflow', styles) != 'visible',
					group = item._definition;
				if (clip && !rect.contains(group.getBounds())) {
					clip = new Shape.Rectangle(rect).transform(group._matrix);
					clip.setClipMask(true);
					group.addChild(clip);
				}
			}
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value
				? undefined
				: value === 'none'
					? null
					: value;
	}

	function applyAttributes(item, node, isRoot) {
		var styles = {
			node: DomElement.getStyles(node) || {},
			parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
		};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			if (value !== undefined)
				item = Base.pick(apply(item, value, name, node, styles), item);
		});
		return item;
	}

	var definitions = {};
	function getDefinition(value) {
		var match = value && value.match(/\((?:#|)([^)']+)/);
		return match && definitions[match[1]];
	}

	function importSVG(source, options, isRoot) {
		if (!source)
			return null;
		if (!options) {
			options = {};
		} else if (typeof options === 'function') {
			options = { onLoad: options };
		}

		var node = source,
			scope = paper;

		function onLoadCallback(svg) {
			paper = scope;
			var item = importSVG(svg, options, isRoot),
				onLoad = options.onLoad,
				view = scope.project && scope.getView();
			if (onLoad)
				onLoad.call(this, item);
			view.update();
		}

		if (isRoot) {
			if (typeof source === 'string' && !/^.*</.test(source)) {
				node = document.getElementById(source);
				if (node) {
					source = null;
				} else {
					return Http.request('get', source, onLoadCallback);
				}
			} else if (typeof File !== 'undefined' && source instanceof File) {
				var reader = new FileReader();
				reader.onload = function() {
					onLoadCallback(reader.result);
				};
				return reader.readAsText(source);
			}
		}

		if (typeof source === 'string')
			node = new DOMParser().parseFromString(source, 'image/svg+xml');
		if (!node.nodeName)
			throw new Error('Unsupported SVG source: ' + source);
		var type = node.nodeName.toLowerCase(),
			importer = importers[type],
			item,
			data = node.getAttribute && node.getAttribute('data-paper-data'),
			settings = scope.settings,
			applyMatrix = settings.applyMatrix;
		settings.applyMatrix = false;
		item = importer && importer(node, type, options, isRoot) || null;
		settings.applyMatrix = applyMatrix;
		if (item) {
			if (type !== '#document' && !(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			var onImport = options.onImport;
			if (onImport)
				item = onImport(node, item, options) || item;
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (isRoot) {
			definitions = {};
			if (item && Base.pick(options.applyMatrix, applyMatrix))
				item.matrix.apply(true, true);
		}
		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return this.addChild(importSVG(node, options, true));
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, options, true);
		}
	});
};

Base.exports.PaperScript = (function() {
	var exports, define,
		scope = this;
!function(e,r){return"object"==typeof exports&&"object"==typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):(r(e.acorn||(e.acorn={})),void 0)}(this,function(e){"use strict";function r(e){fr=e||{};for(var r in mr)Object.prototype.hasOwnProperty.call(fr,r)||(fr[r]=mr[r]);hr=fr.sourceFile||null}function t(e,r){var t=vr(dr,e);r+=" ("+t.line+":"+t.column+")";var n=new SyntaxError(r);throw n.pos=e,n.loc=t,n.raisedAt=br,n}function n(e){function r(e){if(1==e.length)return t+="return str === "+JSON.stringify(e[0])+";";t+="switch(str){";for(var r=0;r<e.length;++r)t+="case "+JSON.stringify(e[r])+":";t+="return true}return false;"}e=e.split(" ");var t="",n=[];e:for(var a=0;a<e.length;++a){for(var o=0;o<n.length;++o)if(n[o][0].length==e[a].length){n[o].push(e[a]);continue e}n.push([e[a]])}if(n.length>3){n.sort(function(e,r){return r.length-e.length}),t+="switch(str.length){";for(var a=0;a<n.length;++a){var i=n[a];t+="case "+i[0].length+":",r(i)}t+="}"}else r(e);return new Function("str",t)}function a(){this.line=Ar,this.column=br-Sr}function o(){Ar=1,br=Sr=0,Er=!0,u()}function i(e,r){gr=br,fr.locations&&(kr=new a),wr=e,u(),Cr=r,Er=e.beforeExpr}function s(){var e=fr.onComment&&fr.locations&&new a,r=br,n=dr.indexOf("*/",br+=2);if(-1===n&&t(br-2,"Unterminated comment"),br=n+2,fr.locations){Kt.lastIndex=r;for(var o;(o=Kt.exec(dr))&&o.index<br;)++Ar,Sr=o.index+o[0].length}fr.onComment&&fr.onComment(!0,dr.slice(r+2,n),r,br,e,fr.locations&&new a)}function c(){for(var e=br,r=fr.onComment&&fr.locations&&new a,t=dr.charCodeAt(br+=2);pr>br&&10!==t&&13!==t&&8232!==t&&8233!==t;)++br,t=dr.charCodeAt(br);fr.onComment&&fr.onComment(!1,dr.slice(e+2,br),e,br,r,fr.locations&&new a)}function u(){for(;pr>br;){var e=dr.charCodeAt(br);if(32===e)++br;else if(13===e){++br;var r=dr.charCodeAt(br);10===r&&++br,fr.locations&&(++Ar,Sr=br)}else if(10===e||8232===e||8233===e)++br,fr.locations&&(++Ar,Sr=br);else if(e>8&&14>e)++br;else if(47===e){var r=dr.charCodeAt(br+1);if(42===r)s();else{if(47!==r)break;c()}}else if(160===e)++br;else{if(!(e>=5760&&Jt.test(String.fromCharCode(e))))break;++br}}}function l(){var e=dr.charCodeAt(br+1);return e>=48&&57>=e?E(!0):(++br,i(xt))}function f(){var e=dr.charCodeAt(br+1);return Er?(++br,k()):61===e?x(Et,2):x(wt,1)}function d(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Dt,1)}function p(e){var r=dr.charCodeAt(br+1);return r===e?x(124===e?Lt:Ut,2):61===r?x(Et,2):x(124===e?Rt:Tt,1)}function h(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Vt,1)}function m(e){var r=dr.charCodeAt(br+1);return r===e?45==r&&62==dr.charCodeAt(br+2)&&Gt.test(dr.slice(Lr,br))?(br+=3,c(),u(),g()):x(St,2):61===r?x(Et,2):x(At,1)}function v(e){var r=dr.charCodeAt(br+1),t=1;return r===e?(t=62===e&&62===dr.charCodeAt(br+2)?3:2,61===dr.charCodeAt(br+t)?x(Et,t+1):x(jt,t)):33==r&&60==e&&45==dr.charCodeAt(br+2)&&45==dr.charCodeAt(br+3)?(br+=4,c(),u(),g()):(61===r&&(t=61===dr.charCodeAt(br+2)?3:2),x(Ot,t))}function b(e){var r=dr.charCodeAt(br+1);return 61===r?x(qt,61===dr.charCodeAt(br+2)?3:2):x(61===e?Ct:It,1)}function y(e){switch(e){case 46:return l();case 40:return++br,i(mt);case 41:return++br,i(vt);case 59:return++br,i(yt);case 44:return++br,i(bt);case 91:return++br,i(ft);case 93:return++br,i(dt);case 123:return++br,i(pt);case 125:return++br,i(ht);case 58:return++br,i(gt);case 63:return++br,i(kt);case 48:var r=dr.charCodeAt(br+1);if(120===r||88===r)return C();case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return E(!1);case 34:case 39:return A(e);case 47:return f(e);case 37:case 42:return d();case 124:case 38:return p(e);case 94:return h();case 43:case 45:return m(e);case 60:case 62:return v(e);case 61:case 33:return b(e);case 126:return x(It,1)}return!1}function g(e){if(e?br=yr+1:yr=br,fr.locations&&(xr=new a),e)return k();if(br>=pr)return i(Br);var r=dr.charCodeAt(br);if(Qt(r)||92===r)return L();var n=y(r);if(n===!1){var o=String.fromCharCode(r);if("\\"===o||$t.test(o))return L();t(br,"Unexpected character '"+o+"'")}return n}function x(e,r){var t=dr.slice(br,br+r);br+=r,i(e,t)}function k(){for(var e,r,n="",a=br;;){br>=pr&&t(a,"Unterminated regular expression");var o=dr.charAt(br);if(Gt.test(o)&&t(a,"Unterminated regular expression"),e)e=!1;else{if("["===o)r=!0;else if("]"===o&&r)r=!1;else if("/"===o&&!r)break;e="\\"===o}++br}var n=dr.slice(a,br);++br;var s=I();return s&&!/^[gmsiy]*$/.test(s)&&t(a,"Invalid regexp flag"),i(jr,new RegExp(n,s))}function w(e,r){for(var t=br,n=0,a=0,o=null==r?1/0:r;o>a;++a){var i,s=dr.charCodeAt(br);if(i=s>=97?s-97+10:s>=65?s-65+10:s>=48&&57>=s?s-48:1/0,i>=e)break;++br,n=n*e+i}return br===t||null!=r&&br-t!==r?null:n}function C(){br+=2;var e=w(16);return null==e&&t(yr+2,"Expected hexadecimal number"),Qt(dr.charCodeAt(br))&&t(br,"Identifier directly after number"),i(Or,e)}function E(e){var r=br,n=!1,a=48===dr.charCodeAt(br);e||null!==w(10)||t(r,"Invalid number"),46===dr.charCodeAt(br)&&(++br,w(10),n=!0);var o=dr.charCodeAt(br);(69===o||101===o)&&(o=dr.charCodeAt(++br),(43===o||45===o)&&++br,null===w(10)&&t(r,"Invalid number"),n=!0),Qt(dr.charCodeAt(br))&&t(br,"Identifier directly after number");var s,c=dr.slice(r,br);return n?s=parseFloat(c):a&&1!==c.length?/[89]/.test(c)||Tr?t(r,"Invalid number"):s=parseInt(c,8):s=parseInt(c,10),i(Or,s)}function A(e){br++;for(var r="";;){br>=pr&&t(yr,"Unterminated string constant");var n=dr.charCodeAt(br);if(n===e)return++br,i(Dr,r);if(92===n){n=dr.charCodeAt(++br);var a=/^[0-7]+/.exec(dr.slice(br,br+3));for(a&&(a=a[0]);a&&parseInt(a,8)>255;)a=a.slice(0,a.length-1);if("0"===a&&(a=null),++br,a)Tr&&t(br-2,"Octal literal in strict mode"),r+=String.fromCharCode(parseInt(a,8)),br+=a.length-1;else switch(n){case 110:r+="\n";break;case 114:r+="\r";break;case 120:r+=String.fromCharCode(S(2));break;case 117:r+=String.fromCharCode(S(4));break;case 85:r+=String.fromCharCode(S(8));break;case 116:r+="	";break;case 98:r+="\b";break;case 118:r+="";break;case 102:r+="\f";break;case 48:r+="\0";break;case 13:10===dr.charCodeAt(br)&&++br;case 10:fr.locations&&(Sr=br,++Ar);break;default:r+=String.fromCharCode(n)}}else(13===n||10===n||8232===n||8233===n)&&t(yr,"Unterminated string constant"),r+=String.fromCharCode(n),++br}}function S(e){var r=w(16,e);return null===r&&t(yr,"Bad character escape sequence"),r}function I(){Bt=!1;for(var e,r=!0,n=br;;){var a=dr.charCodeAt(br);if(Yt(a))Bt&&(e+=dr.charAt(br)),++br;else{if(92!==a)break;Bt||(e=dr.slice(n,br)),Bt=!0,117!=dr.charCodeAt(++br)&&t(br,"Expecting Unicode escape sequence \\uXXXX"),++br;var o=S(4),i=String.fromCharCode(o);i||t(br-1,"Invalid Unicode escape"),(r?Qt(o):Yt(o))||t(br-4,"Invalid Unicode escape"),e+=i}r=!1}return Bt?e:dr.slice(n,br)}function L(){var e=I(),r=Fr;return Bt||(Wt(e)?r=lt[e]:(fr.forbidReserved&&(3===fr.ecmaVersion?Mt:zt)(e)||Tr&&Xt(e))&&t(yr,"The keyword '"+e+"' is reserved")),i(r,e)}function U(){Ir=yr,Lr=gr,Ur=kr,g()}function R(e){if(Tr=e,br=Lr,fr.locations)for(;Sr>br;)Sr=dr.lastIndexOf("\n",Sr-2)+1,--Ar;u(),g()}function V(){this.type=null,this.start=yr,this.end=null}function T(){this.start=xr,this.end=null,null!==hr&&(this.source=hr)}function q(){var e=new V;return fr.locations&&(e.loc=new T),fr.ranges&&(e.range=[yr,0]),e}function O(e){var r=new V;return r.start=e.start,fr.locations&&(r.loc=new T,r.loc.start=e.loc.start),fr.ranges&&(r.range=[e.range[0],0]),r}function j(e,r){return e.type=r,e.end=Lr,fr.locations&&(e.loc.end=Ur),fr.ranges&&(e.range[1]=Lr),e}function D(e){return fr.ecmaVersion>=5&&"ExpressionStatement"===e.type&&"Literal"===e.expression.type&&"use strict"===e.expression.value}function F(e){return wr===e?(U(),!0):void 0}function B(){return!fr.strictSemicolons&&(wr===Br||wr===ht||Gt.test(dr.slice(Lr,yr)))}function M(){F(yt)||B()||X()}function z(e){wr===e?U():X()}function X(){t(yr,"Unexpected token")}function N(e){"Identifier"!==e.type&&"MemberExpression"!==e.type&&t(e.start,"Assigning to rvalue"),Tr&&"Identifier"===e.type&&Nt(e.name)&&t(e.start,"Assigning to "+e.name+" in strict mode")}function W(e){Ir=Lr=br,fr.locations&&(Ur=new a),Rr=Tr=null,Vr=[],g();var r=e||q(),t=!0;for(e||(r.body=[]);wr!==Br;){var n=J();r.body.push(n),t&&D(n)&&R(!0),t=!1}return j(r,"Program")}function J(){(wr===wt||wr===Et&&"/="==Cr)&&g(!0);var e=wr,r=q();switch(e){case Mr:case Nr:U();var n=e===Mr;F(yt)||B()?r.label=null:wr!==Fr?X():(r.label=lr(),M());for(var a=0;a<Vr.length;++a){var o=Vr[a];if(null==r.label||o.name===r.label.name){if(null!=o.kind&&(n||"loop"===o.kind))break;if(r.label&&n)break}}return a===Vr.length&&t(r.start,"Unsyntactic "+e.keyword),j(r,n?"BreakStatement":"ContinueStatement");case Wr:return U(),M(),j(r,"DebuggerStatement");case Pr:return U(),Vr.push(Zt),r.body=J(),Vr.pop(),z(tt),r.test=P(),M(),j(r,"DoWhileStatement");case _r:if(U(),Vr.push(Zt),z(mt),wr===yt)return $(r,null);if(wr===rt){var i=q();return U(),G(i,!0),j(i,"VariableDeclaration"),1===i.declarations.length&&F(ut)?_(r,i):$(r,i)}var i=K(!1,!0);return F(ut)?(N(i),_(r,i)):$(r,i);case Gr:return U(),cr(r,!0);case Kr:return U(),r.test=P(),r.consequent=J(),r.alternate=F(Hr)?J():null,j(r,"IfStatement");case Qr:return Rr||t(yr,"'return' outside of function"),U(),F(yt)||B()?r.argument=null:(r.argument=K(),M()),j(r,"ReturnStatement");case Yr:U(),r.discriminant=P(),r.cases=[],z(pt),Vr.push(en);for(var s,c;wr!=ht;)if(wr===zr||wr===Jr){var u=wr===zr;s&&j(s,"SwitchCase"),r.cases.push(s=q()),s.consequent=[],U(),u?s.test=K():(c&&t(Ir,"Multiple default clauses"),c=!0,s.test=null),z(gt)}else s||X(),s.consequent.push(J());return s&&j(s,"SwitchCase"),U(),Vr.pop(),j(r,"SwitchStatement");case Zr:return U(),Gt.test(dr.slice(Lr,yr))&&t(Lr,"Illegal newline after throw"),r.argument=K(),M(),j(r,"ThrowStatement");case et:if(U(),r.block=H(),r.handler=null,wr===Xr){var l=q();U(),z(mt),l.param=lr(),Tr&&Nt(l.param.name)&&t(l.param.start,"Binding "+l.param.name+" in strict mode"),z(vt),l.guard=null,l.body=H(),r.handler=j(l,"CatchClause")}return r.guardedHandlers=qr,r.finalizer=F($r)?H():null,r.handler||r.finalizer||t(r.start,"Missing catch or finally clause"),j(r,"TryStatement");case rt:return U(),G(r),M(),j(r,"VariableDeclaration");case tt:return U(),r.test=P(),Vr.push(Zt),r.body=J(),Vr.pop(),j(r,"WhileStatement");case nt:return Tr&&t(yr,"'with' in strict mode"),U(),r.object=P(),r.body=J(),j(r,"WithStatement");case pt:return H();case yt:return U(),j(r,"EmptyStatement");default:var f=Cr,d=K();if(e===Fr&&"Identifier"===d.type&&F(gt)){for(var a=0;a<Vr.length;++a)Vr[a].name===f&&t(d.start,"Label '"+f+"' is already declared");var p=wr.isLoop?"loop":wr===Yr?"switch":null;return Vr.push({name:f,kind:p}),r.body=J(),Vr.pop(),r.label=d,j(r,"LabeledStatement")}return r.expression=d,M(),j(r,"ExpressionStatement")}}function P(){z(mt);var e=K();return z(vt),e}function H(e){var r,t=q(),n=!0,a=!1;for(t.body=[],z(pt);!F(ht);){var o=J();t.body.push(o),n&&e&&D(o)&&(r=a,R(a=!0)),n=!1}return a&&!r&&R(!1),j(t,"BlockStatement")}function $(e,r){return e.init=r,z(yt),e.test=wr===yt?null:K(),z(yt),e.update=wr===vt?null:K(),z(vt),e.body=J(),Vr.pop(),j(e,"ForStatement")}function _(e,r){return e.left=r,e.right=K(),z(vt),e.body=J(),Vr.pop(),j(e,"ForInStatement")}function G(e,r){for(e.declarations=[],e.kind="var";;){var n=q();if(n.id=lr(),Tr&&Nt(n.id.name)&&t(n.id.start,"Binding "+n.id.name+" in strict mode"),n.init=F(Ct)?K(!0,r):null,e.declarations.push(j(n,"VariableDeclarator")),!F(bt))break}return e}function K(e,r){var t=Q(r);if(!e&&wr===bt){var n=O(t);for(n.expressions=[t];F(bt);)n.expressions.push(Q(r));return j(n,"SequenceExpression")}return t}function Q(e){var r=Y(e);if(wr.isAssign){var t=O(r);return t.operator=Cr,t.left=r,U(),t.right=Q(e),N(r),j(t,"AssignmentExpression")}return r}function Y(e){var r=Z(e);if(F(kt)){var t=O(r);return t.test=r,t.consequent=K(!0),z(gt),t.alternate=K(!0,e),j(t,"ConditionalExpression")}return r}function Z(e){return er(rr(),-1,e)}function er(e,r,t){var n=wr.binop;if(null!=n&&(!t||wr!==ut)&&n>r){var a=O(e);a.left=e,a.operator=Cr,U(),a.right=er(rr(),n,t);var o=j(a,/&&|\|\|/.test(a.operator)?"LogicalExpression":"BinaryExpression");return er(o,r,t)}return e}function rr(){if(wr.prefix){var e=q(),r=wr.isUpdate;return e.operator=Cr,e.prefix=!0,Er=!0,U(),e.argument=rr(),r?N(e.argument):Tr&&"delete"===e.operator&&"Identifier"===e.argument.type&&t(e.start,"Deleting local variable in strict mode"),j(e,r?"UpdateExpression":"UnaryExpression")}for(var n=tr();wr.postfix&&!B();){var e=O(n);e.operator=Cr,e.prefix=!1,e.argument=n,N(n),U(),n=j(e,"UpdateExpression")}return n}function tr(){return nr(ar())}function nr(e,r){if(F(xt)){var t=O(e);return t.object=e,t.property=lr(!0),t.computed=!1,nr(j(t,"MemberExpression"),r)}if(F(ft)){var t=O(e);return t.object=e,t.property=K(),t.computed=!0,z(dt),nr(j(t,"MemberExpression"),r)}if(!r&&F(mt)){var t=O(e);return t.callee=e,t.arguments=ur(vt,!1),nr(j(t,"CallExpression"),r)}return e}function ar(){switch(wr){case ot:var e=q();return U(),j(e,"ThisExpression");case Fr:return lr();case Or:case Dr:case jr:var e=q();return e.value=Cr,e.raw=dr.slice(yr,gr),U(),j(e,"Literal");case it:case st:case ct:var e=q();return e.value=wr.atomValue,e.raw=wr.keyword,U(),j(e,"Literal");case mt:var r=xr,t=yr;U();var n=K();return n.start=t,n.end=gr,fr.locations&&(n.loc.start=r,n.loc.end=kr),fr.ranges&&(n.range=[t,gr]),z(vt),n;case ft:var e=q();return U(),e.elements=ur(dt,!0,!0),j(e,"ArrayExpression");case pt:return ir();case Gr:var e=q();return U(),cr(e,!1);case at:return or();default:X()}}function or(){var e=q();return U(),e.callee=nr(ar(),!0),e.arguments=F(mt)?ur(vt,!1):qr,j(e,"NewExpression")}function ir(){var e=q(),r=!0,n=!1;for(e.properties=[],U();!F(ht);){if(r)r=!1;else if(z(bt),fr.allowTrailingCommas&&F(ht))break;var a,o={key:sr()},i=!1;if(F(gt)?(o.value=K(!0),a=o.kind="init"):fr.ecmaVersion>=5&&"Identifier"===o.key.type&&("get"===o.key.name||"set"===o.key.name)?(i=n=!0,a=o.kind=o.key.name,o.key=sr(),wr!==mt&&X(),o.value=cr(q(),!1)):X(),"Identifier"===o.key.type&&(Tr||n))for(var s=0;s<e.properties.length;++s){var c=e.properties[s];if(c.key.name===o.key.name){var u=a==c.kind||i&&"init"===c.kind||"init"===a&&("get"===c.kind||"set"===c.kind);u&&!Tr&&"init"===a&&"init"===c.kind&&(u=!1),u&&t(o.key.start,"Redefinition of property")}}e.properties.push(o)}return j(e,"ObjectExpression")}function sr(){return wr===Or||wr===Dr?ar():lr(!0)}function cr(e,r){wr===Fr?e.id=lr():r?X():e.id=null,e.params=[];var n=!0;for(z(mt);!F(vt);)n?n=!1:z(bt),e.params.push(lr());var a=Rr,o=Vr;if(Rr=!0,Vr=[],e.body=H(!0),Rr=a,Vr=o,Tr||e.body.body.length&&D(e.body.body[0]))for(var i=e.id?-1:0;i<e.params.length;++i){var s=0>i?e.id:e.params[i];if((Xt(s.name)||Nt(s.name))&&t(s.start,"Defining '"+s.name+"' in strict mode"),i>=0)for(var c=0;i>c;++c)s.name===e.params[c].name&&t(s.start,"Argument name clash in strict mode")}return j(e,r?"FunctionDeclaration":"FunctionExpression")}function ur(e,r,t){for(var n=[],a=!0;!F(e);){if(a)a=!1;else if(z(bt),r&&fr.allowTrailingCommas&&F(e))break;t&&wr===bt?n.push(null):n.push(K(!0))}return n}function lr(e){var r=q();return r.name=wr===Fr?Cr:e&&!fr.forbidReserved&&wr.keyword||X(),Er=!1,U(),j(r,"Identifier")}e.version="0.4.0";var fr,dr,pr,hr;e.parse=function(e,t){return dr=String(e),pr=dr.length,r(t),o(),W(fr.program)};var mr=e.defaultOptions={ecmaVersion:5,strictSemicolons:!1,allowTrailingCommas:!0,forbidReserved:!1,locations:!1,onComment:null,ranges:!1,program:null,sourceFile:null},vr=e.getLineInfo=function(e,r){for(var t=1,n=0;;){Kt.lastIndex=n;var a=Kt.exec(e);if(!(a&&a.index<r))break;++t,n=a.index+a[0].length}return{line:t,column:r-n}};e.tokenize=function(e,t){function n(e){return g(e),a.start=yr,a.end=gr,a.startLoc=xr,a.endLoc=kr,a.type=wr,a.value=Cr,a}dr=String(e),pr=dr.length,r(t),o();var a={};return n.jumpTo=function(e,r){if(br=e,fr.locations){Ar=1,Sr=Kt.lastIndex=0;for(var t;(t=Kt.exec(dr))&&t.index<e;)++Ar,Sr=t.index+t[0].length}Er=r,u()},n};var br,yr,gr,xr,kr,wr,Cr,Er,Ar,Sr,Ir,Lr,Ur,Rr,Vr,Tr,qr=[],Or={type:"num"},jr={type:"regexp"},Dr={type:"string"},Fr={type:"name"},Br={type:"eof"},Mr={keyword:"break"},zr={keyword:"case",beforeExpr:!0},Xr={keyword:"catch"},Nr={keyword:"continue"},Wr={keyword:"debugger"},Jr={keyword:"default"},Pr={keyword:"do",isLoop:!0},Hr={keyword:"else",beforeExpr:!0},$r={keyword:"finally"},_r={keyword:"for",isLoop:!0},Gr={keyword:"function"},Kr={keyword:"if"},Qr={keyword:"return",beforeExpr:!0},Yr={keyword:"switch"},Zr={keyword:"throw",beforeExpr:!0},et={keyword:"try"},rt={keyword:"var"},tt={keyword:"while",isLoop:!0},nt={keyword:"with"},at={keyword:"new",beforeExpr:!0},ot={keyword:"this"},it={keyword:"null",atomValue:null},st={keyword:"true",atomValue:!0},ct={keyword:"false",atomValue:!1},ut={keyword:"in",binop:7,beforeExpr:!0},lt={"break":Mr,"case":zr,"catch":Xr,"continue":Nr,"debugger":Wr,"default":Jr,"do":Pr,"else":Hr,"finally":$r,"for":_r,"function":Gr,"if":Kr,"return":Qr,"switch":Yr,"throw":Zr,"try":et,"var":rt,"while":tt,"with":nt,"null":it,"true":st,"false":ct,"new":at,"in":ut,"instanceof":{keyword:"instanceof",binop:7,beforeExpr:!0},"this":ot,"typeof":{keyword:"typeof",prefix:!0,beforeExpr:!0},"void":{keyword:"void",prefix:!0,beforeExpr:!0},"delete":{keyword:"delete",prefix:!0,beforeExpr:!0}},ft={type:"[",beforeExpr:!0},dt={type:"]"},pt={type:"{",beforeExpr:!0},ht={type:"}"},mt={type:"(",beforeExpr:!0},vt={type:")"},bt={type:",",beforeExpr:!0},yt={type:";",beforeExpr:!0},gt={type:":",beforeExpr:!0},xt={type:"."},kt={type:"?",beforeExpr:!0},wt={binop:10,beforeExpr:!0},Ct={isAssign:!0,beforeExpr:!0},Et={isAssign:!0,beforeExpr:!0},At={binop:9,prefix:!0,beforeExpr:!0},St={postfix:!0,prefix:!0,isUpdate:!0},It={prefix:!0,beforeExpr:!0},Lt={binop:1,beforeExpr:!0},Ut={binop:2,beforeExpr:!0},Rt={binop:3,beforeExpr:!0},Vt={binop:4,beforeExpr:!0},Tt={binop:5,beforeExpr:!0},qt={binop:6,beforeExpr:!0},Ot={binop:7,beforeExpr:!0},jt={binop:8,beforeExpr:!0},Dt={binop:10,beforeExpr:!0};e.tokTypes={bracketL:ft,bracketR:dt,braceL:pt,braceR:ht,parenL:mt,parenR:vt,comma:bt,semi:yt,colon:gt,dot:xt,question:kt,slash:wt,eq:Ct,name:Fr,eof:Br,num:Or,regexp:jr,string:Dr};for(var Ft in lt)e.tokTypes["_"+Ft]=lt[Ft];var Bt,Mt=n("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),zt=n("class enum extends super const export import"),Xt=n("implements interface let package private protected public static yield"),Nt=n("eval arguments"),Wt=n("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"),Jt=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/,Pt="\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc",Ht="\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f",$t=new RegExp("["+Pt+"]"),_t=new RegExp("["+Pt+Ht+"]"),Gt=/[\n\r\u2028\u2029]/,Kt=/\r\n|[\n\r\u2028\u2029]/g,Qt=e.isIdentifierStart=function(e){return 65>e?36===e:91>e?!0:97>e?95===e:123>e?!0:e>=170&&$t.test(String.fromCharCode(e))},Yt=e.isIdentifierChar=function(e){return 48>e?36===e:58>e?!0:65>e?!1:91>e?!0:97>e?95===e:123>e?!0:e>=170&&_t.test(String.fromCharCode(e))},Zt={kind:"loop"},en={kind:"switch"}});

	var binaryOperators = {
		'+': '__add',
		'-': '__subtract',
		'*': '__multiply',
		'/': '__divide',
		'%': '__modulo',
		'==': 'equals',
		'!=': 'equals'
	};

	var unaryOperators = {
		'-': '__negate',
		'+': null
	};

	var fields = Base.each(
		['add', 'subtract', 'multiply', 'divide', 'modulo', 'negate'],
		function(name) {
			this['__' + name] = '#' + name;
		},
		{}
	);
	Point.inject(fields);
	Size.inject(fields);
	Color.inject(fields);

	function __$__(left, operator, right) {
		var handler = binaryOperators[operator];
		if (left && left[handler]) {
			var res = left[handler](right);
			return operator === '!=' ? !res : res;
		}
		switch (operator) {
		case '+': return left + right;
		case '-': return left - right;
		case '*': return left * right;
		case '/': return left / right;
		case '%': return left % right;
		case '==': return left == right;
		case '!=': return left != right;
		}
	}

	function $__(operator, value) {
		var handler = unaryOperators[operator];
		if (handler && value && value[handler])
			return value[handler]();
		switch (operator) {
		case '+': return +value;
		case '-': return -value;
		}
	}

	function parse(code, options) {
		return scope.acorn.parse(code, options);
	}

	function compile(code, url, options) {
		if (!code)
			return '';
		options = options || {};
		url = url || '';

		var insertions = [];

		function getOffset(offset) {
			for (var i = 0, l = insertions.length; i < l; i++) {
				var insertion = insertions[i];
				if (insertion[0] >= offset)
					break;
				offset += insertion[1];
			}
			return offset;
		}

		function getCode(node) {
			return code.substring(getOffset(node.range[0]),
					getOffset(node.range[1]));
		}

		function getBetween(left, right) {
			return code.substring(getOffset(left.range[1]),
					getOffset(right.range[0]));
		}

		function replaceCode(node, str) {
			var start = getOffset(node.range[0]),
				end = getOffset(node.range[1]),
				insert = 0;
			for (var i = insertions.length - 1; i >= 0; i--) {
				if (start > insertions[i][0]) {
					insert = i + 1;
					break;
				}
			}
			insertions.splice(insert, 0, [start, str.length - end + start]);
			code = code.substring(0, start) + str + code.substring(end);
		}

		function walkAST(node, parent) {
			if (!node)
				return;
			for (var key in node) {
				if (key === 'range' || key === 'loc')
					continue;
				var value = node[key];
				if (Array.isArray(value)) {
					for (var i = 0, l = value.length; i < l; i++)
						walkAST(value[i], node);
				} else if (value && typeof value === 'object') {
					walkAST(value, node);
				}
			}
			switch (node.type) {
			case 'UnaryExpression':
				if (node.operator in unaryOperators
						&& node.argument.type !== 'Literal') {
					var arg = getCode(node.argument);
					replaceCode(node, '$__("' + node.operator + '", '
							+ arg + ')');
				}
				break;
			case 'BinaryExpression':
				if (node.operator in binaryOperators
						&& node.left.type !== 'Literal') {
					var left = getCode(node.left),
						right = getCode(node.right),
						between = getBetween(node.left, node.right),
						operator = node.operator;
					replaceCode(node, '__$__(' + left + ','
							+ between.replace(new RegExp('\\' + operator),
								'"' + operator + '"')
							+ ', ' + right + ')');
				}
				break;
			case 'UpdateExpression':
			case 'AssignmentExpression':
				var parentType = parent && parent.type;
				if (!(
						parentType === 'ForStatement'
						|| parentType === 'BinaryExpression'
							&& /^[=!<>]/.test(parent.operator)
						|| parentType === 'MemberExpression' && parent.computed
				)) {
					if (node.type === 'UpdateExpression') {
						var arg = getCode(node.argument),
							exp = '__$__(' + arg + ', "' + node.operator[0]
									+ '", 1)',
							str = arg + ' = ' + exp;
						if (!node.prefix
								&& (parentType === 'AssignmentExpression'
									|| parentType === 'VariableDeclarator')) {
							if (getCode(parent.left || parent.id) === arg)
								str = exp;
							str = arg + '; ' + str;
						}
						replaceCode(node, str);
					} else {
						if (/^.=$/.test(node.operator)
								&& node.left.type !== 'Literal') {
							var left = getCode(node.left),
								right = getCode(node.right);
							replaceCode(node, left + ' = __$__(' + left + ', "'
									+ node.operator[0] + '", ' + right + ')');
						}
					}
				}
				break;
			}
		}
		var sourceMap = null,
			browser = paper.browser,
			version = browser.versionNumber,
			lineBreaks = /\r\n|\n|\r/mg;
		if (browser.chrome && version >= 30
				|| browser.webkit && version >= 537.76
				|| browser.firefox && version >= 23) {
			var offset = 0;
			if (window.location.href.indexOf(url) === 0) {
				var html = document.getElementsByTagName('html')[0].innerHTML;
				offset = html.substr(0, html.indexOf(code) + 1).match(
						lineBreaks).length + 1;
			}
			var mappings = ['AAAA'];
			mappings.length = (code.match(lineBreaks) || []).length + 1 + offset;
			sourceMap = {
				version: 3,
				file: url,
				names:[],
				mappings: mappings.join(';AACA'),
				sourceRoot: '',
				sources: [url]
			};
			var source = options.source || !url && code;
			if (source)
				sourceMap.sourcesContent = [source];
		}
		walkAST(parse(code, { ranges: true }));
		if (sourceMap) {
			code = new Array(offset + 1).join('\n') + code
					+ "\n//# sourceMappingURL=data:application/json;base64,"
					+ (btoa(unescape(encodeURIComponent(
						JSON.stringify(sourceMap)))))
					+ "\n//# sourceURL=" + (url || 'paperscript');
		}
		return code;
	}

	function execute(code, scope, url, options) {
		paper = scope;
		var view = scope.getView(),
			tool = /\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code)
					? new Tool()
					: null,
			toolHandlers = tool ? tool._events : [],
			handlers = ['onFrame', 'onResize'].concat(toolHandlers),
			params = [],
			args = [],
			func;
		code = compile(code, url, options);
		function expose(scope, hidden) {
			for (var key in scope) {
				if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)'
						+ key.replace(/\$/g, '\\$') + '\\b').test(code)) {
					params.push(key);
					args.push(scope[key]);
				}
			}
		}
		expose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },
				true);
		expose(scope);
		handlers = Base.each(handlers, function(key) {
			if (new RegExp('\\s+' + key + '\\b').test(code)) {
				params.push(key);
				this.push(key + ': ' + key);
			}
		}, []).join(', ');
		if (handlers)
			code += '\nreturn { ' + handlers + ' };';
		var browser = paper.browser;
		if (browser.chrome || browser.firefox) {
			var script = document.createElement('script'),
				head = document.head || document.getElementsByTagName('head')[0];
			if (browser.firefox)
				code = '\n' + code;
			script.appendChild(document.createTextNode(
				'paper._execute = function(' + params + ') {' + code + '\n}'
			));
			head.appendChild(script);
			func = paper._execute;
			delete paper._execute;
			head.removeChild(script);
		} else {
			func = Function(params, code);
		}
		var res = func.apply(scope, args) || {};
		Base.each(toolHandlers, function(key) {
			var value = res[key];
			if (value)
				tool[key] = value;
		});
		if (view) {
			if (res.onResize)
				view.setOnResize(res.onResize);
			view.emit('resize', {
				size: view.size,
				delta: new Point()
			});
			if (res.onFrame)
				view.setOnFrame(res.onFrame);
			view.update();
		}
	}

	function loadScript(script) {
		if (/^text\/(?:x-|)paperscript$/.test(script.type)
				&& PaperScope.getAttribute(script, 'ignore') !== 'true') {
			var canvasId = PaperScope.getAttribute(script, 'canvas'),
				canvas = document.getElementById(canvasId),
				src = script.src || script.getAttribute('data-src'),
				async = PaperScope.hasAttribute(script, 'async'),
				scopeAttribute = 'data-paper-scope';
			if (!canvas)
				throw new Error('Unable to find canvas with id "'
						+ canvasId + '"');
			var scope = PaperScope.get(canvas.getAttribute(scopeAttribute))
						|| new PaperScope().setup(canvas);
			canvas.setAttribute(scopeAttribute, scope._id);
			if (src) {
				Http.request('get', src, function(code) {
					execute(code, scope, src);
				}, async);
			} else {
				execute(script.innerHTML, scope, script.baseURI);
			}
			script.setAttribute('data-paper-ignore', 'true');
			return scope;
		}
	}

	function loadAll() {
		Base.each(document.getElementsByTagName('script'), loadScript);
	}

	function load(script) {
		return script ? loadScript(script) : loadAll();
	}

	if (document.readyState === 'complete') {
		setTimeout(loadAll);
	} else {
		DomEvent.add(window, { load: loadAll });
	}

	return {
		compile: compile,
		execute: execute,
		load: load,
		parse: parse
	};

}).call(this);

paper = new (PaperScope.inject(Base.exports, {
	enumerable: true,
	Base: Base,
	Numerical: Numerical,
	Key: Key
}))();

if (typeof define === 'function' && define.amd) {
	define('paper', paper);
} else if (typeof module === 'object' && module) {
	module.exports = paper;
}

return paper;
};

},{}],8:[function(require,module,exports){
var AudioContext;

AudioContext = window.AudioContext || window.webkitAudioContext;

module.exports = {
  AudioContext: new AudioContext()
};


},{}],9:[function(require,module,exports){
var Dispatcher, Promise;

Promise = (require('es6-promise')).Promise;

Dispatcher = (function() {
  function Dispatcher() {
    this.delegates = [];
  }

  Dispatcher.prototype.register = function(delegate) {
    return this.delegates.push(delegate);
  };

  Dispatcher.prototype.dispatch = function(payload) {
    var _promises, _rejects, _resolves;
    _resolves = [];
    _rejects = [];
    _promises = this.delegates.map(function(d, idx) {
      return new Promise(function(resolve, reject) {
        _resolves[idx] = resolve;
        return _rejects[idx] = reject;
      });
    });
    this.delegates.forEach(function(delegate, idx) {
      return Promise.resolve(delegate(payload)).then((function() {
        return _resolves[i](payload);
      }), (function() {
        return _rejects[i](new Error('Dispatcher callback unsuccessful'));
      }));
    });
    return _promises = [];
  };

  return Dispatcher;

})();

module.exports = new Dispatcher();


},{"es6-promise":3}],10:[function(require,module,exports){
var GranularSynth, SynthPool, SynthStore, _, k;

_ = require('lodash');

k = require('../Constants');

GranularSynth = require('./granular');

SynthStore = require('../stores/Synths');

SynthPool = (function() {
  function SynthPool(options) {
    var i, ref, results;
    if (options == null) {
      options = {};
    }
    SynthStore.addChangeListener((function(_this) {
      return function() {
        return _this.update(SynthStore.getAll());
      };
    })(this));
    this.options = _.defaults(options, {
      voices: 4
    });
    this.voices = (function() {
      results = [];
      for (var i = 0, ref = this.options.voices; 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--){ results.push(i); }
      return results;
    }).apply(this).map((function(_this) {
      return function(idx) {
        return {
          synth: new GranularSynth(k.AudioContext),
          gain: k.AudioContext.createGain(),
          index: idx,
          id: null,
          priority: -1,
          busy: function() {
            return this.id != null;
          }
        };
      };
    })(this));
    this.output = k.AudioContext.createGain();
    this.voices.forEach((function(_this) {
      return function(voice) {
        voice.synth.output.connect(voice.gain);
        return voice.gain.connect(_this.output);
      };
    })(this));
    this.update(SynthStore.getAll());
  }

  SynthPool.prototype.update = function(state) {
    this.output.gain.value = state.master.volume * (state.master.isMuted ? 0 : 1);
    return _(state.synths).take(this.options.voices).value().forEach((function(_this) {
      return function(synth) {
        var v;
        v = _.find(_this.voices, function(voice) {
          return voice.id === synth.id;
        });
        if (v != null) {
          return _this._updateVoice(v, synth);
        } else {
          return _this.pushSynth(synth, synth.level);
        }
      };
    })(this));
  };

  SynthPool.prototype.pushSynth = function(synth, priority) {
    var bottom;
    bottom = (_.sortBy(this.voices, 'priority'))[0];
    if (bottom.priority < priority) {
      this.voices[bottom.index] = _.assign(bottom, {
        id: synth.id,
        priority: priority
      });
      this.voices[bottom.index].synth.set(synth.options);
      return this.noteOn(bottom.index, 1);
    } else {
      return console.log('not high enough priority');
    }
  };

  SynthPool.prototype.set = function(voiceIdx, voiceOptions, synthOptions) {
    if (voiceOptions == null) {
      voiceOptions = {};
    }
    if (synthOptions == null) {
      synthOptions = {};
    }
    if (this.voices[voiceIdx] != null) {
      return this._setVoice(this.voices[voiceIdx], voiceOptions, synthOptions);
    }
  };

  SynthPool.prototype.prioritize = function(priority, synth) {
    var bottom, inPool, voiceOptions;
    inPool = (this.voices.filter(function(v) {
      return v.id === synth.id;
    }))[0];
    if (inPool != null) {
      return inPool.priority = priority;
    } else {
      bottom = (_.sortBy(this.voices, 'priority'))[0];
      voiceOptions = {
        id: synth.id,
        priority: priority
      };
      return this._setVoice(bottom, voiceOptions, synth.options);
    }
  };

  SynthPool.prototype.setGain = function(gain, synth) {
    var i, len, ref, v, voice;
    voice = null;
    ref = this.voices;
    for (i = 0, len = ref.length; i < len; i++) {
      v = ref[i];
      if (v.id === synth.id) {
        voice = v;
        break;
      }
    }
    if (voice != null) {
      return voice.gain.gain.linearRampToValueAtTime(gain, k.AudioContext.currentTime + 0.016);
    } else {
      return console.log("couldn't find voice");
    }
  };

  SynthPool.prototype.noteOn = function(voiceIdx, velocity) {
    var ref, ref1;
    return (ref = this.voices[voiceIdx]) != null ? (ref1 = ref.synth) != null ? ref1.noteOn(velocity) : void 0 : void 0;
  };

  SynthPool.prototype._updateVoice = function(voice, synth) {
    voice.synth.set(synth.options);
    return voice.gain.gain.linearRampToValueAtTime(synth.level, k.AudioContext.currentTime + 0.016);
  };

  SynthPool.prototype._setVoice = function(voice, voiceOptions, synthOptions) {
    _.assign(voice, voiceOptions);
    voice.synth.set(synthOptions);
    return this.noteOn(voice.index, 1);
  };

  return SynthPool;

})();

module.exports = SynthPool;


},{"../Constants":8,"../stores/Synths":17,"./granular":12,"lodash":"lodash"}],11:[function(require,module,exports){
var Envelope, EventTarget, TriggerEnvelope, _, ms2s,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

EventTarget = require('oo-eventtarget');

ms2s = function(ms) {
  return ms / 1000.0;
};

Envelope = (function() {
  function Envelope(audioContext, envelope) {
    this.audioContext = audioContext;
    if (envelope == null) {
      envelope = {};
    }
    this._release = bind(this._release, this);
    this._attack = bind(this._attack, this);
    EventTarget(this);
    this.envelope = _.defaults(envelope, {
      attack: 100,
      release: 1000
    });
    this.gainNode = this.audioContext.createGain();
    Object.defineProperty(this, '_now', {
      get: function() {
        return this.audioContext.currentTime;
      }
    });
    Object.defineProperty(this, 'input', {
      get: function() {
        return this.gainNode;
      }
    });
    Object.defineProperty(this, 'output', {
      get: function() {
        return this.gainNode;
      }
    });
  }

  Envelope.prototype.setEnvelope = function(envelope) {
    return _.assign(this.envelope, envelope);
  };

  Envelope.prototype.noteOn = function(velocity) {
    this._reset();
    return this._attack();
  };

  Envelope.prototype.noteOff = function() {
    return this._release();
  };

  Envelope.prototype._attack = function() {
    this.gainNode.gain.linearRampToValueAtTime(0.0, this._now);
    return this.gainNode.gain.linearRampToValueAtTime(1.0, this._now + ms2s(this.envelope.attack));
  };

  Envelope.prototype._release = function() {
    this.gainNode.gain.linearRampToValueAtTime(0.0, this._now + ms2s(this.envelope.release));
    return this._releaseTimeout = setTimeout(this._willFire('released'), this.envelope.release);
  };

  Envelope.prototype._reset = function() {
    if (this._releaseTimeout != null) {
      clearTimeout(this._releaseTimeout);
      this._releaseTimeout = null;
    }
    return this.gainNode.gain.cancelScheduledValues(this._now);
  };

  Envelope.prototype._willFire = function(eventName, detail) {
    if (detail == null) {
      detail = {};
    }
    return (function(_this) {
      return function() {
        return _this.dispatchEvent(eventName, detail);
      };
    })(this);
  };

  return Envelope;

})();

TriggerEnvelope = (function(superClass) {
  extend(TriggerEnvelope, superClass);

  function TriggerEnvelope(audioContext, envelope) {
    this.audioContext = audioContext;
    if (envelope == null) {
      envelope = {};
    }
    TriggerEnvelope.__super__.constructor.call(this, this.audioContext, envelope);
    this.envelope = _.defaults(this.envelope, {
      hold: 1000
    });
  }

  TriggerEnvelope.prototype.setHoldDuration = function(duration) {
    return this.envelope.hold = duration;
  };

  TriggerEnvelope.prototype.noteOn = function(velocity) {
    TriggerEnvelope.__super__.noteOn.call(this, velocity);
    return this._holdTimeout = setTimeout(this._release, this.envelope.hold + this.envelope.attack);
  };

  TriggerEnvelope.prototype._reset = function() {
    TriggerEnvelope.__super__._reset.call(this);
    if (this._holdTimeout != null) {
      clearTimeout(this._holdTimeout);
      return this._holdTimeout = null;
    }
  };

  TriggerEnvelope.prototype.noteOff = function() {};

  return TriggerEnvelope;

})(Envelope);

module.exports = {
  Envelope: Envelope,
  TriggerEnvelope: TriggerEnvelope
};


},{"lodash":"lodash","oo-eventtarget":5}],12:[function(require,module,exports){
var Envelope, GranularSynth, GranularVoice, Sampler, TimeoutManager, TriggerEnvelope, _, ms2s, ref, s2ms;

_ = require('lodash');

require('object.observe');

TimeoutManager = require('../util/TimeoutManager');

Sampler = require('./sampler');

ref = require('./envelope'), Envelope = ref.Envelope, TriggerEnvelope = ref.TriggerEnvelope;

ms2s = function(ms) {
  return ms / 1000.0;
};

s2ms = function(s) {
  return s * 1000.0;
};

GranularVoice = (function() {
  function GranularVoice(audioContext, options) {
    this.audioContext = audioContext;
    if (options == null) {
      options = {};
    }
    this.options = _.defaults(options, {
      buffer: null,
      center: 0.5,
      grainDuration: 300,
      durationRandom: 150,
      deviation: 150,
      gain: 0.7,
      fadeRatio: 0.1,
      detune: 0
    });
    this.sampler = new Sampler(this.audioContext, this.options.buffer);
    this.envelope = new TriggerEnvelope(this.audioContext);
    this.sampler.output.connect(this.envelope.input);
    Object.defineProperty(this, 'output', {
      get: function() {
        return this.envelope.output;
      }
    });
    Object.defineProperty(this, 'bufferDuration', {
      get: function() {
        return s2ms(this.options.buffer.duration);
      }
    });
  }

  GranularVoice.prototype.set = function(options) {
    if (options == null) {
      options = {};
    }
    if ((options.buffer != null) && options.buffer !== this.sampler.buffer) {
      this.noteOff();
      this.sampler.noteOff();
      this.sampler.output.disconnect();
      this.sampler = new Sampler(this.audioContext, this.options.buffer);
      this.sampler.output.connect(this.envelope.input);
    }
    return this.options = _.assign(this.options, options);
  };

  GranularVoice.prototype.noteOn = function(velocity) {
    var restart;
    restart = this._willTriggerGrain(velocity);
    this.envelope.addEventListener('released', restart);
    this._unsubRelease = (function(_this) {
      return function() {
        return _this.envelope.removeEventListener('released', restart);
      };
    })(this);
    return restart();
  };

  GranularVoice.prototype.noteOff = function() {
    if (this._unsubRelease != null) {
      this._unsubRelease();
      this._unsubRelease = null;
    }
    this.sampler.noteOff();
    return this.envelope.noteOff();
  };

  GranularVoice.prototype._willTriggerGrain = function(velocity) {
    return (function(_this) {
      return function() {
        var duration, fadeTime, offset, ref1;
        ref1 = _this._pickGrain(), offset = ref1.offset, duration = ref1.duration;
        fadeTime = _this.options.fadeRatio * duration;
        _this.envelope.setEnvelope({
          attack: fadeTime,
          hold: duration - fadeTime * 2,
          release: fadeTime
        });
        _this.sampler.setOffset(offset);
        _this.sampler.detune(_this.options.detune);
        _this.sampler.noteOn(velocity);
        _this.envelope.noteOn(velocity);
        return {
          offset: offset,
          duration: duration
        };
      };
    })(this);
  };

  GranularVoice.prototype._pickGrain = function() {
    var deviation, duration, durationRandom;
    if (this.options.buffer != null) {
      deviation = Math.random() * this.options.deviation;
      duration = this.options.grainDuration;
      durationRandom = Math.random() * this.options.durationRandom;
      duration += durationRandom;
      return {
        offset: this.options.center * this.bufferDuration - (duration / 2) + deviation,
        duration: duration
      };
    } else {
      return {
        offset: 0,
        duration: 0
      };
    }
  };

  return GranularVoice;

})();

GranularSynth = (function() {
  function GranularSynth(audioContext, options) {
    var i, ref1, results;
    this.audioContext = audioContext;
    if (options == null) {
      options = {};
    }
    this.options = _.defaultsDeep(options, {
      voices: 3,
      granular: {
        buffer: null,
        center: 0.5,
        grainDuration: 300,
        durationRandom: 150,
        deviation: 150,
        fadeRatio: 0.25,
        gain: options.voices != null ? 1 / options.voices : 1 / 3,
        detune: 0
      }
    });
    this.envelope = new Envelope(this.audioContext, {
      attack: 0,
      release: 0
    });
    this.voices = (function() {
      results = [];
      for (var i = 0, ref1 = this.options.voices; 0 <= ref1 ? i < ref1 : i > ref1; 0 <= ref1 ? i++ : i--){ results.push(i); }
      return results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this._makeVoice();
      };
    })(this));
    Object.defineProperty(this, 'output', {
      get: function() {
        return this.envelope.output;
      }
    });
    Object.defineProperty(this, 'bufferDuration', {
      get: function() {
        var ref2;
        return s2ms((ref2 = this.options.granular.buffer) != null ? ref2.duration : void 0);
      }
    });
  }

  GranularSynth.prototype.noteOn = function(velocity) {
    var attemptTriggerVoice, freeVoices, triggerAndWait, voiceAmp;
    voiceAmp = 1.0 / this.voices.length;
    freeVoices = this.voices.slice();
    attemptTriggerVoice = (function(_this) {
      return function() {
        var freeMe, hd;
        hd = freeVoices.shift();
        if (hd != null) {
          freeMe = function() {
            hd.envelope.removeEventListener('released', freeMe);
            return freeVoices.push(hd);
          };
          hd.envelope.addEventListener('released', freeMe);
          return (hd._willTriggerGrain(voiceAmp)()).duration;
        } else {
          return -1;
        }
      };
    })(this);
    triggerAndWait = (function(_this) {
      return function() {
        var duration, waitTilNext;
        duration = attemptTriggerVoice();
        waitTilNext = duration === -1 ? _this.options.grainDuration / _this.voices.length : duration / _this.voices.length;
        return _this._noteTimeout = setTimeout(triggerAndWait, waitTilNext);
      };
    })(this);
    triggerAndWait();
    return this.envelope.noteOn(velocity);
  };

  GranularSynth.prototype.noteOff = function() {
    if (this._noteTimeout) {
      clearTimeout(this._noteTimeout);
    }
    this.voices.forEach(function(voice) {
      return voice.noteOff();
    });
    return this.envelope.noteOff();
  };

  GranularSynth.prototype.parameters = function() {
    return {
      center: {
        id: 'center',
        display: 'center',
        range: [0, 1],
        mapValue: (function(_this) {
          return function(val) {
            return _this.options.granular.center = val;
          };
        })(this)
      },
      grainDuration: {
        id: 'grainDuration',
        display: 'grain duration',
        range: [0, 1],
        mapValue: (function(_this) {
          return function(val) {
            return _this.options.granular.grainDuration = val;
          };
        })(this)
      },
      durationRandom: {
        id: 'durationRandom',
        display: 'duration random',
        range: [0, 1],
        mapValue: (function(_this) {
          return function(val) {
            return _this.options.granular.durationRandom = val;
          };
        })(this)
      },
      deviation: {
        id: 'deviation',
        display: 'offset deviation',
        range: [0, 1],
        mapValue: (function(_this) {
          return function(val) {
            return _this.options.granular.deviation = val;
          };
        })(this)
      },
      fadeRatio: {
        id: 'fadeRatio',
        display: 'fade ratio',
        range: [0, 1],
        mapValue: (function(_this) {
          return function(val) {
            return _this.options.granular.fadeRatio = val;
          };
        })(this)
      },
      detune: {
        id: 'detune',
        display: 'detune (cents)',
        range: [-1200, 1200],
        mapValue: (function(_this) {
          return function(val) {
            return _this.options.granular.detune = val;
          };
        })(this)
      }
    };
  };

  GranularSynth.prototype.parameterList = function() {
    return _.values(this.parameters());
  };

  GranularSynth.prototype.set = function(options) {
    var granularOptions;
    if (options.voices != null) {
      while (this.voices.length !== options.voices) {
        if (this.voices.length > options.voices) {
          this.voices[this.voices.length - 1].noteOff();
          this.voices.splice(this.voices.length - 1, 1);
        } else if (this.voices.length < options.voices) {
          this.voices.push(this._makeVoice());
        }
      }
    }
    this.options = _.assign(this.options, options);
    granularOptions = _.assign(this.options.granular, options.granular);
    this.options.granular = granularOptions;
    return this.voices.forEach((function(_this) {
      return function(voice) {
        return voice.set(options.granular);
      };
    })(this));
  };

  GranularSynth.prototype._makeVoice = function() {
    var s;
    s = new GranularVoice(this.audioContext, this.options.granular);
    s.output.connect(this.envelope.input);
    return s;
  };

  return GranularSynth;

})();

module.exports = GranularSynth;


},{"../util/TimeoutManager":21,"./envelope":11,"./sampler":13,"lodash":"lodash","object.observe":4}],13:[function(require,module,exports){
var EventTarget, Sampler, _, ms2s, s2ms;

_ = require('lodash');

EventTarget = require('oo-eventtarget');

ms2s = function(ms) {
  return ms / 1000.0;
};

s2ms = function(s) {
  return s * 1000.0;
};

Sampler = (function() {
  Sampler.__instanceCount = 0;

  function Sampler(context, buffer1, offset1) {
    this.context = context;
    this.buffer = buffer1;
    this.offset = offset1 != null ? offset1 : 0;
    EventTarget(this);
    this.id = Sampler.__instanceCount++;
    this.velocityNode = this.context.createGain();
    Object.defineProperty(this, 'output', {
      get: function() {
        return this.velocityNode;
      }
    });
  }

  Sampler.prototype.noteOn = function(velocity) {
    if (this.node != null) {
      this.node.stop();
      this.node = null;
    }
    this.velocityNode.gain.value = Math.max(Math.min(1, velocity), 0);
    if (this.buffer != null) {
      this.node = this._makeNode(this.buffer);
      this.node.detune.setValueAtTime(this.detuneAmount, this.context.currentTime);
      this.node.start(0, ms2s(this.offset));
      return this.node.connect(this.velocityNode);
    }
  };

  Sampler.prototype.noteOff = function() {};

  Sampler.prototype.setOffset = function(offset) {
    return this.offset = Math.max(0, offset);
  };

  Sampler.prototype.detune = function(detuneAmount) {
    this.detuneAmount = detuneAmount;
  };

  Sampler.prototype._makeNode = function(buffer) {
    var node;
    if (this.node != null) {
      this.node.disconnect();
    }
    node = this.context.createBufferSource();
    node.buffer = buffer;
    return node;
  };

  return Sampler;

})();

module.exports = Sampler;


},{"lodash":"lodash","oo-eventtarget":5}],14:[function(require,module,exports){
var Application, React, SynthPool, _, audio, container, dispatcher, initialProps, k, sp, view;

_ = require('lodash');

React = require('react');

Application = require('./view/Application');

SynthPool = require('./audio/SynthPool');

k = require('./Constants');

dispatcher = require('./Dispatcher');

require('./stores/World');

require('./stores/Synths');

require('./stores/User');

sp = new SynthPool({
  voices: 3
});

sp.output.connect(k.AudioContext.destination);

container = document.body;

audio = {
  audioSource: sp.output
};

initialProps = _.assign({}, audio);

view = React.createElement(Application, initialProps);

React.render(view, container);


},{"./Constants":8,"./Dispatcher":9,"./audio/SynthPool":10,"./stores/Synths":17,"./stores/User":18,"./stores/World":19,"./view/Application":23,"lodash":"lodash","react":"react"}],15:[function(require,module,exports){
var Editor, Paper, Store, WorldStore, k,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Paper = require('paper');

Store = require('./Store');

WorldStore = require('./World');

k = require('../Constants');

Editor = (function(superClass) {
  extend(Editor, superClass);

  function Editor() {
    return Editor.__super__.constructor.apply(this, arguments);
  }

  Editor.prototype.getDefaultData = function() {
    return {
      activeEntityId: null,
      activeEntity: null,
      isActive: false,
      queuedEntity: null,
      events: {
        wantsEdit: false,
        wantsCancelInspector: false
      }
    };
  };

  Editor.prototype.delegate = function(payload) {
    var data, entity, id, ref, ref1;
    data = payload != null ? (ref = payload.action) != null ? ref.data : void 0 : void 0;
    switch (payload != null ? (ref1 = payload.action) != null ? ref1.actionType : void 0 : void 0) {
      case 'wantsEditEntity':
        id = data.id.id;
        entity = WorldStore.getEntity(data.id);
        if (entity != null) {
          this.data.events.wantsEdit = true;
          this.data.queuedEntity = entity;
          return this.emitChange();
        }
        break;
      case 'didBeginEditEntity':
        entity = data.entity;
        this.data.events.wantsEdit = false;
        this.data.activeEntity = entity;
        this.data.isActive = true;
        return this.emitChange();
      case 'wantsCancelEditEntity':
        this.data.events.wantsCancel = true;
        return this.emitChange();
      case 'didCancelEditEntity':
        this.data.events.wantsCancel = false;
        this.data.isActive = false;
        return this.emitChange();
    }
  };

  Editor.prototype.setEditEntity = function(entityId) {
    this.data.activeEntityId = entityId;
    return this.data.activeEntity = WorldStore.getEntity(this.data.activeEntityId);
  };

  return Editor;

})(Store);

module.exports = new Editor();


},{"../Constants":8,"./Store":16,"./World":19,"paper":7}],16:[function(require,module,exports){
var CHANGE_EVENT, Dispatchable, EventEmitter, Store, _, dispatcher,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

EventEmitter = require('events').EventEmitter;

dispatcher = require('../Dispatcher');

Dispatchable = require('../util/Dispatchable');

CHANGE_EVENT = 'change';

Store = (function(superClass) {
  extend(Store, superClass);

  function Store(initialData) {
    if (initialData == null) {
      initialData = {};
    }
    Dispatchable(this, dispatcher);
    this.data = _.extend(this.getDefaultData(), initialData);
    this.registerOnDispatcher();
  }

  Store.prototype.getDefaultData = function() {
    return {};
  };

  Store.prototype.getAll = function() {
    return this.data;
  };

  Store.prototype.emitChange = function() {
    return this.emit(CHANGE_EVENT);
  };

  Store.prototype.addChangeListener = function(cb) {
    return this.on(CHANGE_EVENT, cb);
  };

  Store.prototype.removeChangeListener = function(cb) {
    return this.removeListener(CHANGE_EVENT, cb);
  };

  Store.prototype.delegate = void 0;

  Store.prototype.registerOnDispatcher = function(delegate) {
    if (this.delegate != null) {
      return dispatcher.register((function(_this) {
        return function() {
          return _this.delegate.apply(_this, arguments);
        };
      })(this));
    } else {
      return console.warn('No delegate for ', this);
    }
  };

  return Store;

})(EventEmitter);

module.exports = Store;


},{"../Dispatcher":9,"../util/Dispatchable":20,"events":1,"lodash":"lodash"}],17:[function(require,module,exports){
var DEFAULT_BUFFER, Store, Synths, WorldStore, _, k,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

Store = require('./Store');

WorldStore = require('./World');

k = require('../Constants');

DEFAULT_BUFFER = null;

(function() {
  var request;
  request = new XMLHttpRequest();
  request.open('GET', './dist/sounds/hen.wav', true);
  request.responseType = 'arraybuffer';
  request.onload = function() {
    return k.AudioContext.decodeAudioData(request.response, (function(_this) {
      return function(buffer) {
        return DEFAULT_BUFFER = buffer;
      };
    })(this));
  };
  return request.send();
})();

Synths = (function(superClass) {
  extend(Synths, superClass);

  function Synths() {
    return Synths.__super__.constructor.apply(this, arguments);
  }

  Synths.prototype.getDefaultData = function() {
    return {
      synths: [],
      master: {
        volume: 1,
        isMuted: false
      }
    };
  };

  Synths.prototype.delegate = function(payload) {
    var buffer, data, entity, file, isMuted, parameter, reader, ref, ref1, synth;
    data = payload != null ? (ref = payload.action) != null ? ref.data : void 0 : void 0;
    switch (payload != null ? (ref1 = payload.action) != null ? ref1.actionType : void 0 : void 0) {
      case 'didMasterChangeMute':
        isMuted = data.isMuted;
        this.data.master.isMuted = isMuted;
        return this.emitChange();
      case 'didAddEntity':
        entity = data.entity;
        entity.synth = {
          id: entity.id,
          level: 0,
          options: this.defaultSynthOptions()
        };
        Object.defineProperty(entity.synth, 'needsFile', {
          get: function() {
            return entity.synth.options.granular.buffer == null;
          }
        });
        return this.emitChange();
      case 'wantsLoadSoundFile':
        entity = data.entity, file = data.file;
        reader = new FileReader();
        reader.onload = (function(_this) {
          return function(evt) {
            data = evt.target.result;
            k.AudioContext.decodeAudioData(data, function(buffer) {
              return _this.dispatch('loadBufferIntoEntity', {
                buffer: buffer,
                entity: entity
              });
            });
            return _this.emitChange();
          };
        })(this);
        return reader.readAsArrayBuffer(data.file);
      case 'loadBufferIntoEntity':
        buffer = data.buffer, entity = data.entity;
        if (entity.synth == null) {
          console.log('entity has no synth', entity);
          debugger;
        }
        if (buffer == null) {
          buffer = DEFAULT_BUFFER;
        }
        this.loadBuffer(buffer, entity.synth);
        entity.synth.needsFile = false;
        return this.emitChange();
      case 'didUpdateNearestEntities':
        this.setLevels(data.map(function(arg) {
          var distance, entity, viewDistanceRatio;
          entity = arg.entity, distance = arg.distance, viewDistanceRatio = arg.viewDistanceRatio;
          return {
            synth: entity.synth,
            level: (0.5 - viewDistanceRatio) * 2.0
          };
        }));
        return this.emitChange();
      case 'setSynthParameter':
        synth = data.synth, parameter = data.parameter;
        this.setParameter(parameter.name, parameter.value, synth);
        return this.emitChange();
    }
  };

  Synths.prototype.defaultSynthOptions = function() {
    return {
      voices: 8,
      granular: {
        buffer: null,
        center: 0.5,
        grainDuration: 1000,
        durationRandom: 200,
        deviation: 200,
        fadeRatio: 0.5,
        gain: 0.25,
        detune: 0
      }
    };
  };

  Synths.prototype.loadBuffer = function(buffer, synthData) {
    return synthData.options.granular.buffer = buffer;
  };

  Synths.prototype.setLevels = function(levelsInfo) {
    return this.data.synths = _(levelsInfo).sortBy(function(a, b) {
      return a.level - b.level;
    }).map(function(arg) {
      var level, synth;
      synth = arg.synth, level = arg.level;
      synth.level = level;
      return synth;
    }).value();
  };

  Synths.prototype.setParameter = function(pName, pValue, synth) {
    if (synth.options.granular[pName] != null) {
      return synth.options.granular[pName] = pValue;
    }
  };

  return Synths;

})(Store);

module.exports = new Synths();


},{"../Constants":8,"./Store":16,"./World":19,"lodash":"lodash"}],18:[function(require,module,exports){
var Store, User, WorldStore, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

Store = require('./Store');

WorldStore = require('./World');

User = (function(superClass) {
  extend(User, superClass);

  function User() {
    return User.__super__.constructor.apply(this, arguments);
  }

  User.prototype.getDefaultData = function() {
    return {
      position: null,
      deltaPosition: [0, 0]
    };
  };

  User.prototype.delegate = function(payload) {
    var data, entity, id, ref, ref1, scope, viewport;
    data = payload != null ? (ref = payload.action) != null ? ref.data : void 0 : void 0;
    switch (payload != null ? (ref1 = payload.action) != null ? ref1.actionType : void 0 : void 0) {
      case 'wantsEditEntity':
        id = data.id;
        entity = WorldStore.getEntity(id);
        if (entity != null) {
          return this.dispatch('didBeginEditEntity', {
            entity: entity
          });
        }
        break;
      case 'didViewportTransform':
        viewport = data.viewport;
        this.data.deltaPosition = this.data.position != null ? viewport.center.subtract(this.data.position) : [0, 0];
        this.data.position = viewport.center;
        this.recalculateDistances(viewport.center, viewport.size);
        return this.emitChange();
      case 'didRegisterEntity':
        scope = data.paper.scope;
        viewport = scope.view;
        this.recalculateDistances(viewport.center, viewport.size);
        return this.emitChange();
    }
  };

  User.prototype.recalculateDistances = function(fromPoint, withinBox) {
    var distanceInfo;
    distanceInfo = _(WorldStore.data.entities).values().map(function(entity) {
      var nearestPt;
      nearestPt = entity.paper.path.getNearestPoint(fromPoint);
      return {
        distance: fromPoint.getDistance(nearestPt),
        entity: entity
      };
    }).filter(function(elm) {
      return elm.distance < (withinBox.width / 2);
    }).map(function(elm) {
      return _.assign(elm, {
        viewDistanceRatio: elm.distance / withinBox.width
      });
    }).value();
    return this.dispatch('didUpdateNearestEntities', distanceInfo);
  };

  return User;

})(Store);

module.exports = new User();


},{"./Store":16,"./World":19,"lodash":"lodash"}],19:[function(require,module,exports){
var Paper, Promise, Store, World, _, makeRandomPath,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

Promise = (require('es6-promise')).Promise;

Store = require('./Store');

Paper = require('paper');

makeRandomPath = require('../view/paper/MakeRandomPath');

World = (function(superClass) {
  extend(World, superClass);

  function World() {
    World.__super__.constructor.apply(this, arguments);
    this.entityCount = 0;
    this._fixedEltUpdates = {};
  }

  World.prototype.getDefaultData = function() {
    return {
      entities: {},
      queued: {
        entity: null
      }
    };
  };

  World.prototype.getEntity = function(id) {
    if (id != null) {
      return this.data.entities[id];
    } else {
      return null;
    }
  };

  World.prototype.delegate = function(payload) {
    var data, entity, paper, ref, ref1;
    data = payload != null ? (ref = payload.action) != null ? ref.data : void 0 : void 0;
    switch (payload != null ? (ref1 = payload.action) != null ? ref1.actionType : void 0 : void 0) {
      case 'wantsAddEntity':
        entity = this.makeNewEntity(data.position);
        this.dispatch('wantsRegisterEntity', {
          entity: entity
        });
        if (data.file != null) {
          return this.dispatch('wantsLoadSoundFile', {
            entity: entity,
            file: data.file
          });
        } else {
          return this.dispatch('loadBufferIntoEntity', {
            entity: entity,
            buffer: null
          });
        }
        break;
      case 'wantsRegisterEntity':
        this.data.queued.entity = data.entity;
        return this.emitChange();
      case 'didRegisterEntity':
        entity = data.entity, paper = data.paper;
        this.data.queued.entity = null;
        this.data.entities[entity.id] = entity;
        this.data.entities[entity.id].paper = paper;
        this.dispatch('didAddEntity', {
          entity: entity
        });
        return this.emitChange();
    }
  };

  World.prototype.makeNewEntity = function(position) {
    var entity, id;
    id = "entity-" + (this.entityCount++);
    entity = {
      id: id,
      position: position
    };
    return entity;
  };

  return World;

})(Store);

module.exports = new World();


},{"../view/paper/MakeRandomPath":31,"./Store":16,"es6-promise":3,"lodash":"lodash","paper":7}],20:[function(require,module,exports){
var mixinDispatchable;

module.exports = mixinDispatchable = function(onObj, dispatcher) {
  onObj.dispatch = function(actionType, data) {
    return dispatcher.dispatch({
      action: {
        actionType: actionType,
        data: data
      }
    });
  };
  return onObj;
};


},{}],21:[function(require,module,exports){
var TimeoutManager;

TimeoutManager = (function() {
  function TimeoutManager() {
    this._clearSet = {};
  }

  TimeoutManager.prototype.setTimeout = function(delay, proc) {
    var procAndRemove, timeoutId;
    timeoutId = null;
    procAndRemove = (function(_this) {
      return function() {
        proc();
        return delete _this._clearSet["" + timeoutId];
      };
    })(this);
    timeoutId = setTimeout(procAndRemove, delay);
    return this._clearSet["" + timeoutId] = (function(_this) {
      return function() {
        clearTimeout(timeoutId);
        return delete _this._clearSet["" + timeoutId];
      };
    })(this);
  };

  TimeoutManager.prototype.clearAll = function() {
    var k, ref, v;
    ref = this._clearSet;
    for (k in ref) {
      v = ref[k];
      v();
    }
    return this._clearSet = {};
  };

  return TimeoutManager;

})();

module.exports = TimeoutManager;


},{}],22:[function(require,module,exports){
var mixinDispatchable;

module.exports = mixinDispatchable = function(onObj, dispatcher) {
  onObj.dispatch = function(actionType, data) {
    return dispatcher.dispatch({
      action: {
        actionType: actionType,
        data: data
      }
    });
  };
  return onObj;
};


},{}],23:[function(require,module,exports){
var Application, Dispatchable, EditorStore, InspectorController, Paper, React, UserStore, VolumeControl, WorldController, WorldStore, _, dispatcher, makeRandomPath, randomColor, setupCameraTool;

_ = require('lodash');

React = require('react');

Paper = require('paper');

WorldStore = require('../stores/World');

EditorStore = require('../stores/Editor');

UserStore = require('../stores/User');

InspectorController = require('./InspectorController');

WorldController = require('./WorldController');

VolumeControl = require('./VolumeControl');

makeRandomPath = require('./paper/MakeRandomPath');

setupCameraTool = require('./paper/CameraControl');

Dispatchable = require('../util/Dispatchable');

dispatcher = require('../Dispatcher');

randomColor = require('./paper/RandomColor');

Application = React.createClass({
  displayName: 'Application',
  shadowAmount: [20, 20],
  getInitialState: function() {
    return {
      world: WorldStore.getAll(),
      editor: EditorStore.getAll(),
      user: UserStore.getAll(),
      app: {
        showOverlays: false
      }
    };
  },
  componentDidMount: function() {
    var canvas, inspector;
    Dispatchable(this, dispatcher);
    WorldStore.addChangeListener(this._onChange);
    EditorStore.addChangeListener(this._onChange);
    UserStore.addChangeListener(this._onChange);
    canvas = this.refs.canvas.getDOMNode();
    inspector = this.refs.inspector.getDOMNode();
    this.fieldPaperScope = this.setupField(canvas);
    this.inspectorPaperScope = this.setupInspector(inspector);
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    inspector.style.width = '100%';
    inspector.style.height = '100%';
    this.fieldPaperScope.view.viewSize = [canvas.offsetWidth, canvas.offsetHeight];
    return this.inspectorPaperScope.view.viewSize = [inspector.offsetWidth, inspector.offsetHeight];
  },
  setupField: function(canvasNode) {
    var fieldPaper;
    fieldPaper = new Paper.PaperScope();
    fieldPaper.setup(canvasNode);
    (new WorldController()).attach(fieldPaper);
    return fieldPaper;
  },
  setupInspector: function(canvasNode) {
    var inspectorPaper;
    inspectorPaper = new Paper.PaperScope();
    inspectorPaper.setup(canvasNode);
    (new InspectorController()).attach(inspectorPaper);
    return inspectorPaper;
  },
  handleDragover: function(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    return evt.dataTransfer.dropEffect = 'copy';
  },
  handleDrop: function(evt) {
    var file, pt;
    evt.stopPropagation();
    evt.preventDefault();
    file = evt.dataTransfer.files[0];
    pt = new this.fieldPaperScope.Point(evt.clientX, evt.clientY);
    if (file != null) {
      return this.dispatch('wantsAddEntity', {
        file: file,
        position: this.fieldPaperScope.view.viewToProject(pt)
      });
    }
  },
  render: function() {
    return React.createElement("div", {
      "id": "frame",
      "ref": "frame",
      "onMouseEnter": ((function(_this) {
        return function() {
          return _this.setState({
            app: {
              showOverlays: true
            }
          });
        };
      })(this)),
      "onMouseOut": ((function(_this) {
        return function(evt) {
          return _this.setState({
            app: {
              showOverlays: (evt.relatedTarget != null) && evt.relatedTarget !== _this.refs.canvas.getDOMNode()
            }
          });
        };
      })(this))
    }, React.createElement("div", {
      "id": "container"
    }, React.createElement("div", {
      "id": "mg-overlays"
    }, React.createElement(VolumeControl, {
      "id": "mg-master-volume",
      "className": (this.state.app.showOverlays ? 'visible' : 'hidden'),
      "source": this.props.audioSource
    })), React.createElement("div", {
      "id": "mg-app",
      "className": "mg-app",
      "ref": "container"
    }, React.createElement("canvas", {
      "className": "mg-field",
      "id": "mg-field-canvas",
      "ref": "canvas",
      "style": this.props.style,
      "onDragOver": this.handleDragover,
      "onDrop": this.handleDrop,
      "data-resize": "true"
    }), React.createElement("canvas", {
      "className": "mg-inspector" + (this.state.editor.isActive ? ' visible' : ' hidden'),
      "id": "mg-inspector-canvas",
      "ref": "inspector",
      "style": this.props.style,
      "onDragOver": this.handleDragover,
      "onDrop": this.handleDrop,
      "data-resize": "true"
    }))));
  },
  canvasDimensions: function() {
    return this.refs.container.getDOMNode().getBoundingClientRect();
  },
  _onChange: function() {
    return this.setState({
      world: WorldStore.getAll(),
      editor: EditorStore.getAll(),
      user: UserStore.getAll()
    });
  }
});

module.exports = Application;


},{"../Dispatcher":9,"../stores/Editor":15,"../stores/User":18,"../stores/World":19,"../util/Dispatchable":20,"./InspectorController":24,"./VolumeControl":25,"./WorldController":26,"./paper/CameraControl":29,"./paper/MakeRandomPath":31,"./paper/RandomColor":32,"lodash":"lodash","paper":7,"react":"react"}],24:[function(require,module,exports){
var Dispatchable, EditorStore, InspectorController, RedInspector, _, dispatcher,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_ = require('lodash');

Dispatchable = require('../util/dispatchable');

dispatcher = require('../Dispatcher');

EditorStore = require('../stores/Editor');

RedInspector = require('./inspectors/RedInspector');

InspectorController = (function() {
  function InspectorController() {
    this._onChange = bind(this._onChange, this);
    Dispatchable(this, dispatcher);
    this.activeInspector = null;
  }

  InspectorController.prototype.attach = function(paper) {
    this.setupView(paper);
    EditorStore.addChangeListener(this._onChange);
    return this._onChange();
  };

  InspectorController.prototype.detach = function() {
    return EditorStore.removeChangeListener(this._onChange);
  };

  InspectorController.prototype.update = function(state) {
    if (state.editor.events.wantsEdit) {
      if (state.editor.queuedEntity != null) {
        this.activeInspector = new RedInspector(state.editor.queuedEntity);
        this.showInspector(this._paper, this._inspectorGroup, this.activeInspector);
        this.dispatch('didBeginEditEntity', {
          entity: state.editor.queuedEntity
        });
      } else {
        console.error('wanted edit but no entity queued for edit');
      }
    }
    if (state.editor.events.wantsCancel) {
      this.hideInspector(this._paper, this._inspectorGroup, this.activeInspector);
      return this.dispatch('didCancelEditEntity');
    }
  };

  InspectorController.prototype.setupView = function(paper) {
    this._paper = paper;
    paper.view.element.addEventListener('mouseup', (function(_this) {
      return function(evt) {
        var pt;
        pt = new paper.Point(evt.offsetX, evt.offsetY);
        if ((paper.project.hitTest(pt)) == null) {
          return _this.dispatch('wantsCancelEditEntity');
        }
      };
    })(this));
    this._inspectorGroup = new paper.Group({
      name: 'inspector'
    });
    return paper.view.draw();
  };

  InspectorController.prototype.hideInspector = function(paper, inspectorGroup, inspectorModel) {
    inspectorGroup.visible = false;
    return inspectorModel != null ? inspectorModel.remove() : void 0;
  };

  InspectorController.prototype.showInspector = function(paper, inspectorGroup, inspectorModel) {
    var item;
    this._setupSynthMapping(inspectorModel);
    item = inspectorModel.draw(paper, paper.view.bounds.size.multiply(0.8));
    inspectorGroup.addChild(item);
    inspectorGroup.position = paper.view.center;
    paper.view.draw();
    inspectorGroup.position = paper.view.center;
    return inspectorGroup.visible = true;
  };

  InspectorController.prototype._setupSynthMapping = function(inspectorModel) {
    var dispatchParameterChange, initialScrubberHeight, makeGetFn, makeSetFn, synth;
    synth = inspectorModel.entity.synth;
    dispatchParameterChange = (function(_this) {
      return function(paramName, value) {
        return _this.dispatch('setSynthParameter', {
          synth: synth,
          parameter: {
            name: paramName,
            value: value
          }
        });
      };
    })(this);
    makeGetFn = function(paramName, transform) {
      if (transform == null) {
        transform = _.identity;
      }
      return function() {
        return transform(synth.options.granular[paramName]);
      };
    };
    makeSetFn = function(paramName, transform) {
      if (transform == null) {
        transform = _.identity;
      }
      return function(v) {
        return dispatchParameterChange(paramName, transform(v));
      };
    };
    inspectorModel.mapParameter('scrubberX', makeGetFn('center', function(v) {
      return v * 10;
    }), makeSetFn('center', (function(v) {
      var cooked;
      cooked = ((v / 10) + 2) % 1;
      inspectorModel.setFeedbackParameter('playheadPosition', cooked);
      return cooked;
    })));
    inspectorModel.mapParameter('backgroundX', makeGetFn('grainDuration', function(v) {
      return v / 10;
    }), makeSetFn('grainDuration', function(v) {
      var cooked, max, min, normalized, v_;
      v_ = v * 10;
      min = 100;
      max = 1000;
      cooked = Math.min(max, Math.max(min, v_));
      normalized = (cooked - min) / (max - min);
      inspectorModel.setFeedbackParameter('scrubberHeight', normalized);
      return cooked;
    }));
    inspectorModel.mapParameter('backgroundY', makeGetFn('detune', (function(v) {
      return v / 50;
    })), makeSetFn('detune', (function(v) {
      var cooked, max, min, normalized, ranged;
      cooked = v * 50;
      min = -1200;
      max = 1200;
      ranged = Math.max(min, Math.min(max, cooked));
      normalized = (ranged - min) / (max - min);
      inspectorModel.setFeedbackParameter('hue', normalized / 3);
      inspectorModel.setFeedbackParameter('lightness', normalized);
      console.log(normalized);
      return cooked;
    })));
    initialScrubberHeight = (synth.options.granular.grainDuration - 100) / (1000 - 100);
    return inspectorModel.setFeedbackParameter('scrubberHeight', initialScrubberHeight);
  };

  InspectorController.prototype._fetchState = function() {
    return {
      editor: EditorStore.getAll()
    };
  };

  InspectorController.prototype._onChange = function() {
    this.state = this._fetchState();
    return this.update(this.state);
  };

  return InspectorController;

})();

module.exports = InspectorController;


},{"../Dispatcher":9,"../stores/Editor":15,"../util/dispatchable":22,"./inspectors/RedInspector":28,"lodash":"lodash"}],25:[function(require,module,exports){
var Dispatchable, React, VolumeControl, _, dispatcher;

_ = require('lodash');

React = require('react');

dispatcher = require('../Dispatcher');

Dispatchable = require('../util/Dispatchable');

VolumeControl = React.createClass({
  displayName: 'VolumeControl',
  getInitialState: function() {
    return {
      muted: false
    };
  },
  componentDidMount: function() {
    return Dispatchable(this, dispatcher);
  },
  render: function() {
    return React.createElement("div", {
      "className": this.props.className,
      "id": this.props.id,
      "onClick": ((function(_this) {
        return function() {
          _this.dispatch('didMasterChangeMute', {
            isMuted: !_this.state.muted
          });
          return _this.setState({
            muted: !_this.state.muted
          });
        };
      })(this))
    }, React.createElement("span", null, "click to ", (this.state.muted ? 'unmute' : 'mute')));
  }
});

module.exports = VolumeControl;


},{"../Dispatcher":9,"../util/Dispatchable":20,"lodash":"lodash","react":"react"}],26:[function(require,module,exports){
var Dispatchable, InfiniteTiledItem, UserStore, WorldController, WorldStore, _, dispatcher, makeRandomPath, makeTiledItem, randomColor, setupCameraTool,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_ = require('lodash');

Dispatchable = require('../util/dispatchable');

dispatcher = require('../Dispatcher');

WorldStore = require('../stores/World');

UserStore = require('../stores/User');

setupCameraTool = require('./paper/CameraControl');

makeTiledItem = require('./paper/TiledItem');

InfiniteTiledItem = require('./paper/InfiniteTiledItem');

makeRandomPath = require('./paper/MakeRandomPath');

randomColor = require('./paper/RandomColor');

WorldController = (function() {
  function WorldController() {
    this._onChange = bind(this._onChange, this);
    Dispatchable(this, dispatcher);
    this._onViewportTransform = [];
  }

  WorldController.prototype.attach = function(paper) {
    this.setupView(paper);
    WorldStore.addChangeListener(this._onChange);
    UserStore.addChangeListener(this._onChange);
    return this._onChange();
  };

  WorldController.prototype.detach = function() {
    WorldStore.removeChangeListener(this._onChange);
    return UserStore.removeChangeListener(this._onChange);
  };

  WorldController.prototype.update = function(state) {
    var graphic, newOrigin, parallaxFactor, ref, ref1;
    if (state.world.queued.entity != null) {
      graphic = this._makeEntityGraphic(this.paper, state.world.queued.entity);
      this.dispatch('didRegisterEntity', {
        paper: {
          scope: this.paper,
          path: graphic.path,
          shadow: graphic.shadow
        },
        entity: state.world.queued.entity
      });
    }
    if (state.user.position != null) {
      parallaxFactor = 2;
      newOrigin = (new this.paper.Point(state.user.position)).multiply(1 / parallaxFactor);
      if ((ref = this._backgroundGroup.children['tiledBg']) != null) {
        ref.setOrigin(newOrigin);
      }
      if ((ref1 = this._backgroundGroup.children['tiledNoise']) != null) {
        ref1.setOrigin(newOrigin);
      }
      return this._onViewportTransform.forEach(function(cb) {
        return cb();
      });
    }
  };

  WorldController.prototype.setupView = function(paper) {
    var scope, tool;
    this.paper = paper;
    this._shadowGroup = new paper.Group({
      name: 'shadows'
    });
    this._entityGroup = new paper.Group({
      name: 'entities'
    });
    this._backgroundGroup = this._makeBackground(paper, paper.view.center.multiply(0.5));
    this._worldGroup = new paper.Group({
      name: 'world',
      children: [this._backgroundGroup, this._shadowGroup, this._entityGroup]
    });
    tool = new paper.Tool();
    this._setupAddEntityTool(tool, paper);
    this._setupSelectionTool(tool, paper);
    scope = this;
    setupCameraTool(paper, tool, paper.view.element, {
      onTransform: function() {
        return scope.dispatch('didViewportTransform', {
          viewport: paper.view
        });
      }
    });
    this.dispatch('didViewportTransform', {
      viewport: paper.view
    });
    return this.dispatch('setupInspector', {
      paper: paper
    });
  };

  WorldController.prototype._fetchState = function() {
    return {
      world: WorldStore.getAll(),
      user: UserStore.getAll()
    };
  };

  WorldController.prototype._onChange = function() {
    this.state = this._fetchState();
    return this.update(this.state);
  };


  /* DRAWING */

  WorldController.prototype._makeEntityGraphic = function(paper, entity) {
    var data, path, shadow;
    path = this._makePaperEntity(paper, entity.id, entity.position);
    shadow = this._makeShadow(paper, path);
    data = {
      entityId: entity.id
    };
    path.data = shadow.data = data;
    path.name = shadow.name = entity.id;
    this._entityGroup.addChild(path);
    this._shadowGroup.addChild(shadow);
    return {
      path: path,
      shadow: shadow
    };
  };

  WorldController.prototype._makePaperEntity = function(paper, id, position) {
    var item;
    if (position == null) {
      position = paper.view.center;
    }
    item = makeRandomPath(paper, {
      left: 0,
      top: 0,
      width: Math.random() * 450 + 50,
      height: Math.random() * 450 + 50
    });
    item.position = position;
    item.fillColor = {
      gradient: {
        stops: [
          randomColor({
            brightness: 0.8
          }), randomColor({
            brightness: 0.8
          })
        ]
      },
      origin: item.bounds.topLeft,
      destination: item.bounds.bottomRight
    };
    return item;
  };

  WorldController.prototype._makeShadow = function(paper, path) {
    var r;
    r = path.clone();
    r.fillColor = 'black';
    r.opacity = 0.6;
    r.translate([30, 30]);
    return r;
  };

  WorldController.prototype._makeBackground = function(paper, initialPosition) {
    var backgroundGroup, backgroundShapes, blobProto, cloneGroup, noise, outerColor, rasterUrl, tiledBg, updateTN;
    backgroundGroup = new paper.Group({
      name: 'background',
      position: initialPosition
    });
    backgroundGroup.sendToBack();
    blobProto = this._makeBackgroundBlob(paper, [0, 0]);
    backgroundGroup.addChild(blobProto);
    outerColor = new paper.Color(0, 0);
    backgroundShapes = [-1, 0, 1].map(function(x) {
      return [-1, 0, 1].map(function(y) {
        return new paper.Point(x, y);
      });
    }).reduce(function(acc, elm) {
      return acc.concat(elm);
    }).map((function(_this) {
      return function(coordinate) {
        var clone, hues, innerColor;
        clone = blobProto.clone();
        clone.position = coordinate.multiply([800, 800]);
        clone.position = clone.position.add([Math.random() * 400, Math.random() * 400]);
        hues = [5, 187];
        innerColor = new paper.Color({
          hue: hues[Math.floor(Math.random() * hues.length)],
          saturation: 0.3,
          brightness: 0.4
        });
        outerColor = randomColor({
          saturation: 0.3,
          brightness: 0.3
        });
        outerColor.alpha = 0;
        clone.fillColor = {
          gradient: {
            stops: [innerColor, outerColor],
            radial: true
          },
          origin: clone.bounds.center,
          destination: clone.bounds.rightCenter
        };
        return clone;
      };
    })(this));
    cloneGroup = new paper.Group(backgroundShapes);
    tiledBg = new InfiniteTiledItem(paper, cloneGroup, {
      overlap: new paper.Point(-0.5, -0.5)
    });
    tiledBg.name = 'tiledBg';
    backgroundGroup.addChild(tiledBg);
    updateTN = function() {
      return tiledBg.setViewBounds(paper.view.bounds);
    };
    this._onViewportTransform.push(updateTN);
    updateTN();
    rasterUrl = 'http://www.neilblevins.com/cg_education/procedural_noise/perlin_fractal_max.jpg';
    noise = new paper.Raster(rasterUrl);
    noise.opacity = 0.2;
    noise.blendMode = 'multiply';
    noise.onLoad = (function(_this) {
      return function() {
        var tiledNoise;
        tiledNoise = new InfiniteTiledItem(paper, noise);
        tiledNoise.name = 'tiledNoise';
        backgroundGroup.addChild(tiledNoise);
        updateTN = function() {
          return tiledNoise.setViewBounds(paper.view.bounds);
        };
        _this._onViewportTransform.push(updateTN);
        return updateTN();
      };
    })(this);
    return backgroundGroup;
  };

  WorldController.prototype._makeBackgroundBlob = function(paper, position) {
    var outerColor, r, size;
    size = 1000;
    outerColor = new paper.Color(0, 0);
    position = (new paper.Point(Math.random(), Math.random())).add(position);
    r = new paper.Path.Circle({
      center: position.multiply(size / 2),
      radius: size
    });
    r.fillColor = {
      gradient: {
        stops: [
          randomColor({
            saturation: 0.5,
            brightness: 0.6
          }), outerColor
        ],
        radial: true
      },
      origin: r.bounds.center,
      destination: r.bounds.rightCenter
    };
    r.blendMode = 'normal';
    return r;
  };


  /* TOOLS */

  WorldController.prototype._setupAddEntityTool = function(tool, paper) {
    return tool.on('mousedown', (function(_this) {
      return function(evt) {
        if (paper.Key.isDown('shift')) {
          return _this.dispatch('wantsAddEntity', {
            position: evt.downPoint
          });
        }
      };
    })(this));
  };

  WorldController.prototype._setupSelectionTool = function(tool, paper) {
    var hitOptions, lastHit;
    hitOptions = {
      segments: true,
      stroke: true,
      fill: true,
      tolerance: 5
    };
    lastHit = null;
    tool.onMouseMove = (function(_this) {
      return function(evt) {
        var hit, hitResults;
        hitResults = _this._entityGroup.hitTest(evt.point, hitOptions);
        hit = hitResults != null ? hitResults.item.data.entityId : null;
        if (hit !== lastHit) {
          if (lastHit != null) {
            _this._handleMouseHoverEntity(lastHit, 'exit');
          }
          if (hit != null) {
            _this._handleMouseHoverEntity(hit, 'enter');
          }
        }
        _this._handleMouseHoverEntity(hit, 'over');
        return lastHit = hit;
      };
    })(this);
    tool.on('mouseup', (function(_this) {
      return function(evt) {
        if (lastHit != null) {
          _this.dispatch('wantsEditEntity', {
            id: lastHit
          });
          return _this._handleMouseHoverEntity(lastHit, 'up');
        }
      };
    })(this));
    return tool.on('mousedown', (function(_this) {
      return function(evt) {
        if ((lastHit == null) && (!paper.Key.isDown('shift'))) {
          return _this.dispatch('wantsCancelEditEntity');
        }
      };
    })(this));
  };

  WorldController.prototype._handleMouseHoverEntity = (function() {
    var reset;
    reset = null;
    return function(entityId, state) {
      var entity, oldColor, oldWidth, setStrokeWidth;
      entity = {
        path: this._entityGroup.children[entityId],
        shadow: this._entityGroup.children[entityId]
      };
      switch (state) {
        case 'enter':
          if (reset != null) {
            reset();
          }
          setStrokeWidth = (function(_this) {
            return function() {
              return entity.path.strokeWidth = 3 * 1 / _this.paper.view.zoom;
            };
          })(this);
          oldColor = entity.path.strokeColor;
          oldWidth = entity.path.strokeWidth;
          reset = (function(_this) {
            return function() {
              entity.path.strokeColor = oldColor;
              return entity.path.strokeWidth = oldWidth;
            };
          })(this);
          entity.path.strokeColor = '#4181FF';
          return setStrokeWidth();
        case 'exit':
          if (reset != null) {
            return reset();
          }
          break;
        case 'up':
          if (reset != null) {
            return reset();
          }
      }
    };
  })();

  return WorldController;

})();

module.exports = WorldController;


},{"../Dispatcher":9,"../stores/User":18,"../stores/World":19,"../util/dispatchable":22,"./paper/CameraControl":29,"./paper/InfiniteTiledItem":30,"./paper/MakeRandomPath":31,"./paper/RandomColor":32,"./paper/TiledItem":33,"lodash":"lodash"}],27:[function(require,module,exports){
var EventEmitter, InspectorBase, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventEmitter = require('events').EventEmitter;

_ = require('lodash');


/*
Abstract class for inspectors.
 */

InspectorBase = (function(superClass) {
  extend(InspectorBase, superClass);

  function InspectorBase(parameterCallbacks) {
    if (parameterCallbacks == null) {
      parameterCallbacks = {};
    }
    this._parameterCallbacks = parameterCallbacks;
    this._feedbackParameters = _.mapValues(this.defaultFeedbackValues(), function(value, key) {
      return {
        callbacks: [],
        value: value
      };
    });
  }

  InspectorBase.prototype.draw = function(paper, size) {};

  InspectorBase.prototype.remove = function() {};

  InspectorBase.prototype.parameterList = function() {
    return console.warn('Inspector needs to override `parameterList()`.');
  };

  InspectorBase.prototype.mapParameter = function(paramName, getFn, setFn) {
    return this._parameterCallbacks[paramName] = {
      getFn: getFn,
      setFn: setFn
    };
  };

  InspectorBase.prototype.getParameter = function(paramName) {
    var callbacks;
    callbacks = this._parameterCallbacks[paramName];
    if ((callbacks != null ? callbacks.getFn : void 0) != null) {
      return callbacks.getFn();
    } else {
      return void 0;
    }
  };

  InspectorBase.prototype.setParameter = function(paramName, value) {
    var callbacks;
    callbacks = this._parameterCallbacks[paramName];
    if ((callbacks != null ? callbacks.setFn : void 0) != null) {
      callbacks.setFn(value);
      return this.emit(paramName + "Changed", value);
    } else {
      return void 0;
    }
  };

  InspectorBase.prototype.addParameterListener = function(paramName, callback) {
    return this.on(paramName + "Changed", callback);
  };

  InspectorBase.prototype.removeParameterListener = function(paramName, callback) {
    return this.removeListener(paramName + "Changed", callback);
  };

  InspectorBase.prototype.defaultFeedbackValues = function() {
    console.warn('Inspector needs to override `defaultFeedbackValues()`.');
    return {};
  };

  InspectorBase.prototype.refreshFeedbackParameters = function() {
    return Object.keys(this._feedbackParameters).forEach((function(_this) {
      return function(paramName) {
        return _this.setFeedbackParameter(paramName, _this._feedbackParameters[paramName].value);
      };
    })(this));
  };

  InspectorBase.prototype.setFeedbackParameter = function(paramName, value) {
    var delta;
    delta = value - this._feedbackParameters[paramName].value;
    this._feedbackParameters[paramName].value = value;
    return this.emit(paramName + "ChangedFeedback", value, delta);
  };

  InspectorBase.prototype.getFeedbackParameter = function(paramName) {
    return this._feedbackParameters[paramName].value;
  };

  InspectorBase.prototype._addFeedbackListener = function(paramName, callback, afterInteractionCallback) {
    var afterInteractionCallbackId;
    afterInteractionCallbackId = null;
    this.on(paramName + "ChangedFeedback", function() {
      var args;
      args = arguments;
      if (afterInteractionCallback != null) {
        if (afterInteractionCallbackId != null) {
          clearTimeout(afterInteractionCallbackId);
          afterInteractionCallbackId = null;
        }
        afterInteractionCallbackId = setTimeout((function() {
          return afterInteractionCallback.apply(null, args);
        }), 100);
      }
      return callback.apply(null, args);
    });
    return this._feedbackParameters[paramName].callbacks.push(callback);
  };

  InspectorBase.prototype._removeFeedbackListener = function(paramName, callback) {
    return this.removeListener(paramName + "ChangedFeedback", callback);
  };

  InspectorBase.prototype._removeAllFeedbackListeners = function() {
    return (Object.keys(this._feedbackParameters)).forEach((function(_this) {
      return function(paramName) {
        return _this._feedbackParameters[paramName].callbacks.forEach(function(callback) {
          return _this._removeFeedbackListener(paramName, callback);
        });
      };
    })(this));
  };

  return InspectorBase;

})(EventEmitter);

module.exports = InspectorBase;


},{"events":1,"lodash":"lodash"}],28:[function(require,module,exports){
var InspectorBase, RedInspector,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

InspectorBase = require('./InspectorBase');

RedInspector = (function(superClass) {
  extend(RedInspector, superClass);

  function RedInspector(entity1, parameterCallbacks) {
    this.entity = entity1;
    this._onMousewheel = bind(this._onMousewheel, this);
    RedInspector.__super__.constructor.call(this, parameterCallbacks);
    this._gfxInstances = [];
  }

  RedInspector.prototype.parameterList = function() {
    return ['backgroundX', 'backgroundY', 'scrubberX', 'scrubberY'];
  };

  RedInspector.prototype.feedbackParameterList = function() {
    return ['scrubberHeight'];
  };

  RedInspector.prototype.draw = function(paper, size) {
    var bounds, prettySize, ratio, result, topLeft;
    ratio = 1.77;
    prettySize = new paper.Size(size.width, size.height / ratio);
    if (prettySize.height > size.height) {
      prettySize = new paper.Size(size.height * ratio, size.height);
    }
    topLeft = (new paper.Point(prettySize)).negate().multiply(0.5);
    bounds = new paper.Rectangle(topLeft, prettySize);
    result = new paper.Group({
      children: [this._createBackground(paper, bounds, this.entity), this._createScrubber(paper, bounds, this.entity), this._createEntity(paper, bounds, this.entity)]
    });
    this._setupInteraction(paper, result);
    this._gfxInstances.push(result);
    this.refreshFeedbackParameters();
    return result;
  };

  RedInspector.prototype.remove = function() {
    this._gfxInstances.forEach(function(inst) {
      return inst.remove();
    });
    this._gfxInstances = [];
    this._destroyInteraction();
    return this._removeAllFeedbackListeners();
  };

  RedInspector.prototype.defaultFeedbackValues = function() {
    return {
      'scrubberHeight': 0.2,
      'playheadPosition': 0.5,
      'itemAgitation': 0.5,
      'hue': 0,
      'lightness': 0.62
    };
  };

  RedInspector.prototype._createBackground = function(paper, bounds, entity) {
    var rect;
    rect = new paper.Path.Rectangle({
      name: 'redInspectorBG',
      size: bounds.size,
      fillColor: new paper.Color({
        hue: this.getFeedbackParameter('hue'),
        saturation: 0.81,
        lightness: this.getFeedbackParameter('lightness')
      })
    });
    rect.position = [0, 0];
    rect.data.onMousewheel = (function(_this) {
      return function(evt) {
        var nudgeAmountX, nudgeAmountY, oldValueX, oldValueY;
        evt.stopPropagation();
        evt.preventDefault();
        nudgeAmountX = -evt.deltaX / 100;
        oldValueX = _this.getParameter('backgroundX');
        _this.setParameter('backgroundX', oldValueX + nudgeAmountX);
        nudgeAmountY = evt.deltaY / 100;
        oldValueY = _this.getParameter('backgroundY');
        return _this.setParameter('backgroundY', oldValueY + nudgeAmountY);
      };
    })(this);
    rect.on('frame', (function(_this) {
      return function() {
        rect.fillColor.hue = (_this.getFeedbackParameter('hue')) * 360;
        rect.fillColor.lightness = _this.getFeedbackParameter('lightness');
        return paper.view.draw();
      };
    })(this));
    return rect;
  };

  RedInspector.prototype._createScrubber = function(paper, bounds, entity) {
    var afterPlayheadPosition, delta, initialHeight, onPlayheadPosition, playhead, scrubber, scrubberGroup;
    scrubberGroup = new paper.Group();
    scrubber = new paper.Path.Rectangle({
      point: bounds.topLeft,
      size: [bounds.width, bounds.height]
    });
    scrubberGroup.addChild(scrubber);
    scrubber.fillColor = 'black';
    scrubber.opacity = 0.2;
    scrubber.name = 'scrubber';
    playhead = new paper.Path.Rectangle({
      point: scrubber.bounds.topLeft,
      size: [1, scrubber.bounds.height],
      fillColor: 'white',
      name: 'playhead',
      opacity: 0
    });
    scrubberGroup.addChild(playhead);
    initialHeight = scrubber.bounds.size.height * 0.8;
    this._addFeedbackListener('scrubberHeight', function(val, delta) {
      var cooked, distanceToBottom, scaleRatio, targetHeight;
      cooked = val * 0.8 + 0.2;
      targetHeight = cooked * initialHeight;
      scaleRatio = targetHeight / scrubber.bounds.size.height;
      scrubber.scale(1, scaleRatio);
      paper.view.draw();
      distanceToBottom = scrubber.parent.parent.bounds.bottom - scrubber.bounds.bottom;
      scrubber.translate([0, distanceToBottom]);
      return paper.view.draw();
    });
    onPlayheadPosition = function(val, delta) {
      playhead.position.x = scrubber.bounds.left + val * scrubber.bounds.width;
      playhead.opacity = 0.2;
      return paper.view.draw();
    };
    afterPlayheadPosition = function(val) {
      playhead.opacity = 0;
      paper.view.element.style.cursor = 'default';
      return paper.view.draw();
    };
    this._addFeedbackListener('playheadPosition', onPlayheadPosition, afterPlayheadPosition);
    delta = new paper.Point(0, 0);
    scrubber.on('frame', function() {
      var range;
      scrubber.translate(delta.negate());
      range = 2;
      delta = new paper.Point(Math.random() * range - (range / 2), Math.random() * range - (range / 2));
      return scrubber.translate(delta);
    });
    scrubber.data.onMousewheel = (function(_this) {
      return function(evt) {
        var nudgeAmountX, nudgeAmountY, oldValueX, oldValueY;
        evt.stopPropagation();
        evt.preventDefault();
        nudgeAmountX = -evt.deltaX / 100;
        oldValueX = _this.getParameter('scrubberX');
        _this.setParameter('scrubberX', oldValueX + nudgeAmountX);
        nudgeAmountY = evt.deltaY / 100;
        oldValueY = _this.getParameter('scrubberY');
        return _this.setParameter('scrubberY', oldValueY + nudgeAmountY);
      };
    })(this);
    return scrubberGroup;
  };

  RedInspector.prototype._createEntity = function(paper, bounds, entity) {
    var copy, delta, original, originalShadow, result, shadowCopy;
    result = new paper.Group();
    original = entity.paper.path;
    originalShadow = entity.paper.shadow;
    copy = entity.paper.path.clone();
    copy.strokeColor = null;
    shadowCopy = entity.paper.shadow.clone();
    delta = copy.position.negate();
    copy.translate(delta);
    shadowCopy.translate(delta);
    result.addChild(shadowCopy);
    result.addChild(copy);
    return result;
  };

  RedInspector.prototype._setupInteraction = function(paper, group) {
    var onMousewheel;
    onMousewheel = this._onMousewheel(paper, group);
    paper.view.element.addEventListener('mousewheel', onMousewheel);
    return this._destroyInteraction = function() {
      return paper.view.element.removeEventListener('mousewheel', onMousewheel);
    };
  };

  RedInspector.prototype._onMousewheel = function(paper, group) {
    return (function(_this) {
      return function(evt) {
        var hitResults, pt;
        pt = paper.view.viewToProject([evt.offsetX, evt.offsetY]);
        hitResults = group.hitTest(pt);
        if (hitResults != null) {
          if (hitResults.item.data.onMousewheel != null) {
            return hitResults.item.data.onMousewheel(evt);
          }
        }
      };
    })(this);
  };

  return RedInspector;

})(InspectorBase);

module.exports = RedInspector;


},{"./InspectorBase":27}],29:[function(require,module,exports){
var _, cameraControlTool, kLeftMouseFlag, setupPan, setupZoom;

_ = require('lodash');


/*
This is currently more complex than it needs to be, since I mixed together
camera control for operating on groups and the master viewport into the same
functions...

Camera control on groups didn't work out as planned (problem with adding
children after transform), so we no longer need that part of the code. I'll
get rid of it sometime.
 */

kLeftMouseFlag = 1;

module.exports = cameraControlTool = function(paper, tool, canvas, options) {
  options = _.defaults(options, {
    onTransform: _.identity,
    viewItem: paper.view
  });
  setupZoom(paper, tool, canvas, options);
  return setupPan(paper, tool, canvas, options);
};

setupZoom = function(paper, tool, canvas, options) {
  var lastX, zoom;
  zoom = function(amount, pt) {
    var getZoom, newZoom, setZoom;
    getZoom = options.viewItem.zoom != null ? function() {
      return options.viewItem.zoom;
    } : function() {
      return options.viewItem.scaling.x;
    };
    setZoom = options.viewItem.zoom != null ? function(amt, center) {
      var scrollAmount, zoomDelta;
      scrollAmount = options.viewItem.center.subtract(center);
      options.viewItem.scrollBy(scrollAmount);
      zoomDelta = amt / options.viewItem.zoom;
      options.viewItem.zoom = amt;
      return options.viewItem.scrollBy(scrollAmount.negate().multiply(zoomDelta));
    } : function(amt, center) {
      return options.viewItem.scale([1 / amt, 1 / amt], center);
    };
    newZoom = getZoom() * amount;
    newZoom = Math.max(Math.min(newZoom, 5), 0.5);
    if (newZoom !== getZoom()) {
      setZoom(newZoom, pt);
      return options.onTransform();
    }
  };
  canvas.addEventListener('mousewheel', function(evt) {
    var delta, mouseOffset, projMouseOffset;
    evt.stopPropagation();
    evt.preventDefault();
    if (!paper.Key.isDown('option')) {
      mouseOffset = new paper.Point(evt.offsetX, evt.offsetY);
      projMouseOffset = paper.view.viewToProject(mouseOffset);
      delta = -evt.deltaY / 100.0;
      delta *= 0.8;
      return zoom(1 + delta, projMouseOffset);
    }
  });
  lastX = null;
  canvas.addEventListener('mousedown', function(evt) {
    return lastX = evt.clientX;
  });
  return canvas.addEventListener('mousemove', function(evt) {
    var deltaX, mouseButtonDown, mouseOffset, projMouseOffset;
    mouseButtonDown = (evt.buttons & kLeftMouseFlag) === 1;
    if (mouseButtonDown && paper.Key.isDown('option')) {
      mouseOffset = new paper.Point(evt.offsetX, evt.offsetY);
      projMouseOffset = paper.view.viewToProject(mouseOffset);
      deltaX = evt.clientX - lastX;
      lastX = evt.clientX;
      return zoom(1 + 2 * deltaX / paper.view.viewSize.width, paper.view.center);
    }
  });
};

setupPan = function(paper, tool, canvas, options) {
  var decay, getCenter, lastPoint, lastScroll, panInertia, setCenter;
  panInertia = new paper.Point(0, 0);
  lastScroll = new paper.Point(0, 0);
  lastPoint = null;
  canvas.addEventListener('mousedown', function(evt) {
    return lastPoint = new paper.Point(evt.offsetX, evt.offsetY);
  });
  canvas.addEventListener('mousemove', function(evt) {
    var mouseButtonDown, pt, viewDelta;
    mouseButtonDown = (evt.buttons & kLeftMouseFlag) === 1;
    if (mouseButtonDown && !paper.Key.isDown('option')) {
      pt = new paper.Point(evt.offsetX, evt.offsetY);
      viewDelta = lastPoint.subtract(pt);
      panInertia = viewDelta.multiply(1 / paper.view.zoom);
      return lastPoint = pt;
    }
  });
  tool.on('mousedown', function(evt) {
    return panInertia = new paper.Point(0, 0);
  });
  window.addEventListener('focus', function() {
    return panInertia = new paper.Point(0, 0);
  });
  canvas.addEventListener('mousewheel', function(evt) {
    var delta;
    evt.stopPropagation();
    evt.preventDefault();
    if (paper.Key.isDown('option')) {
      delta = new paper.Point(evt.deltaX, evt.deltaY);
      delta = delta.multiply(1 / paper.view.zoom);
      return panInertia = delta;
    }
  });
  decay = 0.8;
  setCenter = options.viewItem.center != null ? function(pt) {
    return options.viewItem.center = pt;
  } : function(pt) {
    var delta;
    delta = options.viewItem.position.subtract(pt);
    return options.viewItem.position = delta.add(options.viewItem.position);
  };
  getCenter = options.viewItem.center != null ? function() {
    return options.viewItem.center;
  } : function() {
    return options.viewItem.position;
  };
  return paper.view.on('frame', function(evt) {
    var delta;
    if (panInertia.length > 0.01) {
      setCenter(getCenter().add(panInertia));
      if (!paper.Key.isDown('option')) {
        delta = (panInertia.multiply(decay)).subtract(panInertia);
        delta.multiply(evt.delta);
        panInertia = panInertia.add(delta);
      }
      return options.onTransform();
    }
  });
};


},{"lodash":"lodash"}],30:[function(require,module,exports){
var InfiniteTiledItem, Paper, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

Paper = require('paper');

InfiniteTiledItem = (function(superClass) {
  extend(InfiniteTiledItem, superClass);

  function InfiniteTiledItem(paper, baseItem, options) {
    this.paper = paper;
    if (options == null) {
      options = {};
    }
    InfiniteTiledItem.__super__.constructor.call(this, []);
    this._options = _.defaults(options, {
      viewBounds: this.paper.view.bounds,
      origin: new this.paper.Point(0, 0),
      overlap: new this.paper.Point(0, 0)
    });
    this._symbol = new this.paper.Symbol(baseItem);
  }

  InfiniteTiledItem.prototype.setOrigin = function(pt) {
    this._options.origin = pt;
    return this._updateInstances();
  };

  InfiniteTiledItem.prototype.setViewBounds = function(newBounds) {
    this._options.viewBounds = newBounds;
    return this._updateInstances();
  };

  InfiniteTiledItem.prototype._updateInstances = function() {
    var dimWithOverlap, i, position, ref, ref1, results, symbolSize, tileRangeX, tileRangeY, x, y;
    this.removeChildren();
    symbolSize = this._symbol.definition.bounds.size;
    dimWithOverlap = {
      width: symbolSize.width * (1 + this._options.overlap.x),
      height: symbolSize.height * (1 + this._options.overlap.y)
    };
    tileRangeX = {
      left: Math.floor((this._options.viewBounds.left - this._options.origin.x) / dimWithOverlap.width),
      right: Math.ceil((this._options.viewBounds.right - this._options.origin.x) / dimWithOverlap.width)
    };
    tileRangeY = {
      top: Math.floor((this._options.viewBounds.top - this._options.origin.y) / dimWithOverlap.height),
      bottom: Math.ceil((this._options.viewBounds.bottom - this._options.origin.y) / dimWithOverlap.height)
    };
    results = [];
    for (x = i = ref = tileRangeX.left, ref1 = tileRangeX.right; ref <= ref1 ? i <= ref1 : i >= ref1; x = ref <= ref1 ? ++i : --i) {
      results.push((function() {
        var j, ref2, ref3, results1;
        results1 = [];
        for (y = j = ref2 = tileRangeY.top, ref3 = tileRangeY.bottom; ref2 <= ref3 ? j <= ref3 : j >= ref3; y = ref2 <= ref3 ? ++j : --j) {
          position = new this.paper.Point(x * dimWithOverlap.width + this._options.origin.x, y * dimWithOverlap.height + this._options.origin.y);
          results1.push(this.addChild(this._symbol.place(position, true)));
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  return InfiniteTiledItem;

})(Paper.Group);

module.exports = InfiniteTiledItem;


},{"lodash":"lodash","paper":7}],31:[function(require,module,exports){
var _, makeRandomPath;

_ = require('lodash');

makeRandomPath = function(paper, bounds, maxSegments) {
  var curves, i, results, segments;
  if (bounds == null) {
    bounds = {};
  }
  if (maxSegments == null) {
    maxSegments = 5;
  }
  bounds = _.defaults(bounds, {
    left: 0,
    top: 0,
    width: 100,
    height: 100
  });
  segments = (function() {
    results = [];
    for (var i = 0; 0 <= maxSegments ? i < maxSegments : i > maxSegments; 0 <= maxSegments ? i++ : i--){ results.push(i); }
    return results;
  }).apply(this).map(function(idx) {
    return [Math.random() * bounds.width + bounds.left, Math.random() * bounds.height + bounds.top];
  }).map(function(anchor, idx, array) {
    var l, next, p2n, previous, smoothFactor;
    l = array.length;
    previous = array[(idx + l - 1) % l];
    next = array[(l + 1) % l];
    p2n = new paper.Point(next[0] - previous[0], next[1] - previous[1]);
    smoothFactor = Math.random();
    return new paper.Segment({
      point: anchor,
      handleIn: p2n.multiply(smoothFactor),
      handleOut: p2n.multiply(-smoothFactor)
    });
  });
  curves = segments.map(function(segment, idx, array) {
    if (idx === (array.length - 1)) {

    } else {
      return new paper.Curve(segment, array[idx + 1]);
    }
  });
  return new paper.Path({
    segments: segments,
    curves: curves,
    closed: true
  });
};

module.exports = makeRandomPath;


},{"lodash":"lodash"}],32:[function(require,module,exports){
var Paper, _, randomColor;

Paper = require('paper');

_ = require('lodash');

module.exports = randomColor = function(options, paper) {
  if (options == null) {
    options = {};
  }
  if (paper == null) {
    paper = Paper;
  }
  options = _.defaults(options, {
    hue: Math.random() * 360,
    saturation: Math.random(),
    brightness: Math.random()
  });
  return new paper.Color(options);
};


},{"lodash":"lodash","paper":7}],33:[function(require,module,exports){
var _, makeTiledItem;

_ = require('lodash');

module.exports = makeTiledItem = function(paper, baseItem, options) {
  var i, instance, j, offset, ref, ref1, symbol, x, y;
  if (options == null) {
    options = {};
  }
  options = _.defaults(options, {
    position: baseItem.position,
    widthInTiles: 5,
    heightInTiles: 5,
    removeOriginal: false,
    onInstance: _.identity,
    group: new paper.Group()
  });
  if (options.random == null) {
    options.random = {};
  }
  options.random = _.defaults(options.random, {
    x: 0,
    y: 0
  });
  symbol = new paper.Symbol(baseItem);
  if (options.removeOriginal) {
    baseItem.remove();
  }
  for (x = i = 0, ref = options.widthInTiles; 0 <= ref ? i < ref : i > ref; x = 0 <= ref ? ++i : --i) {
    for (y = j = 0, ref1 = options.heightInTiles; 0 <= ref1 ? j < ref1 : j > ref1; y = 0 <= ref1 ? ++j : --j) {
      instance = symbol.place();
      offset = new paper.Point(symbol.definition.bounds.width * x, symbol.definition.bounds.height * y);
      offset = offset.add([Math.random() * (options.random.x * 2) - options.random.x, Math.random() * (options.random.y * 2) - options.random.y]);
      instance.position = options.position.add(offset);
      instance = options.onInstance(instance);
      options.group.addChild(instance);
    }
  }
  return options.group;
};


},{"lodash":"lodash"}]},{},[14])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3Qub2JzZXJ2ZS9kaXN0L29iamVjdC1vYnNlcnZlLmpzIiwibm9kZV9tb2R1bGVzL29vLWV2ZW50dGFyZ2V0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29vLWV2ZW50dGFyZ2V0L2xpYi8kRXZlbnRUYXJnZXQuanMiLCJub2RlX21vZHVsZXMvcGFwZXIvZGlzdC9wYXBlci1mdWxsLmpzIiwiL1VzZXJzL2RhdmlkL0RvY3VtZW50cy9Xb3JrL21yYmwvc3JjL0NvbnN0YW50cy5jb2ZmZWUiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvbXJibC9zcmMvRGlzcGF0Y2hlci5jb2ZmZWUiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvbXJibC9zcmMvYXVkaW8vU3ludGhQb29sLmNvZmZlZSIsIi9Vc2Vycy9kYXZpZC9Eb2N1bWVudHMvV29yay9tcmJsL3NyYy9hdWRpby9lbnZlbG9wZS5jb2ZmZWUiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvbXJibC9zcmMvYXVkaW8vZ3JhbnVsYXIuY29mZmVlIiwiL1VzZXJzL2RhdmlkL0RvY3VtZW50cy9Xb3JrL21yYmwvc3JjL2F1ZGlvL3NhbXBsZXIuY29mZmVlIiwiL1VzZXJzL2RhdmlkL0RvY3VtZW50cy9Xb3JrL21yYmwvc3JjL21yYmwuY29mZmVlIiwiL1VzZXJzL2RhdmlkL0RvY3VtZW50cy9Xb3JrL21yYmwvc3JjL3N0b3Jlcy9FZGl0b3IuY29mZmVlIiwiL1VzZXJzL2RhdmlkL0RvY3VtZW50cy9Xb3JrL21yYmwvc3JjL3N0b3Jlcy9TdG9yZS5jb2ZmZWUiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvbXJibC9zcmMvc3RvcmVzL1N5bnRocy5jb2ZmZWUiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvbXJibC9zcmMvc3RvcmVzL1VzZXIuY29mZmVlIiwiL1VzZXJzL2RhdmlkL0RvY3VtZW50cy9Xb3JrL21yYmwvc3JjL3N0b3Jlcy9Xb3JsZC5jb2ZmZWUiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvbXJibC9zcmMvdXRpbC9EaXNwYXRjaGFibGUuY29mZmVlIiwiL1VzZXJzL2RhdmlkL0RvY3VtZW50cy9Xb3JrL21yYmwvc3JjL3V0aWwvVGltZW91dE1hbmFnZXIuY29mZmVlIiwiL1VzZXJzL2RhdmlkL0RvY3VtZW50cy9Xb3JrL21yYmwvc3JjL3V0aWwvZGlzcGF0Y2hhYmxlLmNvZmZlZSIsIi9Vc2Vycy9kYXZpZC9Eb2N1bWVudHMvV29yay9tcmJsL3NyYy92aWV3L0FwcGxpY2F0aW9uLmNqc3giLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvbXJibC9zcmMvdmlldy9JbnNwZWN0b3JDb250cm9sbGVyLmNvZmZlZSIsIi9Vc2Vycy9kYXZpZC9Eb2N1bWVudHMvV29yay9tcmJsL3NyYy92aWV3L1ZvbHVtZUNvbnRyb2wuY2pzeCIsIi9Vc2Vycy9kYXZpZC9Eb2N1bWVudHMvV29yay9tcmJsL3NyYy92aWV3L1dvcmxkQ29udHJvbGxlci5jb2ZmZWUiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvbXJibC9zcmMvdmlldy9pbnNwZWN0b3JzL0luc3BlY3RvckJhc2UuY29mZmVlIiwiL1VzZXJzL2RhdmlkL0RvY3VtZW50cy9Xb3JrL21yYmwvc3JjL3ZpZXcvaW5zcGVjdG9ycy9SZWRJbnNwZWN0b3IuY29mZmVlIiwiL1VzZXJzL2RhdmlkL0RvY3VtZW50cy9Xb3JrL21yYmwvc3JjL3ZpZXcvcGFwZXIvQ2FtZXJhQ29udHJvbC5jb2ZmZWUiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvbXJibC9zcmMvdmlldy9wYXBlci9JbmZpbml0ZVRpbGVkSXRlbS5jb2ZmZWUiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvbXJibC9zcmMvdmlldy9wYXBlci9NYWtlUmFuZG9tUGF0aC5jb2ZmZWUiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvbXJibC9zcmMvdmlldy9wYXBlci9SYW5kb21Db2xvci5jb2ZmZWUiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvbXJibC9zcmMvdmlldy9wYXBlci9UaWxlZEl0ZW0uY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2OEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x1QkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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YixJQUFHLE9BQU8sQ0FBQyxjQUFYO0lBQ0ssUUFBUSxDQUFDLE1BQVosQ0FBQSxFQURGOztBQUlBLE9BQVMsNkZBQVQ7QUFDRSxTQUFTLG1HQUFUO01BQ0UsUUFBQSxHQUFjLE1BQU0sQ0FBQyxLQUFWLENBQUE7TUFDWCxNQUFBLEdBQWEsSUFBQSxLQUFLLENBQUMsS0FBTixDQUNYLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEtBQXpCLEdBQWlDLENBRHRCLEVBRVgsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsTUFBekIsR0FBa0MsQ0FGdkI7TUFHYixNQUFBLEdBQVMsTUFBTSxDQUFDLEdBQVAsQ0FBVyxDQUFDLElBQUksQ0FBQyxNQUFMLENBQUEsQ0FBQSxHQUFnQixDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBZixHQUFtQixDQUFwQixDQUFoQixHQUF5QyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQXpELEVBQ0MsSUFBSSxDQUFDLE1BQUwsQ0FBQSxDQUFBLEdBQWdCLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFmLEdBQW1CLENBQXBCLENBQWhCLEdBQXlDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FEekQsQ0FBWDtNQUVULFFBQVEsQ0FBQyxRQUFULEdBQW9CLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBakIsQ0FBcUIsTUFBckI7TUFFcEIsUUFBQSxHQUFXLE9BQU8sQ0FBQyxVQUFSLENBQW1CLFFBQW5CO01BQ1gsT0FBTyxDQUFDLEtBQUssQ0FBQyxRQUFkLENBQXVCLFFBQXZCO0FBVkY7QUFERjtBQWFBLFNBQU8sT0FBTyxDQUFDO0FBbENnQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9qYWtlYXJjaGliYWxkL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIDMuMC4yXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNNYXliZVRoZW5hYmxlKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheSA9IGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXk7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPSAwO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJHZlcnR4TmV4dDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuO1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbl0gPSBjYWxsYmFjaztcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuICsgMV0gPSBhcmc7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuICs9IDI7XG4gICAgICBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9PT0gMikge1xuICAgICAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbihsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldEFzYXAoYXNhcEZuKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcCA9IGFzYXBGbjtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJXaW5kb3cgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDogdW5kZWZpbmVkO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93IHx8IHt9O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4gICAgLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgLy8gbm9kZVxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VOZXh0VGljaygpIHtcbiAgICAgIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gdmVydHhcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlVmVydHhUaW1lcigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHZlcnR4TmV4dChsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgbm9kZS5kYXRhID0gKGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gd2ViIHdvcmtlclxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCwgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuOyBpKz0yKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpXTtcbiAgICAgICAgdmFyIGFyZyA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpKzFdO1xuXG4gICAgICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaSsxXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJGF0dGVtcHRWZXJ0eCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByID0gcmVxdWlyZTtcbiAgICAgICAgdmFyIHZlcnR4ID0gcigndmVydHgnKTtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlVmVydHhUaW1lcigpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlU2V0VGltZW91dCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaDtcbiAgICAvLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNOb2RlKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VOZXh0VGljaygpO1xuICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhdHRlbXB0VmVydHgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlU2V0VGltZW91dCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3AoKSB7fVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcgICA9IHZvaWQgMDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEID0gMTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQgID0gMjtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUiA9IG5ldyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc2VsZkZ1bGZpbGxtZW50KCkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGNhbm5vdFJldHVybk93bigpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZ2V0VGhlbihwcm9taXNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5VGhlbih0aGVuLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuKSB7XG4gICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAoZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvciA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdGhlbmFibGUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9LCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICAgICAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpIHtcbiAgICAgIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRoZW4gPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKG1heWJlVGhlbmFibGUpO1xuXG4gICAgICAgIGlmICh0aGVuID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc2VsZkZ1bGZpbGxtZW50KCkpO1xuICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgICAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuXG4gICAgICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3N0YXRlID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEO1xuXG4gICAgICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gsIHByb21pc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cbiAgICAgIHByb21pc2UuX3N0YXRlID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQ7XG4gICAgICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgICAgIHZhciBsZW5ndGggPSBzdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgICAgIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURURdICA9IG9uUmVqZWN0aW9uO1xuXG4gICAgICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaCwgcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICAgICAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICAgICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgICAgdmFyIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKSB7XG4gICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SID0gbmV3IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCk7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgICAgIHZhciBoYXNDYWxsYmFjayA9IGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICAgICAgdmFsdWUsIGVycm9yLCBzdWNjZWVkZWQsIGZhaWxlZDtcblxuICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgIHZhbHVlID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IpIHtcbiAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSl7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgICAgZW51bWVyYXRvci5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgICAgZW51bWVyYXRvci5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuXG4gICAgICBpZiAoZW51bWVyYXRvci5fdmFsaWRhdGVJbnB1dChpbnB1dCkpIHtcbiAgICAgICAgZW51bWVyYXRvci5faW5wdXQgICAgID0gaW5wdXQ7XG4gICAgICAgIGVudW1lcmF0b3IubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgZW51bWVyYXRvci5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICAgIGVudW1lcmF0b3IuX2luaXQoKTtcblxuICAgICAgICBpZiAoZW51bWVyYXRvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKGVudW1lcmF0b3IucHJvbWlzZSwgZW51bWVyYXRvci5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnVtZXJhdG9yLmxlbmd0aCA9IGVudW1lcmF0b3IubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgZW51bWVyYXRvci5fZW51bWVyYXRlKCk7XG4gICAgICAgICAgaWYgKGVudW1lcmF0b3IuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChlbnVtZXJhdG9yLnByb21pc2UsIGVudW1lcmF0b3IuX3Jlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QoZW51bWVyYXRvci5wcm9taXNlLCBlbnVtZXJhdG9yLl92YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZUlucHV0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkoaW5wdXQpO1xuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3I7XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgICB2YXIgbGVuZ3RoICA9IGVudW1lcmF0b3IubGVuZ3RoO1xuICAgICAgdmFyIHByb21pc2UgPSBlbnVtZXJhdG9yLnByb21pc2U7XG4gICAgICB2YXIgaW5wdXQgICA9IGVudW1lcmF0b3IuX2lucHV0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgcHJvbWlzZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcgJiYgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24oZW50cnksIGkpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcbiAgICAgIHZhciBjID0gZW51bWVyYXRvci5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcblxuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNNYXliZVRoZW5hYmxlKGVudHJ5KSkge1xuICAgICAgICBpZiAoZW50cnkuY29uc3RydWN0b3IgPT09IGMgJiYgZW50cnkuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgICAgZW50cnkuX29uZXJyb3IgPSBudWxsO1xuICAgICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudW1lcmF0b3IuX3dpbGxTZXR0bGVBdChjLnJlc29sdmUoZW50cnkpLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW51bWVyYXRvci5fcmVtYWluaW5nLS07XG4gICAgICAgIGVudW1lcmF0b3IuX3Jlc3VsdFtpXSA9IGVudHJ5O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uKHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuICAgICAgdmFyIHByb21pc2UgPSBlbnVtZXJhdG9yLnByb21pc2U7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICBlbnVtZXJhdG9yLl9yZW1haW5pbmctLTtcblxuICAgICAgICBpZiAoc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnVtZXJhdG9yLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW51bWVyYXRvci5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgZW51bWVyYXRvci5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbihwcm9taXNlLCBpKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkYWxsKGVudHJpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJGRlZmF1bHQodGhpcywgZW50cmllcykucHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkYWxsO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJHJhY2UoZW50cmllcykge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuXG4gICAgICBpZiAoIWxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gb25GdWxmaWxsbWVudCh2YWx1ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25SZWplY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgcHJvbWlzZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcgJiYgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLCB1bmRlZmluZWQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkcmFjZTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRyZXNvbHZlKG9iamVjdCkge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAgIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJHJlc29sdmU7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRyZWplY3QocmVhc29uKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkcmVqZWN0O1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRjb3VudGVyID0gMDtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2U7XG4gICAgLyoqXG4gICAgICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gICAgICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICAgICAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gICAgICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgVGVybWlub2xvZ3lcbiAgICAgIC0tLS0tLS0tLS0tXG5cbiAgICAgIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAgICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gICAgICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gICAgICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgICAgIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgICAgIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gICAgICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gICAgICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gICAgICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICAgICAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gICAgICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gICAgICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgICAgIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgICAgIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgICAgIEJhc2ljIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIGBgYGpzXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBvbiBzdWNjZXNzXG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgICAgIC8vIG9uIGZhaWx1cmVcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gICAgICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgICAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICAgICAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgICAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQGNsYXNzIFByb21pc2VcbiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgICB0aGlzLl9pZCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRjb3VudGVyKys7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wICE9PSByZXNvbHZlcikge1xuICAgICAgICBpZiAoIWxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbihyZXNvbHZlcikpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNSZXNvbHZlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlKSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLmFsbCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yYWNlID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yZXNvbHZlID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yZWplY3QgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuX3NldFNjaGVkdWxlciA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRTY2hlZHVsZXI7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuX3NldEFzYXAgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0QXNhcDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fYXNhcCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwO1xuXG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucHJvdG90eXBlID0ge1xuICAgICAgY29uc3RydWN0b3I6IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLFxuXG4gICAgLyoqXG4gICAgICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgICAgIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gICAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQ2hhaW5pbmdcbiAgICAgIC0tLS0tLS0tXG5cbiAgICAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gICAgICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gICAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gdXNlci5uYW1lO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICAgICAgfSk7XG5cbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgICAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgICAgIH0pO1xuICAgICAgYGBgXG4gICAgICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBc3NpbWlsYXRpb25cbiAgICAgIC0tLS0tLS0tLS0tLVxuXG4gICAgICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICAgICAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICAgICAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgICAgIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgU2ltcGxlIEV4YW1wbGVcbiAgICAgIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9XG4gICAgICBgYGBcblxuICAgICAgRXJyYmFjayBFeGFtcGxlXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIC8vIGZhaWx1cmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFByb21pc2UgRXhhbXBsZTtcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgYXV0aG9yLCBib29rcztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgICAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9XG4gICAgICBgYGBcblxuICAgICAgRXJyYmFjayBFeGFtcGxlXG5cbiAgICAgIGBgYGpzXG5cbiAgICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcblxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuXG4gICAgICB9XG5cbiAgICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIC8vIGZhaWx1cmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFByb21pc2UgRXhhbXBsZTtcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgZmluZEF1dGhvcigpLlxuICAgICAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICAgICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAbWV0aG9kIHRoZW5cbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICAgICB0aGVuOiBmdW5jdGlvbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuICAgICAgICBpZiAoc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCAmJiAhb25GdWxmaWxsbWVudCB8fCBzdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQgJiYgIW9uUmVqZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcmVudC5fcmVzdWx0O1xuXG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tzdGF0ZSAtIDFdO1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCByZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9LFxuXG4gICAgLyoqXG4gICAgICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gICAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3luY2hyb25vdXNcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmRBdXRob3IoKTtcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9XG5cbiAgICAgIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQG1ldGhvZCBjYXRjaFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRwb2x5ZmlsbCgpIHtcbiAgICAgIHZhciBsb2NhbDtcblxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbG9jYWwgPSBnbG9iYWw7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGxvY2FsID0gc2VsZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICAgICAgaWYgKFAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKSA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb2NhbC5Qcm9taXNlID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQ7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJHBvbHlmaWxsO1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2UgPSB7XG4gICAgICAnUHJvbWlzZSc6IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0LFxuICAgICAgJ3BvbHlmaWxsJzogbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0XG4gICAgfTtcblxuICAgIC8qIGdsb2JhbCBkZWZpbmU6dHJ1ZSBtb2R1bGU6dHJ1ZSB3aW5kb3c6IHRydWUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKSB7XG4gICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlOyB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZVsnZXhwb3J0cyddKSB7XG4gICAgICBtb2R1bGVbJ2V4cG9ydHMnXSA9IGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXNbJ0VTNlByb21pc2UnXSA9IGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0KCk7XG59KS5jYWxsKHRoaXMpO1xuXG4iLCIvKiFcclxuICogT2JqZWN0Lm9ic2VydmUgcG9seWZpbGwgLSB2MC4yLjRcclxuICogYnkgTWFzc2ltbyBBcnRpenp1IChNYXhBcnQyNTAxKVxyXG4gKiBcclxuICogaHR0cHM6Ly9naXRodWIuY29tL01heEFydDI1MDEvb2JqZWN0LW9ic2VydmVcclxuICogXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxyXG4gKiBTZWUgTElDRU5TRSBmb3IgZGV0YWlsc1xyXG4gKi9cclxuXHJcbi8vIFNvbWUgdHlwZSBkZWZpbml0aW9uc1xyXG4vKipcclxuICogVGhpcyByZXByZXNlbnRzIHRoZSBkYXRhIHJlbGF0aXZlIHRvIGFuIG9ic2VydmVkIG9iamVjdFxyXG4gKiBAdHlwZWRlZiAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICBPYmplY3REYXRhXHJcbiAqIEBwcm9wZXJ0eSB7TWFwPEhhbmRsZXIsIEhhbmRsZXJEYXRhPn0gIGhhbmRsZXJzXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nW119ICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNcclxuICogQHByb3BlcnR5IHsqW119ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzXHJcbiAqIEBwcm9wZXJ0eSB7RGVzY3JpcHRvcltdfSAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzXHJcbiAqIEBwcm9wZXJ0eSB7Tm90aWZpZXJ9ICAgICAgICAgICAgICAgICAgIG5vdGlmaWVyXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgIGZyb3plblxyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICBleHRlbnNpYmxlXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgIHByb3RvXHJcbiAqL1xyXG4vKipcclxuICogRnVuY3Rpb24gZGVmaW5pdGlvbiBvZiBhIGhhbmRsZXJcclxuICogQGNhbGxiYWNrIEhhbmRsZXJcclxuICogQHBhcmFtIHtDaGFuZ2VSZWNvcmRbXX0gICAgICAgICAgICAgICAgY2hhbmdlc1xyXG4qL1xyXG4vKipcclxuICogVGhpcyByZXByZXNlbnRzIHRoZSBkYXRhIHJlbGF0aXZlIHRvIGFuIG9ic2VydmVkIG9iamVjdCBhbmQgb25lIG9mIGl0c1xyXG4gKiBoYW5kbGVyc1xyXG4gKiBAdHlwZWRlZiAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICBIYW5kbGVyRGF0YVxyXG4gKiBAcHJvcGVydHkge01hcDxPYmplY3QsIE9ic2VydmVkRGF0YT59ICBvYnNlcnZlZFxyXG4gKiBAcHJvcGVydHkge0NoYW5nZVJlY29yZFtdfSAgICAgICAgICAgICBjaGFuZ2VSZWNvcmRzXHJcbiAqL1xyXG4vKipcclxuICogQHR5cGVkZWYgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgT2JzZXJ2ZWREYXRhXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nW119ICAgICAgICAgICAgICAgICAgIGFjY2VwdExpc3RcclxuICogQHByb3BlcnR5IHtPYmplY3REYXRhfSAgICAgICAgICAgICAgICAgZGF0YVxyXG4qL1xyXG4vKipcclxuICogVHlwZSBkZWZpbml0aW9uIGZvciBhIGNoYW5nZS4gQW55IG90aGVyIHByb3BlcnR5IGNhbiBiZSBhZGRlZCB1c2luZ1xyXG4gKiB0aGUgbm90aWZ5KCkgb3IgcGVyZm9ybUNoYW5nZSgpIG1ldGhvZHMgb2YgdGhlIG5vdGlmaWVyLlxyXG4gKiBAdHlwZWRlZiAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICBDaGFuZ2VSZWNvcmRcclxuICogQHByb3BlcnR5IHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgdHlwZVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gICAgICAgICAgICAgICAgICAgICBvYmplY3RcclxuICogQHByb3BlcnR5IHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgW25hbWVdXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gICAgICAgICAgICAgICAgICAgICAgICAgIFtvbGRWYWx1ZV1cclxuICogQHByb3BlcnR5IHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgW2luZGV4XVxyXG4gKi9cclxuLyoqXHJcbiAqIFR5cGUgZGVmaW5pdGlvbiBmb3IgYSBub3RpZmllciAod2hhdCBPYmplY3QuZ2V0Tm90aWZpZXIgcmV0dXJucylcclxuICogQHR5cGVkZWYgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgTm90aWZpZXJcclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgbm90aWZ5XHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259ICAgICAgICAgICAgICAgICAgIHBlcmZvcm1DaGFuZ2VcclxuICovXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiBjYWxsZWQgd2l0aCBOb3RpZmllci5wZXJmb3JtQ2hhbmdlLiBJdCBtYXkgb3B0aW9uYWxseSByZXR1cm4gYVxyXG4gKiBDaGFuZ2VSZWNvcmQgdGhhdCBnZXRzIGF1dG9tYXRpY2FsbHkgbm90aWZpZWQsIGJ1dCBgdHlwZWAgYW5kIGBvYmplY3RgXHJcbiAqIHByb3BlcnRpZXMgYXJlIG92ZXJyaWRkZW4uXHJcbiAqIEBjYWxsYmFjayBQZXJmb3JtZXJcclxuICogQHJldHVybnMge0NoYW5nZVJlY29yZHx1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuT2JqZWN0Lm9ic2VydmUgfHwgKGZ1bmN0aW9uKE8sIEEsIHJvb3QpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWxhdGVzIG9ic2VydmVkIG9iamVjdHMgYW5kIHRoZWlyIGRhdGFcclxuICAgICAgICAgKiBAdHlwZSB7TWFwPE9iamVjdCwgT2JqZWN0RGF0YX1cclxuICAgICAgICAgKi9cclxuICAgIHZhciBvYnNlcnZlZCxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaXN0IG9mIGhhbmRsZXJzIGFuZCB0aGVpciBkYXRhXHJcbiAgICAgICAgICogQHR5cGUge01hcDxIYW5kbGVyLCBNYXA8T2JqZWN0LCBIYW5kbGVyRGF0YT4+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGhhbmRsZXJzLFxyXG5cclxuICAgICAgICBkZWZhdWx0QWNjZXB0TGlzdCA9IFsgXCJhZGRcIiwgXCJ1cGRhdGVcIiwgXCJkZWxldGVcIiwgXCJyZWNvbmZpZ3VyZVwiLCBcInNldFByb3RvdHlwZVwiLCBcInByZXZlbnRFeHRlbnNpb25zXCIgXTtcclxuXHJcbiAgICAvLyBGdW5jdGlvbnMgZm9yIGludGVybmFsIHVzYWdlXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgYXJndW1lbnQgaXMgYW4gQXJyYXkgb2JqZWN0LiBQb2x5ZmlsbHMgQXJyYXkuaXNBcnJheS5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gaXNBcnJheVxyXG4gICAgICAgICAqIEBwYXJhbSB7Pyp9IG9iamVjdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgdmFyIGlzQXJyYXkgPSBBLmlzQXJyYXkgfHwgKGZ1bmN0aW9uKHRvU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiB0b1N0cmluZy5jYWxsKG9iamVjdCkgPT09IFwiW29iamVjdCBBcnJheV1cIjsgfTtcclxuICAgICAgICB9KShPLnByb3RvdHlwZS50b1N0cmluZyksXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIGFuIGl0ZW0gaW4gYSBjb2xsZWN0aW9uLCBvciAtMSBpZiBub3QgZm91bmQuXHJcbiAgICAgICAgICogVXNlcyB0aGUgZ2VuZXJpYyBBcnJheS5pbmRleE9mIG9yIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGlmIGF2YWlsYWJsZS5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gaW5BcnJheVxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBwaXZvdCAgICAgICAgICAgSXRlbSB0byBsb29rIGZvclxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF0gIEluZGV4IHRvIHN0YXJ0IGZyb21cclxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluQXJyYXkgPSBBLnByb3RvdHlwZS5pbmRleE9mID8gQS5pbmRleE9mIHx8IGZ1bmN0aW9uKGFycmF5LCBwaXZvdCwgc3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEEucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgcGl2b3QsIHN0YXJ0KTtcclxuICAgICAgICB9IDogZnVuY3Rpb24oYXJyYXksIHBpdm90LCBzdGFydCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQgfHwgMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSBwaXZvdClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgTWFwLCBvciBhIE1hcC1saWtlIG9iamVjdCBpcyBNYXAgaXMgbm90XHJcbiAgICAgICAgICogc3VwcG9ydGVkIG9yIGRvZXNuJ3Qgc3VwcG9ydCBmb3JFYWNoKClcclxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlTWFwXHJcbiAgICAgICAgICogQHJldHVybnMge01hcH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGVNYXAgPSB0eXBlb2Ygcm9vdC5NYXAgPT09IFwidW5kZWZpbmVkXCIgfHwgIU1hcC5wcm90b3R5cGUuZm9yRWFjaCA/IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBMaWdodHdlaWdodCBzaGltIG9mIE1hcC4gTGFja3MgY2xlYXIoKSwgZW50cmllcygpLCBrZXlzKCkgYW5kXHJcbiAgICAgICAgICAgIC8vIHZhbHVlcygpICh0aGUgbGFzdCAzIG5vdCBzdXBwb3J0ZWQgYnkgSUUxMSwgc28gY2FuJ3QgdXNlIHRoZW0pLFxyXG4gICAgICAgICAgICAvLyBpdCBkb2Vzbid0IGhhbmRsZSB0aGUgY29uc3RydWN0b3IncyBhcmd1bWVudCAobGlrZSBJRTExKSBhbmQgb2ZcclxuICAgICAgICAgICAgLy8gY291cnNlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBmb3IuLi5vZi5cclxuICAgICAgICAgICAgLy8gQ2hyb21lIDMxLTM1IGFuZCBGaXJlZm94IDEzLTI0IGhhdmUgYSBiYXNpYyBzdXBwb3J0IG9mIE1hcCwgYnV0XHJcbiAgICAgICAgICAgIC8vIHRoZXkgbGFjayBmb3JFYWNoKCksIHNvIHRoZWlyIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyBiYWQgZm9yXHJcbiAgICAgICAgICAgIC8vIHRoaXMgcG9seWZpbGwuIChDaHJvbWUgMzYrIHN1cHBvcnRzIE9iamVjdC5vYnNlcnZlLilcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBbXSwgdmFsdWVzID0gW107XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2l6ZTogMCxcclxuICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpbkFycmF5KGtleXMsIGtleSkgPiAtMTsgfSxcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZXNbaW5BcnJheShrZXlzLCBrZXkpXTsgfSxcclxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gaW5BcnJheShrZXlzLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUrKztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdmFsdWVzW2ldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJkZWxldGVcIjogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBpbkFycmF5KGtleXMsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZvckVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrLyosIHRoaXNPYmoqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChhcmd1bWVudHNbMV0sIHZhbHVlc1tpXSwga2V5c1tpXSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IE1hcCgpOyB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaW1wbGUgc2hpbSBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2hlbiBpcyBub3QgYXZhaWxhYmxlXHJcbiAgICAgICAgICogTWlzc2VzIGNoZWNrcyBvbiBvYmplY3QsIGRvbid0IHVzZSBhcyBhIHJlcGxhY2VtZW50IG9mIE9iamVjdC5rZXlzL2dldE93blByb3BlcnR5TmFtZXNcclxuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0UHJvcHNcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ1tdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFByb3BzID0gTy5nZXRPd25Qcm9wZXJ0eU5hbWVzID8gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZnVuYyA9IE8uZ2V0T3duUHJvcGVydHlOYW1lcztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGFyZ3VtZW50cy5jYWxsZWU7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0cmljdCBtb2RlIGlzIHN1cHBvcnRlZFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEluIHN0cmljdCBtb2RlLCB3ZSBjYW4ndCBhY2Nlc3MgdG8gXCJhcmd1bWVudHNcIiwgXCJjYWxsZXJcIiBhbmRcclxuICAgICAgICAgICAgICAgIC8vIFwiY2FsbGVlXCIgcHJvcGVydGllcyBvZiBmdW5jdGlvbnMuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFsgXCJwcm90b3R5cGVcIiwgXCJsZW5ndGhcIiwgXCJuYW1lXCIgXSBpbiBGaXJlZm94OyBpdCByZXR1cm5zXHJcbiAgICAgICAgICAgICAgICAvLyBcImNhbGxlclwiIGFuZCBcImFyZ3VtZW50c1wiIHRvbyBpbiBDaHJvbWUgYW5kIGluIEludGVybmV0XHJcbiAgICAgICAgICAgICAgICAvLyBFeHBsb3Jlciwgc28gdGhvc2UgdmFsdWVzIG11c3QgYmUgZmlsdGVyZWQuXHJcbiAgICAgICAgICAgICAgICB2YXIgYXZvaWQgPSAoZnVuYyhpbkFycmF5KS5qb2luKFwiIFwiKSArIFwiIFwiKS5yZXBsYWNlKC9wcm90b3R5cGUgfGxlbmd0aCB8bmFtZSAvZywgXCJcIikuc2xpY2UoMCwgLTEpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChhdm9pZC5sZW5ndGgpIGZ1bmMgPSBmdW5jdGlvbihvYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBPLmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgajsgaSA8IGF2b2lkLmxlbmd0aDspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGogPSBpbkFycmF5KHByb3BzLCBhdm9pZFtpKytdKSkgPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5zcGxpY2UoaiwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmM7XHJcbiAgICAgICAgfSkoKSA6IGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgICAgICAgICAvLyBQb29yLW1vdXRoIHZlcnNpb24gd2l0aCBmb3IuLi5pbiAoSUU4LSlcclxuICAgICAgICAgICAgdmFyIHByb3BzID0gW10sIHByb3AsIGhvcDtcclxuICAgICAgICAgICAgaWYgKFwiaGFzT3duUHJvcGVydHlcIiBpbiBvYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIGZvciAocHJvcCBpbiBvYmplY3QpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhvcCA9IE8uaGFzT3duUHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gb2JqZWN0KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChob3AuY2FsbChvYmplY3QsIHByb3ApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbnNlcnRpbmcgYSBjb21tb24gbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb2YgYXJyYXlzXHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9iamVjdCkpXHJcbiAgICAgICAgICAgICAgICBwcm9wcy5wdXNoKFwibGVuZ3RoXCIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiB0aGUgcHJvdG90eXBlIG9mIHRoZSBvYmplY3QuLi4gaWYgZGVmaW5lZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0UHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0UHJvdG90eXBlID0gTy5nZXRQcm90b3R5cGVPZixcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIHRoZSBkZXNjcmlwdG9yIG9mIHRoZSBvYmplY3QuLi4gaWYgZGVmaW5lZC5cclxuICAgICAgICAgKiBJRTggc3VwcG9ydHMgYSAodXNlbGVzcykgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciBmb3IgRE9NXHJcbiAgICAgICAgICogbm9kZXMgb25seSwgc28gZGVmaW5lUHJvcGVydGllcyBpcyBjaGVja2VkIGluc3RlYWQuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGdldERlc2NyaXB0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XHJcbiAgICAgICAgICogQHJldHVybnMge0Rlc2NyaXB0b3J9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0RGVzY3JpcHRvciA9IE8uZGVmaW5lUHJvcGVydGllcyAmJiBPLmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB1cCB0aGUgbmV4dCBjaGVjayBhbmQgZGVsaXZlcmluZyBpdGVyYXRpb24sIHVzaW5nXHJcbiAgICAgICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lIG9yIGEgKGNsb3NlKSBwb2x5ZmlsbC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gbmV4dEZyYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbmV4dEZyYW1lID0gcm9vdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgcm9vdC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgaW5pdGlhbCA9ICtuZXcgRGF0ZSxcclxuICAgICAgICAgICAgICAgIGxhc3QgPSBpbml0aWFsO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZnVuYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuYygobGFzdCA9ICtuZXcgRGF0ZSkgLSBpbml0aWFsKTtcclxuICAgICAgICAgICAgICAgIH0sIDE3KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KSgpLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHVwIHRoZSBvYnNlcnZhdGlvbiBvZiBhbiBvYmplY3RcclxuICAgICAgICAgKiBAZnVuY3Rpb24gZG9PYnNlcnZlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxyXG4gICAgICAgICAqIEBwYXJhbSB7SGFuZGxlcn0gaGFuZGxlclxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IFthY2NlcHRMaXN0XVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRvT2JzZXJ2ZSA9IGZ1bmN0aW9uKG9iamVjdCwgaGFuZGxlciwgYWNjZXB0TGlzdCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBvYnNlcnZlZC5nZXQob2JqZWN0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhKVxyXG4gICAgICAgICAgICAgICAgc2V0SGFuZGxlcihvYmplY3QsIGRhdGEsIGhhbmRsZXIsIGFjY2VwdExpc3QpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBjcmVhdGVPYmplY3REYXRhKG9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICBzZXRIYW5kbGVyKG9iamVjdCwgZGF0YSwgaGFuZGxlciwgYWNjZXB0TGlzdCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlZC5zaXplID09PSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExldCB0aGUgb2JzZXJ2YXRpb24gYmVnaW4hXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dEZyYW1lKHJ1bkdsb2JhbExvb3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyB0aGUgaW5pdGlhbCBkYXRhIGZvciBhbiBvYnNlcnZlZCBvYmplY3RcclxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlT2JqZWN0RGF0YVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGVPYmplY3REYXRhID0gZnVuY3Rpb24ob2JqZWN0LCBkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGdldFByb3BzKG9iamVjdCksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbXSwgZGVzY3MsIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyczogY3JlYXRlTWFwKCksXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvemVuOiBPLmlzRnJvemVuID8gTy5pc0Zyb3plbihvYmplY3QpIDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaWJsZTogTy5pc0V4dGVuc2libGUgPyBPLmlzRXh0ZW5zaWJsZShvYmplY3QpIDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBwcm90bzogZ2V0UHJvdG90eXBlICYmIGdldFByb3RvdHlwZShvYmplY3QpLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BzLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWVyOiByZXRyaWV2ZU5vdGlmaWVyKG9iamVjdCwgZGF0YSlcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoZ2V0RGVzY3JpcHRvcikge1xyXG4gICAgICAgICAgICAgICAgZGVzY3MgPSBkYXRhLmRlc2NyaXB0b3JzID0gW107XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IHByb3BzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc2NzW2ldID0gZ2V0RGVzY3JpcHRvcihvYmplY3QsIHByb3BzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSBvYmplY3RbcHJvcHNbaSsrXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB3aGlsZSAoaSA8IHByb3BzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHZhbHVlc1tpXSA9IG9iamVjdFtwcm9wc1tpKytdXTtcclxuXHJcbiAgICAgICAgICAgIG9ic2VydmVkLnNldChvYmplY3QsIGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyZm9ybXMgYmFzaWMgcHJvcGVydHkgdmFsdWUgY2hhbmdlIGNoZWNrcyBvbiBhbiBvYnNlcnZlZCBvYmplY3RcclxuICAgICAgICAgKiBAZnVuY3Rpb24gcGVyZm9ybVByb3BlcnR5Q2hlY2tzXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3REYXRhfSBkYXRhXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZXhjZXB0XSAgRG9lc24ndCBkZWxpdmVyIHRoZSBjaGFuZ2VzIHRvIHRoZVxyXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMgdGhhdCBhY2NlcHQgdGhpcyB0eXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGVyZm9ybVByb3BlcnR5Q2hlY2tzID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdXBkYXRlQ2hlY2sgPSBnZXREZXNjcmlwdG9yID8gZnVuY3Rpb24ob2JqZWN0LCBkYXRhLCBpZHgsIGV4Y2VwdCwgZGVzY3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBkYXRhLnByb3BlcnRpZXNbaWR4XSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldLFxyXG4gICAgICAgICAgICAgICAgICAgIG92YWx1ZSA9IGRhdGEudmFsdWVzW2lkeF0sXHJcbiAgICAgICAgICAgICAgICAgICAgb2Rlc2MgPSBkYXRhLmRlc2NyaXB0b3JzW2lkeF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjciAmJiAob3ZhbHVlID09PSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG92YWx1ZSA9PT0gMCAmJiAxL292YWx1ZSAhPT0gMS92YWx1ZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvdmFsdWUgPT09IG92YWx1ZSB8fCB2YWx1ZSA9PT0gdmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2hhbmdlUmVjb3JkKG9iamVjdCwgZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb3ZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZXhjZXB0KTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnZhbHVlc1tpZHhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob2Rlc2MuY29uZmlndXJhYmxlICYmICghZGVzY3IuY29uZmlndXJhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGRlc2NyLndyaXRhYmxlICE9PSBvZGVzYy53cml0YWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBkZXNjci5lbnVtZXJhYmxlICE9PSBvZGVzYy5lbnVtZXJhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGRlc2NyLmdldCAhPT0gb2Rlc2MuZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGRlc2NyLnNldCAhPT0gb2Rlc2Muc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZENoYW5nZVJlY29yZChvYmplY3QsIGRhdGEsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlY29uZmlndXJlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb3ZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZXhjZXB0KTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmRlc2NyaXB0b3JzW2lkeF0gPSBkZXNjcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iamVjdCwgZGF0YSwgaWR4LCBleGNlcHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBkYXRhLnByb3BlcnRpZXNbaWR4XSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldLFxyXG4gICAgICAgICAgICAgICAgICAgIG92YWx1ZSA9IGRhdGEudmFsdWVzW2lkeF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG92YWx1ZSA9PT0gdmFsdWUgPyBvdmFsdWUgPT09IDAgJiYgMS9vdmFsdWUgIT09IDEvdmFsdWUgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3ZhbHVlID09PSBvdmFsdWUgfHwgdmFsdWUgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2hhbmdlUmVjb3JkKG9iamVjdCwgZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb3ZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZXhjZXB0KTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnZhbHVlc1tpZHhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVja3MgaWYgc29tZSBwcm9wZXJ0eSBoYXMgYmVlbiBkZWxldGVkXHJcbiAgICAgICAgICAgIHZhciBkZWxldGlvbkNoZWNrID0gZ2V0RGVzY3JpcHRvciA/IGZ1bmN0aW9uKG9iamVjdCwgcHJvcHMsIHByb3BsZW4sIGRhdGEsIGV4Y2VwdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSBwcm9wcy5sZW5ndGgsIGRlc2NyO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHByb3BsZW4gJiYgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzW2ldICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyID0gZ2V0RGVzY3JpcHRvcihvYmplY3QsIHByb3BzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGxlbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBkZXNjcmlwdG9yLCB0aGUgcHJvcGVydHkgaGFzIHJlYWxseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWVuIGRlbGV0ZWQ7IG90aGVyd2lzZSwgaXQncyBiZWVuIHJlY29uZmlndXJlZCBzb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0J3Mgbm90IGVudW1lcmFibGUgYW55bW9yZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVzY3IpIHVwZGF0ZUNoZWNrKG9iamVjdCwgZGF0YSwgaSwgZXhjZXB0LCBkZXNjcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2hhbmdlUmVjb3JkKG9iamVjdCwgZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGVsZXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGRhdGEudmFsdWVzW2ldXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBleGNlcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wcm9wZXJ0aWVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudmFsdWVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGVzY3JpcHRvcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IDogZnVuY3Rpb24ob2JqZWN0LCBwcm9wcywgcHJvcGxlbiwgZGF0YSwgZXhjZXB0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHByb3BzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChwcm9wbGVuICYmIGktLSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHNbaV0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2hhbmdlUmVjb3JkKG9iamVjdCwgZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcHNbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRlbGV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogZGF0YS52YWx1ZXNbaV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZXhjZXB0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wcm9wZXJ0aWVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS52YWx1ZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wbGVuLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEsIG9iamVjdCwgZXhjZXB0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuaGFuZGxlcnMuc2l6ZSB8fCBkYXRhLmZyb3plbikgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwcm9wcywgcHJvcGxlbiwga2V5cyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBkYXRhLnZhbHVlcyxcclxuICAgICAgICAgICAgICAgICAgICBkZXNjcyA9IGRhdGEuZGVzY3JpcHRvcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDAsIGlkeCxcclxuICAgICAgICAgICAgICAgICAgICBrZXksIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3RvLCBkZXNjcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGlzbid0IGV4dGVuc2libGUsIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIG5ld1xyXG4gICAgICAgICAgICAgICAgLy8gb3IgZGVsZXRlZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5leHRlbnNpYmxlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzID0gZGF0YS5wcm9wZXJ0aWVzLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGxlbiA9IHByb3BzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzID0gZ2V0UHJvcHMob2JqZWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2NzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaSsrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGluQXJyYXkocHJvcHMsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjciA9IGdldERlc2NyaXB0b3Iob2JqZWN0LCBrZXkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2hhbmdlUmVjb3JkKG9iamVjdCwgZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZXhjZXB0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnByb3BlcnRpZXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9iamVjdFtrZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcy5wdXNoKGRlc2NyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbaWR4XSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGxlbi0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNoZWNrKG9iamVjdCwgZGF0YSwgaWR4LCBleGNlcHQsIGRlc2NyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGlvbkNoZWNrKG9iamVjdCwgcHJvcHMsIHByb3BsZW4sIGRhdGEsIGV4Y2VwdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU8uaXNFeHRlbnNpYmxlKG9iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZXh0ZW5zaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2hhbmdlUmVjb3JkKG9iamVjdCwgZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicHJldmVudEV4dGVuc2lvbnNcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZXhjZXB0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmZyb3plbiA9IE8uaXNGcm96ZW4ob2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaSsrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGluQXJyYXkocHJvcHMsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2hhbmdlUmVjb3JkKG9iamVjdCwgZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZXhjZXB0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnByb3BlcnRpZXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbaWR4XSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGxlbi0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNoZWNrKG9iamVjdCwgZGF0YSwgaWR4LCBleGNlcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW9uQ2hlY2sob2JqZWN0LCBwcm9wcywgcHJvcGxlbiwgZGF0YSwgZXhjZXB0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZGF0YS5mcm96ZW4pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBpcyBub3QgZXh0ZW5zaWJsZSwgYnV0IG5vdCBmcm96ZW4sIHdlIGp1c3QgaGF2ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGNoZWNrIGZvciB2YWx1ZSBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBwcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2hlY2sob2JqZWN0LCBkYXRhLCBpLCBleGNlcHQsIGdldERlc2NyaXB0b3Iob2JqZWN0LCBrZXkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChPLmlzRnJvemVuKG9iamVjdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZnJvemVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZ2V0UHJvdG90eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8gPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvdG8gIT09IGRhdGEucHJvdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2hhbmdlUmVjb3JkKG9iamVjdCwgZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRQcm90b3R5cGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiX19wcm90b19fXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBkYXRhLnByb3RvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnByb3RvID0gcHJvdG87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKCksXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdXAgdGhlIG1haW4gbG9vcCBmb3Igb2JqZWN0IG9ic2VydmF0aW9uIGFuZCBjaGFuZ2Ugbm90aWZpY2F0aW9uXHJcbiAgICAgICAgICogSXQgc3RvcHMgaWYgbm8gb2JqZWN0IGlzIG9ic2VydmVkLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBydW5HbG9iYWxMb29wXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcnVuR2xvYmFsTG9vcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAob2JzZXJ2ZWQuc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZWQuZm9yRWFjaChwZXJmb3JtUHJvcGVydHlDaGVja3MpO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChkZWxpdmVySGFuZGxlclJlY29yZHMpO1xyXG4gICAgICAgICAgICAgICAgbmV4dEZyYW1lKHJ1bkdsb2JhbExvb3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsaXZlciB0aGUgY2hhbmdlIHJlY29yZHMgcmVsYXRpdmUgdG8gYSBjZXJ0YWluIGhhbmRsZXIsIGFuZCByZXNldHNcclxuICAgICAgICAgKiB0aGUgcmVjb3JkIGxpc3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtIYW5kbGVyRGF0YX0gaGRhdGFcclxuICAgICAgICAgKiBAcGFyYW0ge0hhbmRsZXJ9IGhhbmRsZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWxpdmVySGFuZGxlclJlY29yZHMgPSBmdW5jdGlvbihoZGF0YSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICBpZiAoaGRhdGEuY2hhbmdlUmVjb3Jkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoaGRhdGEuY2hhbmdlUmVjb3Jkcyk7XHJcbiAgICAgICAgICAgICAgICBoZGF0YS5jaGFuZ2VSZWNvcmRzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBub3RpZmllciBmb3IgYW4gb2JqZWN0IC0gd2hldGhlciBpdCdzIG9ic2VydmVkIG9yIG5vdFxyXG4gICAgICAgICAqIEBmdW5jdGlvbiByZXRyaWV2ZU5vdGlmaWVyXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0RGF0YX0gW2RhdGFdXHJcbiAgICAgICAgICogQHJldHVybnMge05vdGlmaWVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJldHJpZXZlTm90aWZpZXIgPSBmdW5jdGlvbihvYmplY3QsIGRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxyXG4gICAgICAgICAgICAgICAgZGF0YSA9IG9ic2VydmVkLmdldChvYmplY3QpO1xyXG5cclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtOb3RpZmllcn0gKi9cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGEgJiYgZGF0YS5ub3RpZmllciB8fCB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBtZXRob2Qgbm90aWZ5XHJcbiAgICAgICAgICAgICAgICAgKiBAc2VlIGh0dHA6Ly9hcnYuZ2l0aHViLmlvL2VjbWFzY3JpcHQtb2JqZWN0LW9ic2VydmUvI25vdGlmaWVycHJvdG90eXBlLl9ub3RpZnlcclxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiBOb3RpZmllclxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtDaGFuZ2VSZWNvcmR9IGNoYW5nZVJlY29yZFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBub3RpZnk6IGZ1bmN0aW9uKGNoYW5nZVJlY29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVJlY29yZC50eXBlOyAvLyBKdXN0IHRvIGNoZWNrIHRoZSBwcm9wZXJ0eSBpcyB0aGVyZS4uLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGRhdGEsIHRoZSBvYmplY3QgaGFzIGJlZW4gdW5vYnNlcnZlZFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gb2JzZXJ2ZWQuZ2V0KG9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZENvcHkgPSB7IG9iamVjdDogb2JqZWN0IH0sIHByb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocHJvcCBpbiBjaGFuZ2VSZWNvcmQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCAhPT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRDb3B5W3Byb3BdID0gY2hhbmdlUmVjb3JkW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDaGFuZ2VSZWNvcmQob2JqZWN0LCBkYXRhLCByZWNvcmRDb3B5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQG1ldGhvZCBwZXJmb3JtQ2hhbmdlXHJcbiAgICAgICAgICAgICAgICAgKiBAc2VlIGh0dHA6Ly9hcnYuZ2l0aHViLmlvL2VjbWFzY3JpcHQtb2JqZWN0LW9ic2VydmUvI25vdGlmaWVycHJvdG90eXBlXy5wZXJmb3JtY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgTm90aWZpZXJcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFuZ2VUeXBlXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1BlcmZvcm1lcn0gZnVuYyAgICAgVGhlIHRhc2sgcGVyZm9ybWVyXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IFt0aGlzT2JqXSAgICAgICAgVXNlZCB0byBzZXQgYHRoaXNgIHdoZW4gY2FsbGluZyBmdW5jXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHBlcmZvcm1DaGFuZ2U6IGZ1bmN0aW9uKGNoYW5nZVR5cGUsIGZ1bmMvKiwgdGhpc09iaiovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2VUeXBlICE9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBub24tc3RyaW5nIGNoYW5nZVR5cGVcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHBlcmZvcm0gbm9uLWZ1bmN0aW9uXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGRhdGEsIHRoZSBvYmplY3QgaGFzIGJlZW4gdW5vYnNlcnZlZFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gb2JzZXJ2ZWQuZ2V0KG9iamVjdCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AsIGNoYW5nZVJlY29yZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5jYWxsKGFyZ3VtZW50c1syXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgJiYgcGVyZm9ybVByb3BlcnR5Q2hlY2tzKGRhdGEsIG9iamVjdCwgY2hhbmdlVHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZGF0YSwgdGhlIG9iamVjdCBoYXMgYmVlbiB1bm9ic2VydmVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgcmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlUmVjb3JkID0geyBvYmplY3Q6IG9iamVjdCwgdHlwZTogY2hhbmdlVHlwZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gcmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgIT09IFwib2JqZWN0XCIgJiYgcHJvcCAhPT0gXCJ0eXBlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlUmVjb3JkW3Byb3BdID0gcmVzdWx0W3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDaGFuZ2VSZWNvcmQob2JqZWN0LCBkYXRhLCBjaGFuZ2VSZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RlciAob3IgcmVkZWZpbmVzKSBhbiBoYW5kbGVyIGluIHRoZSBjb2xsZWN0aW9uIGZvciBhIGdpdmVuXHJcbiAgICAgICAgICogb2JqZWN0IGFuZCBhIGdpdmVuIHR5cGUgYWNjZXB0IGxpc3QuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHNldEhhbmRsZXJcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3REYXRhfSBkYXRhXHJcbiAgICAgICAgICogQHBhcmFtIHtIYW5kbGVyfSBoYW5kbGVyXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gYWNjZXB0TGlzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldEhhbmRsZXIgPSBmdW5jdGlvbihvYmplY3QsIGRhdGEsIGhhbmRsZXIsIGFjY2VwdExpc3QpIHtcclxuICAgICAgICAgICAgdmFyIGhkYXRhID0gaGFuZGxlcnMuZ2V0KGhhbmRsZXIpO1xyXG4gICAgICAgICAgICBpZiAoIWhkYXRhKVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlcnMuc2V0KGhhbmRsZXIsIGhkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVkOiBjcmVhdGVNYXAoKSxcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VSZWNvcmRzOiBbXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhkYXRhLm9ic2VydmVkLnNldChvYmplY3QsIHtcclxuICAgICAgICAgICAgICAgIGFjY2VwdExpc3Q6IGFjY2VwdExpc3Quc2xpY2UoKSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRhdGEuaGFuZGxlcnMuc2V0KGhhbmRsZXIsIGhkYXRhKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY2hhbmdlIHJlY29yZCBpbiBhIGdpdmVuIE9iamVjdERhdGFcclxuICAgICAgICAgKiBAZnVuY3Rpb24gYWRkQ2hhbmdlUmVjb3JkXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0RGF0YX0gZGF0YVxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2hhbmdlUmVjb3JkfSBjaGFuZ2VSZWNvcmRcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2V4Y2VwdF1cclxuICAgICAgICAgKi9cclxuICAgICAgICBhZGRDaGFuZ2VSZWNvcmQgPSBmdW5jdGlvbihvYmplY3QsIGRhdGEsIGNoYW5nZVJlY29yZCwgZXhjZXB0KSB7XHJcbiAgICAgICAgICAgIGRhdGEuaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjY2VwdExpc3QgPSBoZGF0YS5vYnNlcnZlZC5nZXQob2JqZWN0KS5hY2NlcHRMaXN0O1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgZXhjZXB0IGlzIGRlZmluZWQsIE5vdGlmaWVyLnBlcmZvcm1DaGFuZ2UgaGFzIGJlZW5cclxuICAgICAgICAgICAgICAgIC8vIGNhbGxlZCwgd2l0aCBleGNlcHQgYXMgdGhlIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgdGhlIGhhbmRsZXJzIHRoYXQgYWNjZXB0cyB0aGF0IHR5cGUgYXJlIHNraXBwZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBleGNlcHQgIT09IFwic3RyaW5nXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgaW5BcnJheShhY2NlcHRMaXN0LCBleGNlcHQpID09PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgaW5BcnJheShhY2NlcHRMaXN0LCBjaGFuZ2VSZWNvcmQudHlwZSkgPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICBoZGF0YS5jaGFuZ2VSZWNvcmRzLnB1c2goY2hhbmdlUmVjb3JkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBvYnNlcnZlZCA9IGNyZWF0ZU1hcCgpO1xyXG4gICAgaGFuZGxlcnMgPSBjcmVhdGVNYXAoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBPYmplY3Qub2JzZXJ2ZVxyXG4gICAgICogQHNlZSBodHRwOi8vYXJ2LmdpdGh1Yi5pby9lY21hc2NyaXB0LW9iamVjdC1vYnNlcnZlLyNPYmplY3Qub2JzZXJ2ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtIYW5kbGVyfSBoYW5kbGVyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBbYWNjZXB0TGlzdF1cclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9ICAgICAgICAgICAgICAgVGhlIG9ic2VydmVkIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBPLm9ic2VydmUgPSBmdW5jdGlvbiBvYnNlcnZlKG9iamVjdCwgaGFuZGxlciwgYWNjZXB0TGlzdCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iamVjdCAhPT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0Lm9ic2VydmUgY2Fubm90IG9ic2VydmUgbm9uLW9iamVjdFwiKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qub2JzZXJ2ZSBjYW5ub3QgZGVsaXZlciB0byBub24tZnVuY3Rpb25cIik7XHJcblxyXG4gICAgICAgIGlmIChPLmlzRnJvemVuICYmIE8uaXNGcm96ZW4oaGFuZGxlcikpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qub2JzZXJ2ZSBjYW5ub3QgZGVsaXZlciB0byBhIGZyb3plbiBmdW5jdGlvbiBvYmplY3RcIik7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgYWNjZXB0TGlzdCA9PT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICAgICAgYWNjZXB0TGlzdCA9IGRlZmF1bHRBY2NlcHRMaXN0O1xyXG4gICAgICAgIGVsc2UgaWYgKCFhY2NlcHRMaXN0IHx8IHR5cGVvZiBhY2NlcHRMaXN0ICE9PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhpcmQgYXJndW1lbnQgdG8gT2JqZWN0Lm9ic2VydmUgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzLlwiKTtcclxuXHJcbiAgICAgICAgZG9PYnNlcnZlKG9iamVjdCwgaGFuZGxlciwgYWNjZXB0TGlzdCk7XHJcblxyXG4gICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIE9iamVjdC51bm9ic2VydmVcclxuICAgICAqIEBzZWUgaHR0cDovL2Fydi5naXRodWIuaW8vZWNtYXNjcmlwdC1vYmplY3Qtb2JzZXJ2ZS8jT2JqZWN0LnVub2JzZXJ2ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtIYW5kbGVyfSBoYW5kbGVyXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAgICAgICAgIFRoZSBnaXZlbiBvYmplY3RcclxuICAgICAqL1xyXG4gICAgTy51bm9ic2VydmUgPSBmdW5jdGlvbiB1bm9ic2VydmUob2JqZWN0LCBoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmplY3QgIT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdC51bm9ic2VydmUgY2Fubm90IHVub2JzZXJ2ZSBub24tb2JqZWN0XCIpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdC51bm9ic2VydmUgY2Fubm90IGRlbGl2ZXIgdG8gbm9uLWZ1bmN0aW9uXCIpO1xyXG5cclxuICAgICAgICB2YXIgaGRhdGEgPSBoYW5kbGVycy5nZXQoaGFuZGxlciksIG9kYXRhO1xyXG5cclxuICAgICAgICBpZiAoaGRhdGEgJiYgKG9kYXRhID0gaGRhdGEub2JzZXJ2ZWQuZ2V0KG9iamVjdCkpKSB7XHJcbiAgICAgICAgICAgIGhkYXRhLm9ic2VydmVkLmZvckVhY2goZnVuY3Rpb24ob2RhdGEsIG9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgcGVyZm9ybVByb3BlcnR5Q2hlY2tzKG9kYXRhLmRhdGEsIG9iamVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBuZXh0RnJhbWUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxpdmVySGFuZGxlclJlY29yZHMoaGRhdGEsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluIEZpcmVmb3ggMTMtMTgsIHNpemUgaXMgYSBmdW5jdGlvbiwgYnV0IGNyZWF0ZU1hcCBzaG91bGQgZmFsbFxyXG4gICAgICAgICAgICAvLyBiYWNrIHRvIHRoZSBzaGltIGZvciB0aG9zZSB2ZXJzaW9uc1xyXG4gICAgICAgICAgICBpZiAoaGRhdGEub2JzZXJ2ZWQuc2l6ZSA9PT0gMSAmJiBoZGF0YS5vYnNlcnZlZC5oYXMob2JqZWN0KSlcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJzW1wiZGVsZXRlXCJdKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICBlbHNlIGhkYXRhLm9ic2VydmVkW1wiZGVsZXRlXCJdKG9iamVjdCk7XHJcblxyXG4gICAgICAgICAgICBpZiAob2RhdGEuZGF0YS5oYW5kbGVycy5zaXplID09PSAxKVxyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZWRbXCJkZWxldGVcIl0ob2JqZWN0KTtcclxuICAgICAgICAgICAgZWxzZSBvZGF0YS5kYXRhLmhhbmRsZXJzW1wiZGVsZXRlXCJdKGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gT2JqZWN0LmdldE5vdGlmaWVyXHJcbiAgICAgKiBAc2VlIGh0dHA6Ly9hcnYuZ2l0aHViLmlvL2VjbWFzY3JpcHQtb2JqZWN0LW9ic2VydmUvI0dldE5vdGlmaWVyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XHJcbiAgICAgKiBAcmV0dXJucyB7Tm90aWZpZXJ9XHJcbiAgICAgKi9cclxuICAgIE8uZ2V0Tm90aWZpZXIgPSBmdW5jdGlvbiBnZXROb3RpZmllcihvYmplY3QpIHtcclxuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iamVjdCAhPT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0LmdldE5vdGlmaWVyIGNhbm5vdCBnZXROb3RpZmllciBub24tb2JqZWN0XCIpO1xyXG5cclxuICAgICAgICBpZiAoTy5pc0Zyb3plbiAmJiBPLmlzRnJvemVuKG9iamVjdCkpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICByZXR1cm4gcmV0cmlldmVOb3RpZmllcihvYmplY3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBPYmplY3QuZGVsaXZlckNoYW5nZVJlY29yZHNcclxuICAgICAqIEBzZWUgaHR0cDovL2Fydi5naXRodWIuaW8vZWNtYXNjcmlwdC1vYmplY3Qtb2JzZXJ2ZS8jT2JqZWN0LmRlbGl2ZXJDaGFuZ2VSZWNvcmRzXHJcbiAgICAgKiBAc2VlIGh0dHA6Ly9hcnYuZ2l0aHViLmlvL2VjbWFzY3JpcHQtb2JqZWN0LW9ic2VydmUvI0RlbGl2ZXJDaGFuZ2VSZWNvcmRzXHJcbiAgICAgKiBAcGFyYW0ge0hhbmRsZXJ9IGhhbmRsZXJcclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cclxuICAgICAqL1xyXG4gICAgTy5kZWxpdmVyQ2hhbmdlUmVjb3JkcyA9IGZ1bmN0aW9uIGRlbGl2ZXJDaGFuZ2VSZWNvcmRzKGhhbmRsZXIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdC5kZWxpdmVyQ2hhbmdlUmVjb3JkcyBjYW5ub3QgZGVsaXZlciB0byBub24tZnVuY3Rpb25cIik7XHJcblxyXG4gICAgICAgIHZhciBoZGF0YSA9IGhhbmRsZXJzLmdldChoYW5kbGVyKTtcclxuICAgICAgICBpZiAoaGRhdGEpIHtcclxuICAgICAgICAgICAgaGRhdGEub2JzZXJ2ZWQuZm9yRWFjaChmdW5jdGlvbihvZGF0YSwgb2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBwZXJmb3JtUHJvcGVydHlDaGVja3Mob2RhdGEuZGF0YSwgb2JqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRlbGl2ZXJIYW5kbGVyUmVjb3JkcyhoZGF0YSwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbn0pKE9iamVjdCwgQXJyYXksIHRoaXMpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliLyRFdmVudFRhcmdldC5qc1wiKTsiLCIvKipcclxuXHQkRXZlbnRUYXJnZXQgbWl4aW5cclxuXHRAYXV0aG9yIEJhcnQgVmFuIEJldXJkZW5cclxuXHRAZGF0ZSAyNi8wMS8yMDE0XHJcbioqL1xyXG5cclxuLyoqXHJcblx0RXZlbnRzIGRpc3BhdGNoZWQgYnkgJEV2ZW50VGFyZ2V0IGhhdmUgMyBwcm9wZXJ0aWVzOlxyXG5cdC0gdHlwZSAoc3RyaW5nKVxyXG5cdC0gdGFyZ2V0IChldmVudCBzb3VyY2UpXHJcblx0LSBkYXRhICh1c2VyLXByb3ZpZGVkKVxyXG4qKi9cclxudmFyIEV2ZW50ID0gZnVuY3Rpb24odHlwZSwgdGFyZ2V0LCBkYXRhKSB7XHJcblx0dGhpcy50eXBlID0gdHlwZTtcclxuXHR0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuXHR0aGlzLmRhdGEgPSBkYXRhO1xyXG59O1xyXG5cclxuLyoqXHJcblx0JEV2ZW50VGFyZ2V0IG1peGluXHJcblx0RXh0ZW5kcyBhbiBvYmplY3Qgd2l0aCBFdmVudFRhcmdldCBtZXRob2RzXHJcblx0KGFkZHMgI2FkZEV2ZW50TGlzdGVuZXIsICNyZW1vdmVFdmVudExpc3RlbmVyLCAjZGlzcGF0Y2hFdmVudClcclxuXHRAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gZXh0ZW5kXHJcbioqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaikge1xyXG5cclxuXHRvYmouX2xpc3RlbmVycyA9IHt9O1xyXG5cdHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xyXG5cdFxyXG5cdC8vIGlmIG5lY2Vzc2FyeSwgZXh0ZW5kIHByb3RvdHlwZVxyXG5cdGlmICghcHJvdG8uYWRkRXZlbnRMaXN0ZW5lcikge1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHRcdCRFdmVudFRhcmdldCNhZGRFdmVudExpc3RlbmVyXHJcblx0XHRcdEBwYXJhbSB0eXBlIFRoZSBldmVudCBUeXBlIHRvIGxpc3RlbiB0b1xyXG5cdFx0XHRAcGFyYW0gY2FsbGJhY2soZXZlbnQpIFRoZSBsaXN0ZW5lciBmdW5jdGlvblxyXG5cdFx0XHRAcmV0dXJucyB0aGlzXHJcblx0XHQqKi9cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJhZGRFdmVudExpc3RlbmVyXCIsIHsgdmFsdWU6IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XHJcblx0XHRcdGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIsIFwiJEV2ZW50VGFyZ2V0I2FkZEV2ZW50TGlzdGVuZXIgLSB0eXBlIG11c3QgYmUgc3RyaW5nXCIpO1xyXG5cdFx0XHRjb25zb2xlLmFzc2VydCh0eXBlb2YgY2FsbGJhY2sgPT0gXCJmdW5jdGlvblwiLCBcIiRFdmVudFRhcmdldCNhZGRFdmVudExpc3RlbmVyIC0gY2FsbGJhY2sgbXVzdCBiZSBmdW5jdGlvblwiKTtcclxuXHRcdFx0XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XHJcblx0XHRcdGlmICghbGlzdGVuZXJzKSBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXTtcclxuXHRcdFx0bGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH19KTtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHRcdCRFdmVudFRhcmdldCNyZW1vdmVFdmVudExpc3RlbmVyXHJcblx0XHRcdEBwYXJhbSB0eXBlIFRoZSBldmVudCBUeXBlIHRvIHJlbW92ZVxyXG5cdFx0XHRAcGFyYW0gY2FsbGJhY2soZXZlbnQpIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmVcclxuXHRcdFx0QHJldHVybnMgdGhpc1xyXG5cdFx0KiovXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLCB7IHZhbHVlOiBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xyXG5cdFx0XHRjb25zb2xlLmFzc2VydCh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiLCBcIiRFdmVudFRhcmdldCNyZW1vdmVFdmVudExpc3RlbmVyIC0gdHlwZSBtdXN0IGJlIHN0cmluZ1wiKTtcclxuXHRcdFx0Y29uc29sZS5hc3NlcnQodHlwZW9mIGNhbGxiYWNrID09IFwiZnVuY3Rpb25cIiwgXCIkRXZlbnRUYXJnZXQjcmVtb3ZlRXZlbnRMaXN0ZW5lciAtIGNhbGxiYWNrIG11c3QgYmUgZnVuY3Rpb25cIik7XHJcblx0XHRcdFxyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0dmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spO1xyXG5cdFx0XHRcdGlmIChpbmRleCAhPSAtMSkge1xyXG5cdFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHRcdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA9PSAwKSBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH19KTtcclxuXHRcdFxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBcImNsZWFyRXZlbnRMaXN0ZW5lcnNcIiwgeyB2YWx1ZTogZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xyXG5cdFx0XHRcdHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9fSk7XHJcblx0XHRcclxuXHRcdHZhciBkaXNwYXRjaGVyID0gZnVuY3Rpb24oZXZlbnQpIHsgXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykgeyBcclxuXHRcdFx0XHRjYWxsYmFjayhldmVudCk7XHJcblx0XHRcdH07XHJcblx0XHR9O1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdFx0JEV2ZW50VGFyZ2V0I2Rpc3BhdGNoRXZlbnRcclxuXHRcdFx0QHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIGV2ZW50IHRvIGRpc3BhdGNoXHJcblx0XHRcdEBwYXJhbSBkYXRhIFtPcHRpb25hbF0gVGhlIGRhdGEgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJzXHJcblx0XHQqKi9cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJkaXNwYXRjaEV2ZW50XCIsIHsgdmFsdWU6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcclxuXHRcdFx0Y29uc29sZS5hc3NlcnQodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIiwgXCIkRXZlbnRUYXJnZXQjZGlzcGF0Y2hFdmVudCAtIHR5cGUgbXVzdCBiZSBzdHJpbmdcIik7XHJcblx0XHRcdFxyXG5cdFx0XHQodGhpcy5fbGlzdGVuZXJzW3R5cGVdIHx8IFtdKS5mb3JFYWNoKGRpc3BhdGNoZXIobmV3IEV2ZW50KHR5cGUsIHRoaXMsIGRhdGEpKSk7XHJcblx0XHR9fSk7XHJcblx0fTtcclxuXHRcclxuXHRyZXR1cm4gb2JqO1xyXG5cclxufTsiLCIvKiFcbiAqIFBhcGVyLmpzIHYwLjkuMjQgLSBUaGUgU3dpc3MgQXJteSBLbmlmZSBvZiBWZWN0b3IgR3JhcGhpY3MgU2NyaXB0aW5nLlxuICogaHR0cDovL3BhcGVyanMub3JnL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMSAtIDIwMTQsIEp1ZXJnIExlaG5pICYgSm9uYXRoYW4gUHVja2V5XG4gKiBodHRwOi8vc2NyYXRjaGRpc2suY29tLyAmIGh0dHA6Ly9qb25hdGhhbnB1Y2tleS5jb20vXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuICpcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogRGF0ZTogRnJpIEF1ZyAyMSAxNjozOTo0MSAyMDE1ICswMjAwXG4gKlxuICoqKlxuICpcbiAqIFN0cmFwcy5qcyAtIENsYXNzIGluaGVyaXRhbmNlIGxpYnJhcnkgd2l0aCBzdXBwb3J0IGZvciBiZWFuLXN0eWxlIGFjY2Vzc29yc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAwNiAtIDIwMTMgSnVlcmcgTGVobmlcbiAqIGh0dHA6Ly9zY3JhdGNoZGlzay5jb20vXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICpcbiAqKipcbiAqXG4gKiBBY29ybi5qc1xuICogaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9hY29ybi9cbiAqXG4gKiBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LFxuICogY3JlYXRlZCBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVQgbGljZW5zZS5cbiAqXG4gKi9cblxudmFyIHBhcGVyID0gbmV3IGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuXG52YXIgQmFzZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGhpZGRlbiA9IC9eKHN0YXRpY3N8ZW51bWVyYWJsZXxiZWFuc3xwcmVzZXJ2ZSkkLyxcblxuXHRcdGZvckVhY2ggPSBbXS5mb3JFYWNoIHx8IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcblx0XHR9LFxuXG5cdFx0Zm9ySW4gPSBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIHRoaXMpXG5cdFx0XHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGkpKVxuXHRcdFx0XHRcdGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcblx0XHR9LFxuXG5cdFx0Y3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbihwcm90bykge1xuXHRcdFx0cmV0dXJuIHsgX19wcm90b19fOiBwcm90byB9O1xuXHRcdH0sXG5cblx0XHRkZXNjcmliZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgfHwgZnVuY3Rpb24ob2JqLCBuYW1lKSB7XG5cdFx0XHR2YXIgZ2V0ID0gb2JqLl9fbG9va3VwR2V0dGVyX18gJiYgb2JqLl9fbG9va3VwR2V0dGVyX18obmFtZSk7XG5cdFx0XHRyZXR1cm4gZ2V0XG5cdFx0XHRcdFx0PyB7IGdldDogZ2V0LCBzZXQ6IG9iai5fX2xvb2t1cFNldHRlcl9fKG5hbWUpLFxuXHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH1cblx0XHRcdFx0XHQ6IG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuXHRcdFx0XHRcdFx0PyB7IHZhbHVlOiBvYmpbbmFtZV0sIGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfVxuXHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdH0sXG5cblx0XHRfZGVmaW5lID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uKG9iaiwgbmFtZSwgZGVzYykge1xuXHRcdFx0aWYgKChkZXNjLmdldCB8fCBkZXNjLnNldCkgJiYgb2JqLl9fZGVmaW5lR2V0dGVyX18pIHtcblx0XHRcdFx0aWYgKGRlc2MuZ2V0KVxuXHRcdFx0XHRcdG9iai5fX2RlZmluZUdldHRlcl9fKG5hbWUsIGRlc2MuZ2V0KTtcblx0XHRcdFx0aWYgKGRlc2Muc2V0KVxuXHRcdFx0XHRcdG9iai5fX2RlZmluZVNldHRlcl9fKG5hbWUsIGRlc2Muc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9ialtuYW1lXSA9IGRlc2MudmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sXG5cblx0XHRkZWZpbmUgPSBmdW5jdGlvbihvYmosIG5hbWUsIGRlc2MpIHtcblx0XHRcdGRlbGV0ZSBvYmpbbmFtZV07XG5cdFx0XHRyZXR1cm4gX2RlZmluZShvYmosIG5hbWUsIGRlc2MpO1xuXHRcdH07XG5cblx0ZnVuY3Rpb24gaW5qZWN0KGRlc3QsIHNyYywgZW51bWVyYWJsZSwgYmVhbnMsIHByZXNlcnZlKSB7XG5cdFx0dmFyIGJlYW5zTmFtZXMgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGZpZWxkKG5hbWUsIHZhbCkge1xuXHRcdFx0dmFsID0gdmFsIHx8ICh2YWwgPSBkZXNjcmliZShzcmMsIG5hbWUpKVxuXHRcdFx0XHRcdCYmICh2YWwuZ2V0ID8gdmFsIDogdmFsLnZhbHVlKTtcblx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWxbMF0gPT09ICcjJylcblx0XHRcdFx0dmFsID0gZGVzdFt2YWwuc3Vic3RyaW5nKDEpXSB8fCB2YWw7XG5cdFx0XHR2YXIgaXNGdW5jID0gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcblx0XHRcdFx0cmVzID0gdmFsLFxuXHRcdFx0XHRwcmV2ID0gcHJlc2VydmUgfHwgaXNGdW5jICYmICF2YWwuYmFzZVxuXHRcdFx0XHRcdFx0PyAodmFsICYmIHZhbC5nZXQgPyBuYW1lIGluIGRlc3QgOiBkZXN0W25hbWVdKVxuXHRcdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0XHRiZWFuO1xuXHRcdFx0aWYgKCFwcmVzZXJ2ZSB8fCAhcHJldikge1xuXHRcdFx0XHRpZiAoaXNGdW5jICYmIHByZXYpXG5cdFx0XHRcdFx0dmFsLmJhc2UgPSBwcmV2O1xuXHRcdFx0XHRpZiAoaXNGdW5jICYmIGJlYW5zICE9PSBmYWxzZVxuXHRcdFx0XHRcdFx0JiYgKGJlYW4gPSBuYW1lLm1hdGNoKC9eKFtnc11ldHxpcykoKFtBLVpdKSguKikpJC8pKSlcblx0XHRcdFx0XHRiZWFuc05hbWVzW2JlYW5bM10udG9Mb3dlckNhc2UoKSArIGJlYW5bNF1dID0gYmVhblsyXTtcblx0XHRcdFx0aWYgKCFyZXMgfHwgaXNGdW5jIHx8ICFyZXMuZ2V0IHx8IHR5cGVvZiByZXMuZ2V0ICE9PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHR8fCAhQmFzZS5pc1BsYWluT2JqZWN0KHJlcykpXG5cdFx0XHRcdFx0cmVzID0geyB2YWx1ZTogcmVzLCB3cml0YWJsZTogdHJ1ZSB9O1xuXHRcdFx0XHRpZiAoKGRlc2NyaWJlKGRlc3QsIG5hbWUpXG5cdFx0XHRcdFx0XHR8fCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KS5jb25maWd1cmFibGUpIHtcblx0XHRcdFx0XHRyZXMuY29uZmlndXJhYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXMuZW51bWVyYWJsZSA9IGVudW1lcmFibGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVmaW5lKGRlc3QsIG5hbWUsIHJlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzcmMpIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gc3JjKSB7XG5cdFx0XHRcdGlmIChzcmMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIWhpZGRlbi50ZXN0KG5hbWUpKVxuXHRcdFx0XHRcdGZpZWxkKG5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBiZWFuc05hbWVzKSB7XG5cdFx0XHRcdHZhciBwYXJ0ID0gYmVhbnNOYW1lc1tuYW1lXSxcblx0XHRcdFx0XHRzZXQgPSBkZXN0WydzZXQnICsgcGFydF0sXG5cdFx0XHRcdFx0Z2V0ID0gZGVzdFsnZ2V0JyArIHBhcnRdIHx8IHNldCAmJiBkZXN0WydpcycgKyBwYXJ0XTtcblx0XHRcdFx0aWYgKGdldCAmJiAoYmVhbnMgPT09IHRydWUgfHwgZ2V0Lmxlbmd0aCA9PT0gMCkpXG5cdFx0XHRcdFx0ZmllbGQobmFtZSwgeyBnZXQ6IGdldCwgc2V0OiBzZXQgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkZXN0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIsIGJpbmQpIHtcblx0XHRpZiAob2JqKVxuXHRcdFx0KCdsZW5ndGgnIGluIG9iaiAmJiAhb2JqLmdldExlbmd0aFxuXHRcdFx0XHRcdCYmIHR5cGVvZiBvYmoubGVuZ3RoID09PSAnbnVtYmVyJ1xuXHRcdFx0XHQ/IGZvckVhY2hcblx0XHRcdFx0OiBmb3JJbikuY2FsbChvYmosIGl0ZXIsIGJpbmQgPSBiaW5kIHx8IG9iaik7XG5cdFx0cmV0dXJuIGJpbmQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQob2JqLCBwcm9wcywgZXhjbHVkZSkge1xuXHRcdGZvciAodmFyIGtleSBpbiBwcm9wcylcblx0XHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICEoZXhjbHVkZSAmJiBleGNsdWRlW2tleV0pKVxuXHRcdFx0XHRvYmpba2V5XSA9IHByb3BzW2tleV07XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXG5cdHJldHVybiBpbmplY3QoZnVuY3Rpb24gQmFzZSgpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzZXQodGhpcywgYXJndW1lbnRzW2ldKTtcblx0fSwge1xuXHRcdGluamVjdDogZnVuY3Rpb24oc3JjKSB7XG5cdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdHZhciBzdGF0aWNzID0gc3JjLnN0YXRpY3MgPT09IHRydWUgPyBzcmMgOiBzcmMuc3RhdGljcyxcblx0XHRcdFx0XHRiZWFucyA9IHNyYy5iZWFucyxcblx0XHRcdFx0XHRwcmVzZXJ2ZSA9IHNyYy5wcmVzZXJ2ZTtcblx0XHRcdFx0aWYgKHN0YXRpY3MgIT09IHNyYylcblx0XHRcdFx0XHRpbmplY3QodGhpcy5wcm90b3R5cGUsIHNyYywgc3JjLmVudW1lcmFibGUsIGJlYW5zLCBwcmVzZXJ2ZSk7XG5cdFx0XHRcdGluamVjdCh0aGlzLCBzdGF0aWNzLCB0cnVlLCBiZWFucywgcHJlc2VydmUpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLmluamVjdChhcmd1bWVudHNbaV0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYmFzZSA9IHRoaXMsXG5cdFx0XHRcdGN0b3IsXG5cdFx0XHRcdHByb3RvO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoY3RvciA9IGFyZ3VtZW50c1tpXS5pbml0aWFsaXplKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y3RvciA9IGN0b3IgfHwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0XHRwcm90byA9IGN0b3IucHJvdG90eXBlID0gY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcblx0XHRcdGRlZmluZShwcm90bywgJ2NvbnN0cnVjdG9yJyxcblx0XHRcdFx0XHR7IHZhbHVlOiBjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXHRcdFx0aW5qZWN0KGN0b3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuaW5qZWN0LmFwcGx5KGN0b3IsIGFyZ3VtZW50cyk7XG5cdFx0XHRjdG9yLmJhc2UgPSBiYXNlO1xuXHRcdFx0cmV0dXJuIGN0b3I7XG5cdFx0fVxuXHR9LCB0cnVlKS5pbmplY3Qoe1xuXHRcdGluamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0aWYgKHNyYylcblx0XHRcdFx0XHRpbmplY3QodGhpcywgc3JjLCBzcmMuZW51bWVyYWJsZSwgc3JjLmJlYW5zLCBzcmMucHJlc2VydmUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVzID0gY3JlYXRlKHRoaXMpO1xuXHRcdFx0cmV0dXJuIHJlcy5pbmplY3QuYXBwbHkocmVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRlYWNoOiBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRyZXR1cm4gZWFjaCh0aGlzLCBpdGVyLCBiaW5kKTtcblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbihwcm9wcykge1xuXHRcdFx0cmV0dXJuIHNldCh0aGlzLCBwcm9wcyk7XG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0c3RhdGljczoge1xuXHRcdFx0ZWFjaDogZWFjaCxcblx0XHRcdGNyZWF0ZTogY3JlYXRlLFxuXHRcdFx0ZGVmaW5lOiBkZWZpbmUsXG5cdFx0XHRkZXNjcmliZTogZGVzY3JpYmUsXG5cdFx0XHRzZXQ6IHNldCxcblxuXHRcdFx0Y2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRyZXR1cm4gc2V0KG5ldyBvYmouY29uc3RydWN0b3IoKSwgb2JqKTtcblx0XHRcdH0sXG5cblx0XHRcdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHR2YXIgY3RvciA9IG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvcjtcblx0XHRcdFx0cmV0dXJuIGN0b3IgJiYgKGN0b3IgPT09IE9iamVjdCB8fCBjdG9yID09PSBCYXNlXG5cdFx0XHRcdFx0XHR8fCBjdG9yLm5hbWUgPT09ICdPYmplY3QnKTtcblx0XHRcdH0sXG5cblx0XHRcdHBpY2s6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0cmV0dXJuIGEgIT09IHVuZGVmaW5lZCA/IGEgOiBiO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpXG5cdG1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuQmFzZS5pbmplY3Qoe1xuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkICE9IG51bGxcblx0XHRcdD8gICh0aGlzLl9jbGFzcyB8fCAnT2JqZWN0JykgKyAodGhpcy5fbmFtZVxuXHRcdFx0XHQ/IFwiICdcIiArIHRoaXMuX25hbWUgKyBcIidcIlxuXHRcdFx0XHQ6ICcgQCcgKyB0aGlzLl9pZClcblx0XHRcdDogJ3sgJyArIEJhc2UuZWFjaCh0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdGlmICghL15fLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLnB1c2goa2V5ICsgJzogJyArICh0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0XHQ/IEZvcm1hdHRlci5pbnN0YW5jZS5udW1iZXIodmFsdWUpXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ3N0cmluZycgPyBcIidcIiArIHZhbHVlICsgXCInXCIgOiB2YWx1ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBbXSkuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0Z2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xhc3MgfHwgJyc7XG5cdH0sXG5cblx0ZXhwb3J0SlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLmV4cG9ydEpTT04odGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcyk7XG5cdH0sXG5cblx0X3NldDogZnVuY3Rpb24ocHJvcHMsIGV4Y2x1ZGUsIGRvbnRDaGVjaykge1xuXHRcdGlmIChwcm9wcyAmJiAoZG9udENoZWNrIHx8IEJhc2UuaXNQbGFpbk9iamVjdChwcm9wcykpKSB7XG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzLl9maWx0ZXJpbmcgfHwgcHJvcHMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0aWYgKCEoZXhjbHVkZSAmJiBleGNsdWRlW2tleV0pKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gcHJvcHNba2V5XTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXG5cdFx0ZXhwb3J0czoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0XHRcdHZhciByZXMgPSBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuXHRcdFx0XHRuYW1lID0gcmVzLnByb3RvdHlwZS5fY2xhc3M7XG5cdFx0XHRpZiAobmFtZSAmJiAhQmFzZS5leHBvcnRzW25hbWVdKVxuXHRcdFx0XHRCYXNlLmV4cG9ydHNbbmFtZV0gPSByZXM7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcblx0XHRcdGlmIChvYmoxID09PSBvYmoyKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGlmIChvYmoxICYmIG9iajEuZXF1YWxzKVxuXHRcdFx0XHRyZXR1cm4gb2JqMS5lcXVhbHMob2JqMik7XG5cdFx0XHRpZiAob2JqMiAmJiBvYmoyLmVxdWFscylcblx0XHRcdFx0cmV0dXJuIG9iajIuZXF1YWxzKG9iajEpO1xuXHRcdFx0aWYgKG9iajEgJiYgb2JqMlxuXHRcdFx0XHRcdCYmIHR5cGVvZiBvYmoxID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqMiA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqMSkgJiYgQXJyYXkuaXNBcnJheShvYmoyKSkge1xuXHRcdFx0XHRcdHZhciBsZW5ndGggPSBvYmoxLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAobGVuZ3RoICE9PSBvYmoyLmxlbmd0aClcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdFx0XHRcdGlmICghQmFzZS5lcXVhbHMob2JqMVtsZW5ndGhdLCBvYmoyW2xlbmd0aF0pKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqMSksXG5cdFx0XHRcdFx0XHRsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGgpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRcdFx0XHR2YXIga2V5ID0ga2V5c1tsZW5ndGhdO1xuXHRcdFx0XHRcdFx0aWYgKCEob2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpXG5cdFx0XHRcdFx0XHRcdFx0JiYgQmFzZS5lcXVhbHMob2JqMVtrZXldLCBvYmoyW2tleV0pKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0cmVhZDogZnVuY3Rpb24obGlzdCwgc3RhcnQsIG9wdGlvbnMsIGxlbmd0aCkge1xuXHRcdFx0aWYgKHRoaXMgPT09IEJhc2UpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5wZWVrKGxpc3QsIHN0YXJ0KTtcblx0XHRcdFx0bGlzdC5fX2luZGV4Kys7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHZhciBwcm90byA9IHRoaXMucHJvdG90eXBlLFxuXHRcdFx0XHRyZWFkSW5kZXggPSBwcm90by5fcmVhZEluZGV4LFxuXHRcdFx0XHRpbmRleCA9IHN0YXJ0IHx8IHJlYWRJbmRleCAmJiBsaXN0Ll9faW5kZXggfHwgMDtcblx0XHRcdGlmICghbGVuZ3RoKVxuXHRcdFx0XHRsZW5ndGggPSBsaXN0Lmxlbmd0aCAtIGluZGV4O1xuXHRcdFx0dmFyIG9iaiA9IGxpc3RbaW5kZXhdO1xuXHRcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIHRoaXNcblx0XHRcdFx0fHwgb3B0aW9ucyAmJiBvcHRpb25zLnJlYWROdWxsICYmIG9iaiA9PSBudWxsICYmIGxlbmd0aCA8PSAxKSB7XG5cdFx0XHRcdGlmIChyZWFkSW5kZXgpXG5cdFx0XHRcdFx0bGlzdC5fX2luZGV4ID0gaW5kZXggKyAxO1xuXHRcdFx0XHRyZXR1cm4gb2JqICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5jbG9uZSA/IG9iai5jbG9uZSgpIDogb2JqO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gQmFzZS5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuXHRcdFx0aWYgKHJlYWRJbmRleClcblx0XHRcdFx0b2JqLl9fcmVhZCA9IHRydWU7XG5cdFx0XHRvYmogPSBvYmouaW5pdGlhbGl6ZS5hcHBseShvYmosIGluZGV4ID4gMCB8fCBsZW5ndGggPCBsaXN0Lmxlbmd0aFxuXHRcdFx0XHQ/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGluZGV4LCBpbmRleCArIGxlbmd0aClcblx0XHRcdFx0OiBsaXN0KSB8fCBvYmo7XG5cdFx0XHRpZiAocmVhZEluZGV4KSB7XG5cdFx0XHRcdGxpc3QuX19pbmRleCA9IGluZGV4ICsgb2JqLl9fcmVhZDtcblx0XHRcdFx0b2JqLl9fcmVhZCA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdHBlZWs6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0KSB7XG5cdFx0XHRyZXR1cm4gbGlzdFtsaXN0Ll9faW5kZXggPSBzdGFydCB8fCBsaXN0Ll9faW5kZXggfHwgMF07XG5cdFx0fSxcblxuXHRcdHJlbWFpbjogZnVuY3Rpb24obGlzdCkge1xuXHRcdFx0cmV0dXJuIGxpc3QubGVuZ3RoIC0gKGxpc3QuX19pbmRleCB8fCAwKTtcblx0XHR9LFxuXG5cdFx0cmVhZEFsbDogZnVuY3Rpb24obGlzdCwgc3RhcnQsIG9wdGlvbnMpIHtcblx0XHRcdHZhciByZXMgPSBbXSxcblx0XHRcdFx0ZW50cnk7XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQgfHwgMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHJlcy5wdXNoKEFycmF5LmlzQXJyYXkoZW50cnkgPSBsaXN0W2ldKVxuXHRcdFx0XHRcdFx0PyB0aGlzLnJlYWQoZW50cnksIDAsIG9wdGlvbnMpXG5cdFx0XHRcdFx0XHQ6IHRoaXMucmVhZChsaXN0LCBpLCBvcHRpb25zLCAxKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRyZWFkTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUsIHN0YXJ0LCBvcHRpb25zLCBsZW5ndGgpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSksXG5cdFx0XHRcdGhhc09iamVjdCA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG5cdFx0XHRpZiAoaGFzT2JqZWN0KSB7XG5cdFx0XHRcdHZhciBmaWx0ZXJlZCA9IGxpc3QuX2ZpbHRlcmVkO1xuXHRcdFx0XHRpZiAoIWZpbHRlcmVkKSB7XG5cdFx0XHRcdFx0ZmlsdGVyZWQgPSBsaXN0Ll9maWx0ZXJlZCA9IEJhc2UuY3JlYXRlKGxpc3RbMF0pO1xuXHRcdFx0XHRcdGZpbHRlcmVkLl9maWx0ZXJpbmcgPSBsaXN0WzBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZpbHRlcmVkW25hbWVdID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucmVhZChoYXNPYmplY3QgPyBbdmFsdWVdIDogbGlzdCwgc3RhcnQsIG9wdGlvbnMsIGxlbmd0aCk7XG5cdFx0fSxcblxuXHRcdGdldE5hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lKSB7XG5cdFx0XHR2YXIgYXJnID0gbGlzdFswXTtcblx0XHRcdGlmIChsaXN0Ll9oYXNPYmplY3QgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0bGlzdC5faGFzT2JqZWN0ID0gbGlzdC5sZW5ndGggPT09IDEgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZyk7XG5cdFx0XHRpZiAobGlzdC5faGFzT2JqZWN0KVxuXHRcdFx0XHRyZXR1cm4gbmFtZSA/IGFyZ1tuYW1lXSA6IGxpc3QuX2ZpbHRlcmVkIHx8IGFyZztcblx0XHR9LFxuXG5cdFx0aGFzTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUpIHtcblx0XHRcdHJldHVybiAhIXRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSk7XG5cdFx0fSxcblxuXHRcdGlzUGxhaW5WYWx1ZTogZnVuY3Rpb24ob2JqLCBhc1N0cmluZykge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNQbGFpbk9iamVjdChvYmopIHx8IEFycmF5LmlzQXJyYXkob2JqKVxuXHRcdFx0XHRcdHx8IGFzU3RyaW5nICYmIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xuXHRcdH0sXG5cblx0XHRzZXJpYWxpemU6IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucywgY29tcGFjdCwgZGljdGlvbmFyeSkge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRcdHZhciByb290ID0gIWRpY3Rpb25hcnksXG5cdFx0XHRcdHJlcztcblx0XHRcdGlmIChyb290KSB7XG5cdFx0XHRcdG9wdGlvbnMuZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcihvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0XHRcdGRpY3Rpb25hcnkgPSB7XG5cdFx0XHRcdFx0bGVuZ3RoOiAwLFxuXHRcdFx0XHRcdGRlZmluaXRpb25zOiB7fSxcblx0XHRcdFx0XHRyZWZlcmVuY2VzOiB7fSxcblx0XHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKGl0ZW0sIGNyZWF0ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGlkID0gJyMnICsgaXRlbS5faWQsXG5cdFx0XHRcdFx0XHRcdHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF07XG5cdFx0XHRcdFx0XHRpZiAoIXJlZikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCsrO1xuXHRcdFx0XHRcdFx0XHR2YXIgcmVzID0gY3JlYXRlLmNhbGwoaXRlbSksXG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGl0ZW0uX2NsYXNzO1xuXHRcdFx0XHRcdFx0XHRpZiAobmFtZSAmJiByZXNbMF0gIT09IG5hbWUpXG5cdFx0XHRcdFx0XHRcdFx0cmVzLnVuc2hpZnQobmFtZSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVmaW5pdGlvbnNbaWRdID0gcmVzO1xuXHRcdFx0XHRcdFx0XHRyZWYgPSB0aGlzLnJlZmVyZW5jZXNbaWRdID0gW2lkXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9iaiAmJiBvYmouX3NlcmlhbGl6ZSkge1xuXHRcdFx0XHRyZXMgPSBvYmouX3NlcmlhbGl6ZShvcHRpb25zLCBkaWN0aW9uYXJ5KTtcblx0XHRcdFx0dmFyIG5hbWUgPSBvYmouX2NsYXNzO1xuXHRcdFx0XHRpZiAobmFtZSAmJiAhY29tcGFjdCAmJiAhcmVzLl9jb21wYWN0ICYmIHJlc1swXSAhPT0gbmFtZSlcblx0XHRcdFx0XHRyZXMudW5zaGlmdChuYW1lKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdHJlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cmVzW2ldID0gQmFzZS5zZXJpYWxpemUob2JqW2ldLCBvcHRpb25zLCBjb21wYWN0LFxuXHRcdFx0XHRcdFx0XHRkaWN0aW9uYXJ5KTtcblx0XHRcdFx0aWYgKGNvbXBhY3QpXG5cdFx0XHRcdFx0cmVzLl9jb21wYWN0ID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KG9iaikpIHtcblx0XHRcdFx0cmVzID0ge307XG5cdFx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdHJlc1trZXldID0gQmFzZS5zZXJpYWxpemUob2JqW2tleV0sIG9wdGlvbnMsIGNvbXBhY3QsXG5cdFx0XHRcdFx0XHRcdGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHJlcyA9IG9wdGlvbnMuZm9ybWF0dGVyLm51bWJlcihvYmosIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlcyA9IG9iajtcblx0XHRcdH1cblx0XHRcdHJldHVybiByb290ICYmIGRpY3Rpb25hcnkubGVuZ3RoID4gMFxuXHRcdFx0XHRcdD8gW1snZGljdGlvbmFyeScsIGRpY3Rpb25hcnkuZGVmaW5pdGlvbnNdLCByZXNdXG5cdFx0XHRcdFx0OiByZXM7XG5cdFx0fSxcblxuXHRcdGRlc2VyaWFsaXplOiBmdW5jdGlvbihqc29uLCBjcmVhdGUsIF9kYXRhLCBfaXNEaWN0aW9uYXJ5KSB7XG5cdFx0XHR2YXIgcmVzID0ganNvbixcblx0XHRcdFx0aXNSb290ID0gIV9kYXRhO1xuXHRcdFx0X2RhdGEgPSBfZGF0YSB8fCB7fTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG5cdFx0XHRcdHZhciB0eXBlID0ganNvblswXSxcblx0XHRcdFx0XHRpc0RpY3Rpb25hcnkgPSB0eXBlID09PSAnZGljdGlvbmFyeSc7XG5cdFx0XHRcdGlmIChqc29uLmxlbmd0aCA9PSAxICYmIC9eIy8udGVzdCh0eXBlKSlcblx0XHRcdFx0XHRyZXR1cm4gX2RhdGEuZGljdGlvbmFyeVt0eXBlXTtcblx0XHRcdFx0dHlwZSA9IEJhc2UuZXhwb3J0c1t0eXBlXTtcblx0XHRcdFx0cmVzID0gW107XG5cdFx0XHRcdGlmIChfaXNEaWN0aW9uYXJ5KVxuXHRcdFx0XHRcdF9kYXRhLmRpY3Rpb25hcnkgPSByZXM7XG5cdFx0XHRcdGZvciAodmFyIGkgPSB0eXBlID8gMSA6IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRyZXMucHVzaChCYXNlLmRlc2VyaWFsaXplKGpzb25baV0sIGNyZWF0ZSwgX2RhdGEsXG5cdFx0XHRcdFx0XHRcdGlzRGljdGlvbmFyeSkpO1xuXHRcdFx0XHRpZiAodHlwZSkge1xuXHRcdFx0XHRcdHZhciBhcmdzID0gcmVzO1xuXHRcdFx0XHRcdGlmIChjcmVhdGUpIHtcblx0XHRcdFx0XHRcdHJlcyA9IGNyZWF0ZSh0eXBlLCBhcmdzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzID0gQmFzZS5jcmVhdGUodHlwZS5wcm90b3R5cGUpO1xuXHRcdFx0XHRcdFx0dHlwZS5hcHBseShyZXMsIGFyZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoanNvbikpIHtcblx0XHRcdFx0cmVzID0ge307XG5cdFx0XHRcdGlmIChfaXNEaWN0aW9uYXJ5KVxuXHRcdFx0XHRcdF9kYXRhLmRpY3Rpb25hcnkgPSByZXM7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBqc29uKVxuXHRcdFx0XHRcdHJlc1trZXldID0gQmFzZS5kZXNlcmlhbGl6ZShqc29uW2tleV0sIGNyZWF0ZSwgX2RhdGEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGlzUm9vdCAmJiBqc29uICYmIGpzb24ubGVuZ3RoICYmIGpzb25bMF1bMF0gPT09ICdkaWN0aW9uYXJ5J1xuXHRcdFx0XHRcdD8gcmVzWzFdXG5cdFx0XHRcdFx0OiByZXM7XG5cdFx0fSxcblxuXHRcdGV4cG9ydEpTT046IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuXHRcdFx0dmFyIGpzb24gPSBCYXNlLnNlcmlhbGl6ZShvYmosIG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA9PT0gZmFsc2Vcblx0XHRcdFx0XHQ/IGpzb25cblx0XHRcdFx0XHQ6IEpTT04uc3RyaW5naWZ5KGpzb24pO1xuXHRcdH0sXG5cblx0XHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uLCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiBCYXNlLmRlc2VyaWFsaXplKFxuXHRcdFx0XHRcdHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKHR5cGUsIGFyZ3MpIHtcblx0XHRcdFx0XHRcdHZhciBvYmogPSB0YXJnZXQgJiYgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSB0eXBlXG5cdFx0XHRcdFx0XHRcdFx0PyB0YXJnZXRcblx0XHRcdFx0XHRcdFx0XHQ6IEJhc2UuY3JlYXRlKHR5cGUucHJvdG90eXBlKSxcblx0XHRcdFx0XHRcdFx0aXNUYXJnZXQgPSBvYmogPT09IHRhcmdldDtcblx0XHRcdFx0XHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBvYmogaW5zdGFuY2VvZiBJdGVtXG5cdFx0XHRcdFx0XHRcdFx0JiYgKGlzVGFyZ2V0IHx8ICEob2JqIGluc3RhbmNlb2YgTGF5ZXIpKSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYXJnID0gYXJnc1swXTtcblx0XHRcdFx0XHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcpKVxuXHRcdFx0XHRcdFx0XHRcdGFyZy5pbnNlcnQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHR5cGUuYXBwbHkob2JqLCBhcmdzKTtcblx0XHRcdFx0XHRcdGlmIChpc1RhcmdldClcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHNwbGljZTogZnVuY3Rpb24obGlzdCwgaXRlbXMsIGluZGV4LCByZW1vdmUpIHtcblx0XHRcdHZhciBhbW91bnQgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGgsXG5cdFx0XHRcdGFwcGVuZCA9IGluZGV4ID09PSB1bmRlZmluZWQ7XG5cdFx0XHRpbmRleCA9IGFwcGVuZCA/IGxpc3QubGVuZ3RoIDogaW5kZXg7XG5cdFx0XHRpZiAoaW5kZXggPiBsaXN0Lmxlbmd0aClcblx0XHRcdFx0aW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspXG5cdFx0XHRcdGl0ZW1zW2ldLl9pbmRleCA9IGluZGV4ICsgaTtcblx0XHRcdGlmIChhcHBlbmQpIHtcblx0XHRcdFx0bGlzdC5wdXNoLmFwcGx5KGxpc3QsIGl0ZW1zKTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBbaW5kZXgsIHJlbW92ZV07XG5cdFx0XHRcdGlmIChpdGVtcylcblx0XHRcdFx0XHRhcmdzLnB1c2guYXBwbHkoYXJncywgaXRlbXMpO1xuXHRcdFx0XHR2YXIgcmVtb3ZlZCA9IGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIGFyZ3MpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHJlbW92ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHJlbW92ZWRbaV0uX2luZGV4ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRsaXN0W2ldLl9pbmRleCA9IGk7XG5cdFx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjYXBpdGFsaXplOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvXFxiW2Etel0vZywgZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0cmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Y2FtZWxpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKGFsbCwgY2hyKSB7XG5cdFx0XHRcdHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRoeXBoZW5hdGU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBFbWl0dGVyID0ge1xuXHRvbjogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdHRoaXMub24oa2V5LCB2YWx1ZSk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHR5cGVzID0gdGhpcy5fZXZlbnRUeXBlcyxcblx0XHRcdFx0ZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcblx0XHRcdFx0aGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdFx0XHRoYW5kbGVycyA9IGhhbmRsZXJzW3R5cGVdID0gaGFuZGxlcnNbdHlwZV0gfHwgW107XG5cdFx0XHRpZiAoaGFuZGxlcnMuaW5kZXhPZihmdW5jKSA9PT0gLTEpIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaChmdW5jKTtcblx0XHRcdFx0aWYgKGVudHJ5ICYmIGVudHJ5Lmluc3RhbGwgJiYgaGFuZGxlcnMubGVuZ3RoID09IDEpXG5cdFx0XHRcdFx0ZW50cnkuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvZmY6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHR0aGlzLm9mZihrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgdHlwZXMgPSB0aGlzLl9ldmVudFR5cGVzLFxuXHRcdFx0ZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcblx0XHRcdGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSxcblx0XHRcdGluZGV4O1xuXHRcdGlmIChoYW5kbGVycykge1xuXHRcdFx0aWYgKCFmdW5jIHx8IChpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YoZnVuYykpICE9PSAtMVxuXHRcdFx0XHRcdCYmIGhhbmRsZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRpZiAoZW50cnkgJiYgZW50cnkudW5pbnN0YWxsKVxuXHRcdFx0XHRcdGVudHJ5LnVuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fY2FsbGJhY2tzW3R5cGVdO1xuXHRcdFx0fSBlbHNlIGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b25jZTogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdHJldHVybiB0aGlzLm9uKHR5cGUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5vZmYodHlwZSwgZnVuYyk7XG5cdFx0fSk7XG5cdH0sXG5cblx0ZW1pdDogZnVuY3Rpb24odHlwZSwgZXZlbnQpIHtcblx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdO1xuXHRcdGlmICghaGFuZGxlcnMpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFx0aGFuZGxlcnMgPSBoYW5kbGVycy5zbGljZSgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoaGFuZGxlcnNbaV0uYXBwbHkodGhpcywgYXJncykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmIChldmVudCAmJiBldmVudC5zdG9wKVxuXHRcdFx0XHRcdGV2ZW50LnN0b3AoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHJlc3BvbmRzOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0cmV0dXJuICEhKHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV0pO1xuXHR9LFxuXG5cdGF0dGFjaDogJyNvbicsXG5cdGRldGFjaDogJyNvZmYnLFxuXHRmaXJlOiAnI2VtaXQnLFxuXG5cdF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbihpbnN0YWxsKSB7XG5cdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzLFxuXHRcdFx0a2V5ID0gaW5zdGFsbCA/ICdpbnN0YWxsJyA6ICd1bmluc3RhbGwnO1xuXHRcdGZvciAodmFyIHR5cGUgaW4gaGFuZGxlcnMpIHtcblx0XHRcdGlmIChoYW5kbGVyc1t0eXBlXS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHZhciB0eXBlcyA9IHRoaXMuX2V2ZW50VHlwZXMsXG5cdFx0XHRcdFx0ZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcblx0XHRcdFx0XHRmdW5jID0gZW50cnkgJiYgZW50cnlba2V5XTtcblx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0ZnVuYy5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbiBpbmplY3Qoc3JjKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gc3JjLl9ldmVudHM7XG5cdFx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRcdHZhciB0eXBlcyA9IHt9O1xuXHRcdFx0XHRCYXNlLmVhY2goZXZlbnRzLCBmdW5jdGlvbihlbnRyeSwga2V5KSB7XG5cdFx0XHRcdFx0dmFyIGlzU3RyaW5nID0gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyxcblx0XHRcdFx0XHRcdG5hbWUgPSBpc1N0cmluZyA/IGVudHJ5IDoga2V5LFxuXHRcdFx0XHRcdFx0cGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdFx0XHRcdHR5cGUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHR5cGVzW3R5cGVdID0gaXNTdHJpbmcgPyB7fSA6IGVudHJ5O1xuXHRcdFx0XHRcdG5hbWUgPSAnXycgKyBuYW1lO1xuXHRcdFx0XHRcdHNyY1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHNyY1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24oZnVuYykge1xuXHRcdFx0XHRcdFx0dmFyIHByZXYgPSB0aGlzW25hbWVdO1xuXHRcdFx0XHRcdFx0aWYgKHByZXYpXG5cdFx0XHRcdFx0XHRcdHRoaXMub2ZmKHR5cGUsIHByZXYpO1xuXHRcdFx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0XHRcdHRoaXMub24odHlwZSwgZnVuYyk7XG5cdFx0XHRcdFx0XHR0aGlzW25hbWVdID0gZnVuYztcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0c3JjLl9ldmVudFR5cGVzID0gdHlwZXM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5qZWN0LmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBQYXBlclNjb3BlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXBlclNjb3BlJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXBlclNjb3BlKCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0XHR0aGlzLnNldHRpbmdzID0gbmV3IEJhc2Uoe1xuXHRcdFx0YXBwbHlNYXRyaXg6IHRydWUsXG5cdFx0XHRoYW5kbGVTaXplOiA0LFxuXHRcdFx0aGl0VG9sZXJhbmNlOiAwXG5cdFx0fSk7XG5cdFx0dGhpcy5wcm9qZWN0ID0gbnVsbDtcblx0XHR0aGlzLnByb2plY3RzID0gW107XG5cdFx0dGhpcy50b29scyA9IFtdO1xuXHRcdHRoaXMucGFsZXR0ZXMgPSBbXTtcblx0XHR0aGlzLl9pZCA9IFBhcGVyU2NvcGUuX2lkKys7XG5cdFx0UGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0dmFyIHByb3RvID0gUGFwZXJTY29wZS5wcm90b3R5cGU7XG5cdFx0aWYgKCF0aGlzLnN1cHBvcnQpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRcdFx0cHJvdG8uc3VwcG9ydCA9IHtcblx0XHRcdFx0bmF0aXZlRGFzaDogJ3NldExpbmVEYXNoJyBpbiBjdHggfHwgJ21vekRhc2gnIGluIGN0eCxcblx0XHRcdFx0bmF0aXZlQmxlbmRNb2RlczogQmxlbmRNb2RlLm5hdGl2ZU1vZGVzXG5cdFx0XHR9O1xuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5icm93c2VyKSB7XG5cdFx0XHR2YXIgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdHBsYXRmb3JtID0gKC8od2luKS8uZXhlYyhhZ2VudClcblx0XHRcdFx0XHRcdHx8IC8obWFjKS8uZXhlYyhhZ2VudClcblx0XHRcdFx0XHRcdHx8IC8obGludXgpLy5leGVjKGFnZW50KVxuXHRcdFx0XHRcdFx0fHwgW10pWzBdLFxuXHRcdFx0XHRicm93c2VyID0gcHJvdG8uYnJvd3NlciA9IHsgcGxhdGZvcm06IHBsYXRmb3JtIH07XG5cdFx0XHRpZiAocGxhdGZvcm0pXG5cdFx0XHRcdGJyb3dzZXJbcGxhdGZvcm1dID0gdHJ1ZTtcblx0XHRcdGFnZW50LnJlcGxhY2UoXG5cdFx0XHRcdC8ob3BlcmF8Y2hyb21lfHNhZmFyaXx3ZWJraXR8ZmlyZWZveHxtc2llfHRyaWRlbnR8YXRvbSlcXC8/XFxzKihbLlxcZF0rKSg/Oi4qdmVyc2lvblxcLyhbLlxcZF0rKSk/KD86LipydlxcOihbLlxcZF0rKSk/L2csXG5cdFx0XHRcdGZ1bmN0aW9uKGFsbCwgbiwgdjEsIHYyLCBydikge1xuXHRcdFx0XHRcdGlmICghYnJvd3Nlci5jaHJvbWUpIHtcblx0XHRcdFx0XHRcdHZhciB2ID0gbiA9PT0gJ29wZXJhJyA/IHYyIDogdjE7XG5cdFx0XHRcdFx0XHRpZiAobiA9PT0gJ3RyaWRlbnQnKSB7XG5cdFx0XHRcdFx0XHRcdHYgPSBydjtcblx0XHRcdFx0XHRcdFx0biA9ICdtc2llJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyb3dzZXIudmVyc2lvbiA9IHY7XG5cdFx0XHRcdFx0XHRicm93c2VyLnZlcnNpb25OdW1iZXIgPSBwYXJzZUZsb2F0KHYpO1xuXHRcdFx0XHRcdFx0YnJvd3Nlci5uYW1lID0gbjtcblx0XHRcdFx0XHRcdGJyb3dzZXJbbl0gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHRcdGlmIChicm93c2VyLmNocm9tZSlcblx0XHRcdFx0ZGVsZXRlIGJyb3dzZXIud2Via2l0O1xuXHRcdFx0aWYgKGJyb3dzZXIuYXRvbSlcblx0XHRcdFx0ZGVsZXRlIGJyb3dzZXIuY2hyb21lO1xuXHRcdH1cblx0fSxcblxuXHR2ZXJzaW9uOiAnMC45LjI0JyxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0ICYmIHRoaXMucHJvamVjdC5nZXRWaWV3KCk7XG5cdH0sXG5cblx0Z2V0UGFwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGV4ZWN1dGU6IGZ1bmN0aW9uKGNvZGUsIHVybCwgb3B0aW9ucykge1xuXHRcdHBhcGVyLlBhcGVyU2NyaXB0LmV4ZWN1dGUoY29kZSwgdGhpcywgdXJsLCBvcHRpb25zKTtcblx0XHRWaWV3LnVwZGF0ZUZvY3VzKCk7XG5cdH0sXG5cblx0aW5zdGFsbDogZnVuY3Rpb24oc2NvcGUpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0QmFzZS5lYWNoKFsncHJvamVjdCcsICd2aWV3JywgJ3Rvb2wnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRCYXNlLmRlZmluZShzY29wZSwga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhhdFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcylcblx0XHRcdGlmICghL15fLy50ZXN0KGtleSkgJiYgdGhpc1trZXldKVxuXHRcdFx0XHRzY29wZVtrZXldID0gdGhpc1trZXldO1xuXHR9LFxuXG5cdHNldHVwOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMucHJvamVjdCA9IG5ldyBQcm9qZWN0KGVsZW1lbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXM7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLnByb2plY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dGhpcy5wcm9qZWN0c1tpXS5yZW1vdmUoKTtcblx0XHRmb3IgKHZhciBpID0gdGhpcy50b29scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMudG9vbHNbaV0ucmVtb3ZlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMucGFsZXR0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0aGlzLnBhbGV0dGVzW2ldLnJlbW92ZSgpO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jbGVhcigpO1xuXHRcdGRlbGV0ZSBQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdO1xuXHR9LFxuXG5cdHN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGUobmFtZSkge1xuXHRcdFx0bmFtZSArPSAnQXR0cmlidXRlJztcblx0XHRcdHJldHVybiBmdW5jdGlvbihlbCwgYXR0cikge1xuXHRcdFx0XHRyZXR1cm4gZWxbbmFtZV0oYXR0cikgfHwgZWxbbmFtZV0oJ2RhdGEtcGFwZXItJyArIGF0dHIpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0X3Njb3Blczoge30sXG5cdFx0XHRfaWQ6IDAsXG5cblx0XHRcdGdldDogZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3Njb3Blc1tpZF0gfHwgbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdGdldEF0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdnZXQnKSxcblx0XHRcdGhhc0F0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdoYXMnKVxuXHRcdH07XG5cdH1cbn0pO1xuXG52YXIgUGFwZXJTY29wZUl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oYWN0aXZhdGUpIHtcblx0XHR0aGlzLl9zY29wZSA9IHBhcGVyO1xuXHRcdHRoaXMuX2luZGV4ID0gdGhpcy5fc2NvcGVbdGhpcy5fbGlzdF0ucHVzaCh0aGlzKSAtIDE7XG5cdFx0aWYgKGFjdGl2YXRlIHx8ICF0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdKVxuXHRcdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3Njb3BlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBwcmV2ID0gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXTtcblx0XHRpZiAocHJldiAmJiBwcmV2ICE9PSB0aGlzKVxuXHRcdFx0cHJldi5lbWl0KCdkZWFjdGl2YXRlJyk7XG5cdFx0dGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9IHRoaXM7XG5cdFx0dGhpcy5lbWl0KCdhY3RpdmF0ZScsIHByZXYpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGlzQWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9PT0gdGhpcztcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9pbmRleCA9PSBudWxsKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdEJhc2Uuc3BsaWNlKHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG5cdFx0aWYgKHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT0gdGhpcylcblx0XHRcdHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSBudWxsO1xuXHRcdHRoaXMuX3Njb3BlID0gbnVsbDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBGb3JtYXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXHRcdHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDU7XG5cdFx0dGhpcy5tdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHRoaXMucHJlY2lzaW9uKTtcblx0fSxcblxuXHRudW1iZXI6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbCAqIHRoaXMubXVsdGlwbGllcikgLyB0aGlzLm11bHRpcGxpZXI7XG5cdH0sXG5cblx0cGFpcjogZnVuY3Rpb24odmFsMSwgdmFsMiwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbDEpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsMik7XG5cdH0sXG5cblx0cG9pbnQ6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbC54KSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbC55KTtcblx0fSxcblxuXHRzaXplOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwud2lkdGgpICsgKHNlcGFyYXRvciB8fCAnLCcpXG5cdFx0XHRcdCsgdGhpcy5udW1iZXIodmFsLmhlaWdodCk7XG5cdH0sXG5cblx0cmVjdGFuZ2xlOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLnBvaW50KHZhbCwgc2VwYXJhdG9yKSArIChzZXBhcmF0b3IgfHwgJywnKVxuXHRcdFx0XHQrIHRoaXMuc2l6ZSh2YWwsIHNlcGFyYXRvcik7XG5cdH1cbn0pO1xuXG5Gb3JtYXR0ZXIuaW5zdGFuY2UgPSBuZXcgRm9ybWF0dGVyKCk7XG5cbnZhciBOdW1lcmljYWwgPSBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGFic2Npc3NhcyA9IFtcblx0XHRbICAwLjU3NzM1MDI2OTE4OTYyNTc2NDUwOTE0ODhdLFxuXHRcdFswLDAuNzc0NTk2NjY5MjQxNDgzMzc3MDM1ODUzMV0sXG5cdFx0WyAgMC4zMzk5ODEwNDM1ODQ4NTYyNjQ4MDI2NjU4LDAuODYxMTM2MzExNTk0MDUyNTc1MjIzOTQ2NV0sXG5cdFx0WzAsMC41Mzg0NjkzMTAxMDU2ODMwOTEwMzYzMTQ0LDAuOTA2MTc5ODQ1OTM4NjYzOTkyNzk3NjI2OV0sXG5cdFx0WyAgMC4yMzg2MTkxODYwODMxOTY5MDg2MzA1MDE3LDAuNjYxMjA5Mzg2NDY2MjY0NTEzNjYxMzk5NiwwLjkzMjQ2OTUxNDIwMzE1MjAyNzgxMjMwMTZdLFxuXHRcdFswLDAuNDA1ODQ1MTUxMzc3Mzk3MTY2OTA2NjA2NCwwLjc0MTUzMTE4NTU5OTM5NDQzOTg2Mzg2NDgsMC45NDkxMDc5MTIzNDI3NTg1MjQ1MjYxODk3XSxcblx0XHRbICAwLjE4MzQzNDY0MjQ5NTY0OTgwNDkzOTQ3NjEsMC41MjU1MzI0MDk5MTYzMjg5ODU4MTc3MzkwLDAuNzk2NjY2NDc3NDEzNjI2NzM5NTkxNTUzOSwwLjk2MDI4OTg1NjQ5NzUzNjIzMTY4MzU2MDldLFxuXHRcdFswLDAuMzI0MjUzNDIzNDAzODA4OTI5MDM4NTM4MCwwLjYxMzM3MTQzMjcwMDU5MDM5NzMwODcwMjAsMC44MzYwMzExMDczMjY2MzU3OTQyOTk0Mjk4LDAuOTY4MTYwMjM5NTA3NjI2MDg5ODM1NTc2Ml0sXG5cdFx0WyAgMC4xNDg4NzQzMzg5ODE2MzEyMTA4ODQ4MjYwLDAuNDMzMzk1Mzk0MTI5MjQ3MTkwNzk5MjY1OSwwLjY3OTQwOTU2ODI5OTAyNDQwNjIzNDMyNzQsMC44NjUwNjMzNjY2ODg5ODQ1MTA3MzIwOTY3LDAuOTczOTA2NTI4NTE3MTcxNzIwMDc3OTY0MF0sXG5cdFx0WzAsMC4yNjk1NDMxNTU5NTIzNDQ5NzIzMzE1MzIwLDAuNTE5MDk2MTI5MjA2ODExODE1OTI1NzI1NywwLjczMDE1MjAwNTU3NDA0OTMyNDA5MzQxNjMsMC44ODcwNjI1OTk3NjgwOTUyOTkwNzUxNTc4LDAuOTc4MjI4NjU4MTQ2MDU2OTkyODAzOTM4MF0sXG5cdFx0WyAgMC4xMjUyMzM0MDg1MTE0Njg5MTU0NzI0NDE0LDAuMzY3ODMxNDk4OTk4MTgwMTkzNzUyNjkxNSwwLjU4NzMxNzk1NDI4NjYxNzQ0NzI5NjcwMjQsMC43Njk5MDI2NzQxOTQzMDQ2ODcwMzY4OTM4LDAuOTA0MTE3MjU2MzcwNDc0ODU2Njc4NDY1OSwwLjk4MTU2MDYzNDI0NjcxOTI1MDY5MDU0OTFdLFxuXHRcdFswLDAuMjMwNDU4MzE1OTU1MTM0Nzk0MDY1NTI4MSwwLjQ0ODQ5Mjc1MTAzNjQ0Njg1Mjg3NzkxMjksMC42NDIzNDkzMzk0NDAzNDAyMjA2NDM5ODQ2LDAuODAxNTc4MDkwNzMzMzA5OTEyNzk0MjA2NSwwLjkxNzU5ODM5OTIyMjk3Nzk2NTIwNjU0NzgsMC45ODQxODMwNTQ3MTg1ODgxNDk0NzI4Mjk0XSxcblx0XHRbICAwLjEwODA1NDk0ODcwNzM0MzY2MjA2NjI0NDcsMC4zMTkxMTIzNjg5Mjc4ODk3NjA0MzU2NzE4LDAuNTE1MjQ4NjM2MzU4MTU0MDkxOTY1MjkwNywwLjY4NzI5MjkwNDgxMTY4NTQ3MDE0ODAxOTgsMC44MjcyMDEzMTUwNjk3NjQ5OTMxODk3OTQ3LDAuOTI4NDM0ODgzNjYzNTczNTE3MzM2MzkxMSwwLjk4NjI4MzgwODY5NjgxMjMzODg0MTU5NzNdLFxuXHRcdFswLDAuMjAxMTk0MDkzOTk3NDM0NTIyMzAwNjI4MywwLjM5NDE1MTM0NzA3NzU2MzM2OTg5NzIwNzQsMC41NzA5NzIxNzI2MDg1Mzg4NDc1MzcyMjY3LDAuNzI0NDE3NzMxMzYwMTcwMDQ3NDE2MTg2MSwwLjg0ODIwNjU4MzQxMDQyNzIxNjIwMDY0ODMsMC45MzcyNzMzOTI0MDA3MDU5MDQzMDc3NTg5LDAuOTg3OTkyNTE4MDIwNDg1NDI4NDg5NTY1N10sXG5cdFx0WyAgMC4wOTUwMTI1MDk4Mzc2Mzc0NDAxODUzMTkzLDAuMjgxNjAzNTUwNzc5MjU4OTEzMjMwNDYwNSwwLjQ1ODAxNjc3NzY1NzIyNzM4NjM0MjQxOTQsMC42MTc4NzYyNDQ0MDI2NDM3NDg0NDY2NzE4LDAuNzU1NDA0NDA4MzU1MDAzMDMzODk1MTAxMiwwLjg2NTYzMTIwMjM4NzgzMTc0Mzg4MDQ2NzksMC45NDQ1NzUwMjMwNzMyMzI1NzYwNzc5ODg0LDAuOTg5NDAwOTM0OTkxNjQ5OTMyNTk2MTU0Ml1cblx0XTtcblxuXHR2YXIgd2VpZ2h0cyA9IFtcblx0XHRbMV0sXG5cdFx0WzAuODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwwLjU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTZdLFxuXHRcdFswLjY1MjE0NTE1NDg2MjU0NjE0MjYyNjkzNjEsMC4zNDc4NTQ4NDUxMzc0NTM4NTczNzMwNjM5XSxcblx0XHRbMC41Njg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNDc4NjI4NjcwNDk5MzY2NDY4MDQxMjkxNSwwLjIzNjkyNjg4NTA1NjE4OTA4NzUxNDI2NDBdLFxuXHRcdFswLjQ2NzkxMzkzNDU3MjY5MTA0NzM4OTg3MDMsMC4zNjA3NjE1NzMwNDgxMzg2MDc1Njk4MzM1LDAuMTcxMzI0NDkyMzc5MTcwMzQ1MDQwMjk2MV0sXG5cdFx0WzAuNDE3OTU5MTgzNjczNDY5Mzg3NzU1MTAyMCwwLjM4MTgzMDA1MDUwNTExODk0NDk1MDM2OTgsMC4yNzk3MDUzOTE0ODkyNzY2Njc5MDE0Njc4LDAuMTI5NDg0OTY2MTY4ODY5NjkzMjcwNjExNF0sXG5cdFx0WzAuMzYyNjgzNzgzMzc4MzYxOTgyOTY1MTUwNCwwLjMxMzcwNjY0NTg3Nzg4NzI4NzMzNzk2MjIsMC4yMjIzODEwMzQ0NTMzNzQ0NzA1NDQzNTYwLDAuMTAxMjI4NTM2MjkwMzc2MjU5MTUyNTMxNF0sXG5cdFx0WzAuMzMwMjM5MzU1MDAxMjU5NzYzMTY0NTI1MSwwLjMxMjM0NzA3NzA0MDAwMjg0MDA2ODYzMDQsMC4yNjA2MTA2OTY0MDI5MzU0NjIzMTg3NDI5LDAuMTgwNjQ4MTYwNjk0ODU3NDA0MDU4NDcyMCwwLjA4MTI3NDM4ODM2MTU3NDQxMTk3MTg5MjJdLFxuXHRcdFswLjI5NTUyNDIyNDcxNDc1Mjg3MDE3Mzg5MzAsMC4yNjkyNjY3MTkzMDk5OTYzNTUwOTEyMjY5LDAuMjE5MDg2MzYyNTE1OTgyMDQzOTk1NTM0OSwwLjE0OTQ1MTM0OTE1MDU4MDU5MzE0NTc3NjMsMC4wNjY2NzEzNDQzMDg2ODgxMzc1OTM1Njg4XSxcblx0XHRbMC4yNzI5MjUwODY3Nzc5MDA2MzA3MTQ0ODM1LDAuMjYyODA0NTQ0NTEwMjQ2NjYyMTgwNjg4OSwwLjIzMzE5Mzc2NDU5MTk5MDQ3OTkxODUyMzcsMC4xODYyOTAyMTA5Mjc3MzQyNTE0MjYwOTc2LDAuMTI1NTgwMzY5NDY0OTA0NjI0NjM0Njk0MywwLjA1NTY2ODU2NzExNjE3MzY2NjQ4Mjc1MzddLFxuXHRcdFswLjI0OTE0NzA0NTgxMzQwMjc4NTAwMDU2MjQsMC4yMzM0OTI1MzY1MzgzNTQ4MDg3NjA4NDk5LDAuMjAzMTY3NDI2NzIzMDY1OTIxNzQ5MDY0NSwwLjE2MDA3ODMyODU0MzM0NjIyNjMzNDY1MjUsMC4xMDY5MzkzMjU5OTUzMTg0MzA5NjAyNTQ3LDAuMDQ3MTc1MzM2Mzg2NTExODI3MTk0NjE2MF0sXG5cdFx0WzAuMjMyNTUxNTUzMjMwODczOTEwMTk0NTg5NSwwLjIyNjI4MzE4MDI2Mjg5NzIzODQxMjA5MDIsMC4yMDc4MTYwNDc1MzY4ODg1MDIzMTI1MjMyLDAuMTc4MTQ1OTgwNzYxOTQ1NzM4MjgwMDQ2NywwLjEzODg3MzUxMDIxOTc4NzIzODQ2MzYwMTgsMC4wOTIxMjE0OTk4Mzc3Mjg0NDc5MTQ0MjE4LDAuMDQwNDg0MDA0NzY1MzE1ODc5NTIwMDIxNl0sXG5cdFx0WzAuMjE1MjYzODUzNDYzMTU3NzkwMTk1ODc2NCwwLjIwNTE5ODQ2MzcyMTI5NTYwMzk2NTkyNDEsMC4xODU1MzgzOTc0Nzc5Mzc4MTM3NDE3MTY2LDAuMTU3MjAzMTY3MTU4MTkzNTM0NTY5NjAxOSwwLjEyMTUxODU3MDY4NzkwMzE4NDY4OTQxNDgsMC4wODAxNTgwODcxNTk3NjAyMDk4MDU2MzMzLDAuMDM1MTE5NDYwMzMxNzUxODYzMDMxODMyOV0sXG5cdFx0WzAuMjAyNTc4MjQxOTI1NTYxMjcyODgwNjIwMiwwLjE5ODQzMTQ4NTMyNzExMTU3NjQ1NjExODMsMC4xODYxNjEwMDAwMTU1NjIyMTEwMjY4MDA2LDAuMTY2MjY5MjA1ODE2OTkzOTMzNTUzMjAwOSwwLjEzOTU3MDY3NzkyNjE1NDMxNDQ0NzgwNDgsMC4xMDcxNTkyMjA0NjcxNzE5MzUwMTE4Njk1LDAuMDcwMzY2MDQ3NDg4MTA4MTI0NzA5MjY3NCwwLjAzMDc1MzI0MTk5NjExNzI2ODM1NDYyODRdLFxuXHRcdFswLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcsMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM3LDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMSwwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTcsMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYzLDAuMDk1MTU4NTExNjgyNDkyNzg0ODA5OTI1MSwwLjA2MjI1MzUyMzkzODY0Nzg5Mjg2Mjg0MzgsMC4wMjcxNTI0NTk0MTE3NTQwOTQ4NTE3ODA2XVxuXHRdO1xuXG5cdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRzcXJ0ID0gTWF0aC5zcXJ0LFxuXHRcdHBvdyA9IE1hdGgucG93LFxuXHRcdFRPTEVSQU5DRSA9IDFlLTYsXG5cdFx0RVBTSUxPTiA9IDFlLTEyLFxuXHRcdE1BQ0hJTkVfRVBTSUxPTiA9IDEuMTJlLTE2O1xuXG5cdHJldHVybiB7XG5cdFx0VE9MRVJBTkNFOiBUT0xFUkFOQ0UsXG5cdFx0RVBTSUxPTjogRVBTSUxPTixcblx0XHRNQUNISU5FX0VQU0lMT046IE1BQ0hJTkVfRVBTSUxPTixcblx0XHRLQVBQQTogNCAqIChzcXJ0KDIpIC0gMSkgLyAzLFxuXG5cdFx0aXNaZXJvOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdHJldHVybiBhYnModmFsKSA8PSBFUFNJTE9OO1xuXHRcdH0sXG5cblx0XHRpbnRlZ3JhdGU6IGZ1bmN0aW9uKGYsIGEsIGIsIG4pIHtcblx0XHRcdHZhciB4ID0gYWJzY2lzc2FzW24gLSAyXSxcblx0XHRcdFx0dyA9IHdlaWdodHNbbiAtIDJdLFxuXHRcdFx0XHRBID0gKGIgLSBhKSAqIDAuNSxcblx0XHRcdFx0QiA9IEEgKyBhLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bSA9IChuICsgMSkgPj4gMSxcblx0XHRcdFx0c3VtID0gbiAmIDEgPyB3W2krK10gKiBmKEIpIDogMDtcblx0XHRcdHdoaWxlIChpIDwgbSkge1xuXHRcdFx0XHR2YXIgQXggPSBBICogeFtpXTtcblx0XHRcdFx0c3VtICs9IHdbaSsrXSAqIChmKEIgKyBBeCkgKyBmKEIgLSBBeCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEEgKiBzdW07XG5cdFx0fSxcblxuXHRcdGZpbmRSb290OiBmdW5jdGlvbihmLCBkZiwgeCwgYSwgYiwgbiwgdG9sZXJhbmNlKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgZnggPSBmKHgpLFxuXHRcdFx0XHRcdGR4ID0gZnggLyBkZih4KSxcblx0XHRcdFx0XHRueCA9IHggLSBkeDtcblx0XHRcdFx0aWYgKGFicyhkeCkgPCB0b2xlcmFuY2UpXG5cdFx0XHRcdFx0cmV0dXJuIG54O1xuXHRcdFx0XHRpZiAoZnggPiAwKSB7XG5cdFx0XHRcdFx0YiA9IHg7XG5cdFx0XHRcdFx0eCA9IG54IDw9IGEgPyAoYSArIGIpICogMC41IDogbng7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YSA9IHg7XG5cdFx0XHRcdFx0eCA9IG54ID49IGIgPyAoYSArIGIpICogMC41IDogbng7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB4O1xuXHRcdH0sXG5cblx0XHRzb2x2ZVF1YWRyYXRpYzogZnVuY3Rpb24oYSwgYiwgYywgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0XHR2YXIgY291bnQgPSAwLFxuXHRcdFx0XHR4MSwgeDIgPSBJbmZpbml0eSxcblx0XHRcdFx0QiA9IGIsXG5cdFx0XHRcdEQ7XG5cdFx0XHRiIC89IDI7XG5cdFx0XHREID0gYiAqIGIgLSBhICogYztcblx0XHRcdGlmIChEICE9PSAwICYmIGFicyhEKSA8IE1BQ0hJTkVfRVBTSUxPTikge1xuXHRcdFx0XHR2YXIgZ21DID0gcG93KGFicyhhICogYiAqIGMpLCAxIC8gMyk7XG5cdFx0XHRcdGlmIChnbUMgPCAxZS04KSB7XG5cdFx0XHRcdFx0dmFyIG11bHQgPSBwb3coMTAsIGFicyhcblx0XHRcdFx0XHRcdE1hdGguZmxvb3IoTWF0aC5sb2coZ21DKSAqIE1hdGguTE9HMTBFKSkpO1xuXHRcdFx0XHRcdGlmICghaXNGaW5pdGUobXVsdCkpXG5cdFx0XHRcdFx0XHRtdWx0ID0gMDtcblx0XHRcdFx0XHRhICo9IG11bHQ7XG5cdFx0XHRcdFx0YiAqPSBtdWx0O1xuXHRcdFx0XHRcdGMgKj0gbXVsdDtcblx0XHRcdFx0XHREID0gYiAqIGIgLSBhICogYztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFicyhhKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0aWYgKGFicyhCKSA8IEVQU0lMT04pXG5cdFx0XHRcdFx0cmV0dXJuIGFicyhjKSA8IEVQU0lMT04gPyAtMSA6IDA7XG5cdFx0XHRcdHgxID0gLWMgLyBCO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKEQgPj0gLU1BQ0hJTkVfRVBTSUxPTikge1xuXHRcdFx0XHRcdEQgPSBEIDwgMCA/IDAgOiBEO1xuXHRcdFx0XHRcdHZhciBSID0gc3FydChEKTtcblx0XHRcdFx0XHRpZiAoYiA+PSBNQUNISU5FX0VQU0lMT04gJiYgYiA8PSBNQUNISU5FX0VQU0lMT04pIHtcblx0XHRcdFx0XHRcdHgxID0gYWJzKGEpID49IGFicyhjKSA/IFIgLyBhIDogLWMgLyBSO1xuXHRcdFx0XHRcdFx0eDIgPSAteDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBxID0gLShiICsgKGIgPCAwID8gLTEgOiAxKSAqIFIpO1xuXHRcdFx0XHRcdFx0eDEgPSBxIC8gYTtcblx0XHRcdFx0XHRcdHgyID0gYyAvIHE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNGaW5pdGUoeDEpICYmIChtaW4gPT0gbnVsbCB8fCB4MSA+PSBtaW4gJiYgeDEgPD0gbWF4KSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSB4MTtcblx0XHRcdGlmICh4MiAhPT0geDFcblx0XHRcdFx0XHQmJiBpc0Zpbml0ZSh4MikgJiYgKG1pbiA9PSBudWxsIHx8IHgyID49IG1pbiAmJiB4MiA8PSBtYXgpKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IHgyO1xuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH0sXG5cblx0XHRzb2x2ZUN1YmljOiBmdW5jdGlvbihhLCBiLCBjLCBkLCByb290cywgbWluLCBtYXgpIHtcblx0XHRcdHZhciBjb3VudCA9IDAsXG5cdFx0XHRcdHgsIGIxLCBjMjtcblx0XHRcdGlmIChhYnMoYSkgPCBFUFNJTE9OKSB7XG5cdFx0XHRcdGEgPSBiO1xuXHRcdFx0XHRiMSA9IGM7XG5cdFx0XHRcdGMyID0gZDtcblx0XHRcdFx0eCA9IEluZmluaXR5O1xuXHRcdFx0fSBlbHNlIGlmIChhYnMoZCkgPCBFUFNJTE9OKSB7XG5cdFx0XHRcdGIxID0gYjtcblx0XHRcdFx0YzIgPSBjO1xuXHRcdFx0XHR4ID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBlYyA9IDEgKyBNQUNISU5FX0VQU0lMT04sXG5cdFx0XHRcdFx0eDAsIHEsIHFkLCB0LCByLCBzLCB0bXA7XG5cdFx0XHRcdHggPSAtKGIgLyBhKSAvIDM7XG5cdFx0XHRcdHRtcCA9IGEgKiB4LFxuXHRcdFx0XHRiMSA9IHRtcCArIGIsXG5cdFx0XHRcdGMyID0gYjEgKiB4ICsgYyxcblx0XHRcdFx0cWQgPSAodG1wICsgYjEpICogeCArIGMyLFxuXHRcdFx0XHRxID0gYzIgKiB4ICsgZDtcblx0XHRcdFx0dCA9IHEgL2E7XG5cdFx0XHRcdHIgPSBwb3coYWJzKHQpLCAxLzMpO1xuXHRcdFx0XHRzID0gdCA8IDAgPyAtMSA6IDE7XG5cdFx0XHRcdHQgPSAtcWQgLyBhO1xuXHRcdFx0XHRyID0gdCA+IDAgPyAxLjMyNDcxNzk1NzIgKiBNYXRoLm1heChyLCBzcXJ0KHQpKSA6IHI7XG5cdFx0XHRcdHgwID0geCAtIHMgKiByO1xuXHRcdFx0XHRpZiAoeDAgIT09IHgpIHtcblx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHR4ID0geDA7XG5cdFx0XHRcdFx0XHR0bXAgPSBhICogeCxcblx0XHRcdFx0XHRcdGIxID0gdG1wICsgYixcblx0XHRcdFx0XHRcdGMyID0gYjEgKiB4ICsgYyxcblx0XHRcdFx0XHRcdHFkID0gKHRtcCArIGIxKSAqIHggKyBjMixcblx0XHRcdFx0XHRcdHEgPSBjMiAqIHggKyBkO1xuXHRcdFx0XHRcdFx0eDAgPSBxZCA9PT0gMCA/IHggOiB4IC0gcSAvIHFkIC8gZWM7XG5cdFx0XHRcdFx0XHRpZiAoeDAgPT09IHgpIHtcblx0XHRcdFx0XHRcdFx0eCA9IHgwO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IHdoaWxlIChzICogeDAgPiBzICogeCk7XG5cdFx0XHRcdFx0aWYgKGFicyhhKSAqIHggKiB4ID4gYWJzKGQgLyB4KSkge1xuXHRcdFx0XHRcdFx0YzIgPSAtZCAvIHg7XG5cdFx0XHRcdFx0XHRiMSA9IChjMiAtIGMpIC8geDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciBjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiMSwgYzIsIHJvb3RzLCBtaW4sIG1heCk7XG5cdFx0XHRpZiAoaXNGaW5pdGUoeCkgJiYgKGNvdW50ID09PSAwIHx8IHggIT09IHJvb3RzW2NvdW50IC0gMV0pXG5cdFx0XHRcdFx0JiYgKG1pbiA9PSBudWxsIHx8IHggPj0gbWluICYmIHggPD0gbWF4KSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSB4O1xuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBVSUQgPSB7XG5cdF9pZDogMSxcblx0X3Bvb2xzOiB7fSxcblxuXHRnZXQ6IGZ1bmN0aW9uKGN0b3IpIHtcblx0XHRpZiAoY3Rvcikge1xuXHRcdFx0dmFyIG5hbWUgPSBjdG9yLl9jbGFzcyxcblx0XHRcdFx0cG9vbCA9IHRoaXMuX3Bvb2xzW25hbWVdO1xuXHRcdFx0aWYgKCFwb29sKVxuXHRcdFx0XHRwb29sID0gdGhpcy5fcG9vbHNbbmFtZV0gPSB7IF9pZDogMSB9O1xuXHRcdFx0cmV0dXJuIHBvb2wuX2lkKys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLl9pZCsrO1xuXHRcdH1cblx0fVxufTtcblxudmFyIFBvaW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQb2ludCcsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoYXJnMCwgYXJnMSkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGFyZzA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR2YXIgaGFzWSA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblx0XHRcdHRoaXMueCA9IGFyZzA7XG5cdFx0XHR0aGlzLnkgPSBoYXNZID8gYXJnMSA6IGFyZzA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gaGFzWSA/IDIgOiAxO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy54ID0gdGhpcy55ID0gMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzBbMF07XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAubGVuZ3RoID4gMSA/IGFyZzBbMV0gOiBhcmcwWzBdO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwLng7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAueTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC53aWR0aCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAud2lkdGg7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAuaGVpZ2h0O1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmFuZ2xlICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC5sZW5ndGg7XG5cdFx0XHRcdHRoaXMueSA9IDA7XG5cdFx0XHRcdHRoaXMuc2V0QW5nbGUoYXJnMC5hbmdsZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnggPSB0aGlzLnkgPSAwO1xuXHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0dGhpcy5fX3JlYWQgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IDE7XG5cdFx0fVxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIHRoaXMgPT09IHBvaW50IHx8IHBvaW50XG5cdFx0XHRcdCYmICh0aGlzLnggPT09IHBvaW50LnggJiYgdGhpcy55ID09PSBwb2ludC55XG5cdFx0XHRcdFx0fHwgQXJyYXkuaXNBcnJheShwb2ludClcblx0XHRcdFx0XHRcdCYmIHRoaXMueCA9PT0gcG9pbnRbMF0gJiYgdGhpcy55ID09PSBwb2ludFsxXSlcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueCkgKyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KSArICcgfSc7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG5cdFx0cmV0dXJuIFtmLm51bWJlcih0aGlzLngpLCBmLm51bWJlcih0aGlzLnkpXTtcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcblx0fSxcblxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdGlmICh0aGlzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgYW5nbGUgPSB0aGlzLl9hbmdsZSB8fCAwO1xuXHRcdFx0dGhpcy5zZXQoXG5cdFx0XHRcdE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCxcblx0XHRcdFx0TWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc2NhbGUgPSBsZW5ndGggLyB0aGlzLmdldExlbmd0aCgpO1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oc2NhbGUpKVxuXHRcdFx0XHR0aGlzLmdldEFuZ2xlKCk7XG5cdFx0XHR0aGlzLnNldChcblx0XHRcdFx0dGhpcy54ICogc2NhbGUsXG5cdFx0XHRcdHRoaXMueSAqIHNjYWxlXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblx0Z2V0QW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEFuZ2xlSW5SYWRpYW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiAxODAgLyBNYXRoLlBJO1xuXHR9LFxuXG5cdHNldEFuZ2xlOiBmdW5jdGlvbihhbmdsZSkge1xuXHRcdHRoaXMuc2V0QW5nbGVJblJhZGlhbnMuY2FsbCh0aGlzLCBhbmdsZSAqIE1hdGguUEkgLyAxODApO1xuXHR9LFxuXG5cdGdldEFuZ2xlSW5EZWdyZWVzOiAnI2dldEFuZ2xlJyxcblx0c2V0QW5nbGVJbkRlZ3JlZXM6ICcjc2V0QW5nbGUnLFxuXG5cdGdldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9hbmdsZSB8fCAwXG5cdFx0XHRcdFx0OiB0aGlzLl9hbmdsZSA9IE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGRpdiA9IHRoaXMuZ2V0TGVuZ3RoKCkgKiBwb2ludC5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGRpdikpIHtcblx0XHRcdFx0cmV0dXJuIE5hTjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhID0gdGhpcy5kb3QocG9pbnQpIC8gZGl2O1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5hY29zKGEgPCAtMSA/IC0xIDogYSA+IDEgPyAxIDogYSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbihhbmdsZSkge1xuXHRcdHRoaXMuX2FuZ2xlID0gYW5nbGU7XG5cdFx0aWYgKCF0aGlzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRcdHRoaXMuc2V0KFxuXHRcdFx0XHRNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG5cdFx0XHRcdE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aFxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UXVhZHJhbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggPj0gMCA/IHRoaXMueSA+PSAwID8gMSA6IDQgOiB0aGlzLnkgPj0gMCA/IDIgOiAzO1xuXHR9XG59LCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXREaXJlY3RlZEFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIE1hdGguYXRhbjIodGhpcy5jcm9zcyhwb2ludCksIHRoaXMuZG90KHBvaW50KSkgKiAxODAgLyBNYXRoLlBJO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4ID0gcG9pbnQueCAtIHRoaXMueCxcblx0XHRcdHkgPSBwb2ludC55IC0gdGhpcy55LFxuXHRcdFx0ZCA9IHggKiB4ICsgeSAqIHksXG5cdFx0XHRzcXVhcmVkID0gQmFzZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHNxdWFyZWQgPyBkIDogTWF0aC5zcXJ0KGQpO1xuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0aWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0bGVuZ3RoID0gMTtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0TGVuZ3RoKCksXG5cdFx0XHRzY2FsZSA9IGN1cnJlbnQgIT09IDAgPyBsZW5ndGggLyBjdXJyZW50IDogMCxcblx0XHRcdHBvaW50ID0gbmV3IFBvaW50KHRoaXMueCAqIHNjYWxlLCB0aGlzLnkgKiBzY2FsZSk7XG5cdFx0aWYgKHNjYWxlID49IDApXG5cdFx0XHRwb2ludC5fYW5nbGUgPSB0aGlzLl9hbmdsZTtcblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSwgY2VudGVyKSB7XG5cdFx0aWYgKGFuZ2xlID09PSAwKVxuXHRcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKTtcblx0XHRhbmdsZSA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcblx0XHR2YXIgcG9pbnQgPSBjZW50ZXIgPyB0aGlzLnN1YnRyYWN0KGNlbnRlcikgOiB0aGlzLFxuXHRcdFx0cyA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdGMgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0cG9pbnQgPSBuZXcgUG9pbnQoXG5cdFx0XHRwb2ludC54ICogYyAtIHBvaW50LnkgKiBzLFxuXHRcdFx0cG9pbnQueCAqIHMgKyBwb2ludC55ICogY1xuXHRcdCk7XG5cdFx0cmV0dXJuIGNlbnRlciA/IHBvaW50LmFkZChjZW50ZXIpIDogcG9pbnQ7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh0aGlzKSA6IHRoaXM7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBwb2ludC54LCB0aGlzLnkgKyBwb2ludC55KTtcblx0fSxcblxuXHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gcG9pbnQueCwgdGhpcy55IC0gcG9pbnQueSk7XG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XG5cdH0sXG5cblx0bW9kdWxvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggJSBwb2ludC54LCB0aGlzLnkgJSBwb2ludC55KTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQoLXRoaXMueCwgLXRoaXMueSk7XG5cdH0sXG5cblx0aXNJbnNpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLmNvbnRhaW5zKHRoaXMpO1xuXHR9LFxuXG5cdGlzQ2xvc2U6IGZ1bmN0aW9uKHBvaW50LCB0b2xlcmFuY2UpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXREaXN0YW5jZShwb2ludCkgPCB0b2xlcmFuY2U7XG5cdH0sXG5cblx0aXNDb2xsaW5lYXI6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMuY3Jvc3MocG9pbnQpKSA8IDAuMDAwMDAxO1xuXHR9LFxuXG5cdGlzQ29saW5lYXI6ICcjaXNDb2xsaW5lYXInLFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy5kb3QocG9pbnQpKSA8IDAuMDAwMDAxO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy54KSAmJiBOdW1lcmljYWwuaXNaZXJvKHRoaXMueSk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLngpIHx8IGlzTmFOKHRoaXMueSk7XG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHBvaW50LnggKyB0aGlzLnkgKiBwb2ludC55O1xuXHR9LFxuXG5cdGNyb3NzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHBvaW50LnkgLSB0aGlzLnkgKiBwb2ludC54O1xuXHR9LFxuXG5cdHByb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAocG9pbnQuaXNaZXJvKCkpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoMCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBzY2FsZSA9IHRoaXMuZG90KHBvaW50KSAvIHBvaW50LmRvdChwb2ludCk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRwb2ludC54ICogc2NhbGUsXG5cdFx0XHRcdHBvaW50LnkgKiBzY2FsZVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueCwgcG9pbnQyLngpLFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueSwgcG9pbnQyLnkpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50MSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cG9pbnQyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0TWF0aC5tYXgocG9pbnQxLngsIHBvaW50Mi54KSxcblx0XHRcdFx0TWF0aC5tYXgocG9pbnQxLnksIHBvaW50Mi55KVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBvcCA9IE1hdGhbbmFtZV07XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KG9wKHRoaXMueCksIG9wKHRoaXMueSkpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmtlZFBvaW50ID0gUG9pbnQuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoeCwgeSwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fSxcblxuXHRnZXRZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feTtcblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbih5KSB7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fVxufSk7XG5cbnZhciBTaXplID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTaXplJyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaXplKGFyZzAsIGFyZzEpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGhhc0hlaWdodCA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblx0XHRcdHRoaXMud2lkdGggPSBhcmcwO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBoYXNIZWlnaHQgPyBhcmcxIDogYXJnMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBoYXNIZWlnaHQgPyAyIDogMTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMFswXTtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLmxlbmd0aCA+IDEgPyBhcmcwWzFdIDogYXJnMFswXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC53aWR0aCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwLndpZHRoO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAuaGVpZ2h0O1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC54O1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAueTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0XHR0aGlzLl9fcmVhZCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gMTtcblx0XHR9XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHJldHVybiBzaXplID09PSB0aGlzIHx8IHNpemUgJiYgKHRoaXMud2lkdGggPT09IHNpemUud2lkdGhcblx0XHRcdFx0JiYgdGhpcy5oZWlnaHQgPT09IHNpemUuaGVpZ2h0XG5cdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkoc2l6ZSkgJiYgdGhpcy53aWR0aCA9PT0gc2l6ZVswXVxuXHRcdFx0XHRcdCYmIHRoaXMuaGVpZ2h0ID09PSBzaXplWzFdKSB8fCBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodCkgKyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICsgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKyBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAtIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAqIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICogc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAvIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC8gc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG1vZHVsbzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAlIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICUgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKC10aGlzLndpZHRoLCAtdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy53aWR0aCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLndpZHRoKSB8fCBpc05hTih0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oc2l6ZTEsIHNpemUyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHRcdE1hdGgubWluKHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG5cdFx0XHRcdE1hdGgubWluKHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG5cdFx0fSxcblxuXHRcdG1heDogZnVuY3Rpb24oc2l6ZTEsIHNpemUyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHRcdE1hdGgubWF4KHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG5cdFx0XHRcdE1hdGgubWF4KHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG5cdFx0fSxcblxuXHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBvcCA9IE1hdGhbbmFtZV07XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNpemUob3AodGhpcy53aWR0aCksIG9wKHRoaXMuaGVpZ2h0KSk7XG5cdH07XG59LCB7fSkpO1xuXG52YXIgTGlua2VkU2l6ZSA9IFNpemUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZSh3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fd2lkdGg7XG5cdH0sXG5cblx0c2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9LFxuXG5cdGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hlaWdodDtcblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIFJlY3RhbmdsZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUmVjdGFuZ2xlJyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwLFxuXHRcdFx0cmVhZCA9IDA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR0aGlzLnggPSBhcmcwO1xuXHRcdFx0dGhpcy55ID0gYXJnMTtcblx0XHRcdHRoaXMud2lkdGggPSBhcmcyO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBhcmczO1xuXHRcdFx0cmVhZCA9IDQ7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLnggPSB0aGlzLnkgPSB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0cmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzBbMF07XG5cdFx0XHRcdHRoaXMueSA9IGFyZzBbMV07XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwWzJdO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzBbM107XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT09IHVuZGVmaW5lZCB8fCBhcmcwLndpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC54IHx8IDA7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAueSB8fCAwO1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC53aWR0aCB8fCAwO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAuaGVpZ2h0IHx8IDA7XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmZyb20gPT09IHVuZGVmaW5lZCAmJiBhcmcwLnRvID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy54ID0gdGhpcy55ID0gdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0XHRcdFx0dGhpcy5fc2V0KGFyZzApO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFyZWFkKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnZnJvbScpLFxuXHRcdFx0XHRuZXh0ID0gQmFzZS5wZWVrKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnggPSBwb2ludC54O1xuXHRcdFx0dGhpcy55ID0gcG9pbnQueTtcblx0XHRcdGlmIChuZXh0ICYmIG5leHQueCAhPT0gdW5kZWZpbmVkIHx8IEJhc2UuaGFzTmFtZWQoYXJndW1lbnRzLCAndG8nKSkge1xuXHRcdFx0XHR2YXIgdG8gPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHRvLnggLSBwb2ludC54O1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IHRvLnkgLSBwb2ludC55O1xuXHRcdFx0XHRpZiAodGhpcy53aWR0aCA8IDApIHtcblx0XHRcdFx0XHR0aGlzLnggPSB0by54O1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSAtdGhpcy53aWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5oZWlnaHQgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy55ID0gdG8ueTtcblx0XHRcdFx0XHR0aGlzLmhlaWdodCA9IC10aGlzLmhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHRyZWFkID0gYXJndW1lbnRzLl9faW5kZXg7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdHRoaXMuX19yZWFkID0gcmVhZDtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciBydCA9IEJhc2UuaXNQbGFpblZhbHVlKHJlY3QpXG5cdFx0XHRcdD8gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKVxuXHRcdFx0XHQ6IHJlY3Q7XG5cdFx0cmV0dXJuIHJ0ID09PSB0aGlzXG5cdFx0XHRcdHx8IHJ0ICYmIHRoaXMueCA9PT0gcnQueCAmJiB0aGlzLnkgPT09IHJ0Lnlcblx0XHRcdFx0XHQmJiB0aGlzLndpZHRoID09PSBydC53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gcnQuaGVpZ2h0XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueClcblx0XHRcdFx0KyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KVxuXHRcdFx0XHQrICcsIHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodClcblx0XHRcdFx0KyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy54KSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy55KSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMsICdzZXRQb2ludCcpO1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy54ID0gcG9pbnQueDtcblx0XHR0aGlzLnkgPSBwb2ludC55O1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gU2l6ZSA6IExpbmtlZFNpemU7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHRoaXMuX2ZpeFgpXG5cdFx0XHR0aGlzLnggKz0gKHRoaXMud2lkdGggLSBzaXplLndpZHRoKSAqIHRoaXMuX2ZpeFg7XG5cdFx0aWYgKHRoaXMuX2ZpeFkpXG5cdFx0XHR0aGlzLnkgKz0gKHRoaXMuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpICogdGhpcy5fZml4WTtcblx0XHR0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdHRoaXMuX2ZpeFcgPSAxO1xuXHRcdHRoaXMuX2ZpeEggPSAxO1xuXHR9LFxuXG5cdGdldExlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLng7XG5cdH0sXG5cblx0c2V0TGVmdDogZnVuY3Rpb24obGVmdCkge1xuXHRcdGlmICghdGhpcy5fZml4Vylcblx0XHRcdHRoaXMud2lkdGggLT0gbGVmdCAtIHRoaXMueDtcblx0XHR0aGlzLnggPSBsZWZ0O1xuXHRcdHRoaXMuX2ZpeFggPSAwO1xuXHR9LFxuXG5cdGdldFRvcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueTtcblx0fSxcblxuXHRzZXRUb3A6IGZ1bmN0aW9uKHRvcCkge1xuXHRcdGlmICghdGhpcy5fZml4SClcblx0XHRcdHRoaXMuaGVpZ2h0IC09IHRvcCAtIHRoaXMueTtcblx0XHR0aGlzLnkgPSB0b3A7XG5cdFx0dGhpcy5fZml4WSA9IDA7XG5cdH0sXG5cblx0Z2V0UmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuXHR9LFxuXG5cdHNldFJpZ2h0OiBmdW5jdGlvbihyaWdodCkge1xuXHRcdGlmICh0aGlzLl9maXhYICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZml4WCAhPT0gMSlcblx0XHRcdHRoaXMuX2ZpeFcgPSAwO1xuXHRcdGlmICh0aGlzLl9maXhXKVxuXHRcdFx0dGhpcy54ID0gcmlnaHQgLSB0aGlzLndpZHRoO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMud2lkdGggPSByaWdodCAtIHRoaXMueDtcblx0XHR0aGlzLl9maXhYID0gMTtcblx0fSxcblxuXHRnZXRCb3R0b206IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRzZXRCb3R0b206IGZ1bmN0aW9uKGJvdHRvbSkge1xuXHRcdGlmICh0aGlzLl9maXhZICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZml4WSAhPT0gMSlcblx0XHRcdHRoaXMuX2ZpeEggPSAwO1xuXHRcdGlmICh0aGlzLl9maXhIKVxuXHRcdFx0dGhpcy55ID0gYm90dG9tIC0gdGhpcy5oZWlnaHQ7XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5oZWlnaHQgPSBib3R0b20gLSB0aGlzLnk7XG5cdFx0dGhpcy5fZml4WSA9IDE7XG5cdH0sXG5cblx0Z2V0Q2VudGVyWDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGggKiAwLjU7XG5cdH0sXG5cblx0c2V0Q2VudGVyWDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMueCA9IHggLSB0aGlzLndpZHRoICogMC41O1xuXHRcdHRoaXMuX2ZpeFggPSAwLjU7XG5cdH0sXG5cblx0Z2V0Q2VudGVyWTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0ICogMC41O1xuXHR9LFxuXG5cdHNldENlbnRlclk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLnkgPSB5IC0gdGhpcy5oZWlnaHQgKiAwLjU7XG5cdFx0dGhpcy5fZml4WSA9IDAuNTtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy5nZXRDZW50ZXJYKCksIHRoaXMuZ2V0Q2VudGVyWSgpLCB0aGlzLCAnc2V0Q2VudGVyJyk7XG5cdH0sXG5cblx0c2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5zZXRDZW50ZXJYKHBvaW50LngpO1xuXHRcdHRoaXMuc2V0Q2VudGVyWShwb2ludC55KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoID09PSAwIHx8IHRoaXMuaGVpZ2h0ID09PSAwO1xuXHR9LFxuXG5cdGNvbnRhaW5zOiBmdW5jdGlvbihhcmcpIHtcblx0XHRyZXR1cm4gYXJnICYmIGFyZy53aWR0aCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdHx8IChBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpLmxlbmd0aCA9PSA0XG5cdFx0XHRcdD8gdGhpcy5fY29udGFpbnNSZWN0YW5nbGUoUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSlcblx0XHRcdFx0OiB0aGlzLl9jb250YWluc1BvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0cmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdF9jb250YWluc1JlY3RhbmdsZTogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciB4ID0gcmVjdC54LFxuXHRcdFx0eSA9IHJlY3QueTtcblx0XHRyZXR1cm4geCA+PSB0aGlzLnggJiYgeSA+PSB0aGlzLnlcblx0XHRcdFx0JiYgeCArIHJlY3Qud2lkdGggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiB5ICsgcmVjdC5oZWlnaHQgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0aW50ZXJzZWN0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID4gdGhpcy54XG5cdFx0XHRcdCYmIHJlY3QueSArIHJlY3QuaGVpZ2h0ID4gdGhpcy55XG5cdFx0XHRcdCYmIHJlY3QueCA8IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgcmVjdC55IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0dG91Y2hlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID49IHRoaXMueFxuXHRcdFx0XHQmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+PSB0aGlzLnlcblx0XHRcdFx0JiYgcmVjdC54IDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgcmVjdC55IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGludGVyc2VjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1heCh0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWF4KHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHR1bml0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRpbmNsdWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIHgxID0gTWF0aC5taW4odGhpcy54LCBwb2ludC54KSxcblx0XHRcdHkxID0gTWF0aC5taW4odGhpcy55LCBwb2ludC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcG9pbnQueCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBwb2ludC55KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGV4cGFuZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFtb3VudCA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0aG9yID0gYW1vdW50LndpZHRoLFxuXHRcdFx0dmVyID0gYW1vdW50LmhlaWdodDtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSBob3IgLyAyLCB0aGlzLnkgLSB2ZXIgLyAyLFxuXHRcdFx0XHR0aGlzLndpZHRoICsgaG9yLCB0aGlzLmhlaWdodCArIHZlcik7XG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uKGhvciwgdmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMud2lkdGggKiBob3IgLSB0aGlzLndpZHRoLFxuXHRcdFx0XHR0aGlzLmhlaWdodCAqICh2ZXIgPT09IHVuZGVmaW5lZCA/IGhvciA6IHZlcikgLSB0aGlzLmhlaWdodCk7XG5cdH1cbn0sIEJhc2UuZWFjaChbXG5cdFx0WydUb3AnLCAnTGVmdCddLCBbJ1RvcCcsICdSaWdodCddLFxuXHRcdFsnQm90dG9tJywgJ0xlZnQnXSwgWydCb3R0b20nLCAnUmlnaHQnXSxcblx0XHRbJ0xlZnQnLCAnQ2VudGVyJ10sIFsnVG9wJywgJ0NlbnRlciddLFxuXHRcdFsnUmlnaHQnLCAnQ2VudGVyJ10sIFsnQm90dG9tJywgJ0NlbnRlciddXG5cdF0sXG5cdGZ1bmN0aW9uKHBhcnRzLCBpbmRleCkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHMuam9pbignJyk7XG5cdFx0dmFyIHhGaXJzdCA9IC9eW1JMXS8udGVzdChwYXJ0KTtcblx0XHRpZiAoaW5kZXggPj0gNClcblx0XHRcdHBhcnRzWzFdICs9IHhGaXJzdCA/ICdZJyA6ICdYJztcblx0XHR2YXIgeCA9IHBhcnRzW3hGaXJzdCA/IDAgOiAxXSxcblx0XHRcdHkgPSBwYXJ0c1t4Rmlyc3QgPyAxIDogMF0sXG5cdFx0XHRnZXRYID0gJ2dldCcgKyB4LFxuXHRcdFx0Z2V0WSA9ICdnZXQnICsgeSxcblx0XHRcdHNldFggPSAnc2V0JyArIHgsXG5cdFx0XHRzZXRZID0gJ3NldCcgKyB5LFxuXHRcdFx0Z2V0ID0gJ2dldCcgKyBwYXJ0LFxuXHRcdFx0c2V0ID0gJ3NldCcgKyBwYXJ0O1xuXHRcdHRoaXNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXNbZ2V0WF0oKSwgdGhpc1tnZXRZXSgpLCB0aGlzLCBzZXQpO1xuXHRcdH07XG5cdFx0dGhpc1tzZXRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzW3NldFhdKHBvaW50LngpO1xuXHRcdFx0dGhpc1tzZXRZXShwb2ludC55KTtcblx0XHR9O1xuXHR9LCB7XG5cdFx0YmVhbnM6IHRydWVcblx0fVxuKSk7XG5cbnZhciBMaW5rZWRSZWN0YW5nbGUgPSBSZWN0YW5nbGUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLnNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHByb3RvID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpO1xuXHRcdHZhciBpbnRlcm5hbCA9ICdfJyArIGtleTtcblx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW2ludGVybmFsXTtcblx0XHR9O1xuXG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXNbaW50ZXJuYWxdID0gdmFsdWU7XG5cdFx0XHRpZiAoIXRoaXMuX2RvbnROb3RpZnkpXG5cdFx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0fTtcblx0fSwgQmFzZS5lYWNoKFsnUG9pbnQnLCAnU2l6ZScsICdDZW50ZXInLFxuXHRcdFx0J0xlZnQnLCAnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdDZW50ZXJYJywgJ0NlbnRlclknLFxuXHRcdFx0J1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsXG5cdFx0XHQnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ10sXG5cdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgbmFtZSA9ICdzZXQnICsga2V5O1xuXHRcdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9kb250Tm90aWZ5ID0gdHJ1ZTtcblx0XHRcdFx0cHJvdG9bbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy5fZG9udE5vdGlmeSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX293bmVyLl9ib3VuZHNTZWxlY3RlZDtcblx0XHRcdH0sXG5cblx0XHRcdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRcdFx0aWYgKG93bmVyLnNldFNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0b3duZXIuX2JvdW5kc1NlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0XHRcdFx0b3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQgfHwgb3duZXIuX3NlbGVjdGVkU2VnbWVudFN0YXRlID4gMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXHQpO1xufSk7XG5cbnZhciBNYXRyaXggPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ01hdHJpeCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTWF0cml4KGFyZykge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRvayA9IHRydWU7XG5cdFx0aWYgKGNvdW50ID09PSA2KSB7XG5cdFx0XHR0aGlzLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdGlmIChhcmcgaW5zdGFuY2VvZiBNYXRyaXgpIHtcblx0XHRcdFx0dGhpcy5zZXQoYXJnLl9hLCBhcmcuX2MsIGFyZy5fYiwgYXJnLl9kLCBhcmcuX3R4LCBhcmcuX3R5KTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdHRoaXMuc2V0LmFwcGx5KHRoaXMsIGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvayA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDApIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2sgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCFvaylcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgbWF0cml4IHBhcmFtZXRlcnMnKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKGEsIGMsIGIsIGQsIHR4LCB0eSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl9hID0gYTtcblx0XHR0aGlzLl9jID0gYztcblx0XHR0aGlzLl9iID0gYjtcblx0XHR0aGlzLl9kID0gZDtcblx0XHR0aGlzLl90eCA9IHR4O1xuXHRcdHRoaXMuX3R5ID0gdHk7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuZ2V0VmFsdWVzKCksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdGlmIChvd25lci5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3duZXIuX2NoYW5nZWQoOSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeCh0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLFxuXHRcdFx0XHR0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24obXgpIHtcblx0XHRyZXR1cm4gbXggPT09IHRoaXMgfHwgbXggJiYgdGhpcy5fYSA9PT0gbXguX2EgJiYgdGhpcy5fYiA9PT0gbXguX2Jcblx0XHRcdFx0JiYgdGhpcy5fYyA9PT0gbXguX2MgJiYgdGhpcy5fZCA9PT0gbXguX2Rcblx0XHRcdFx0JiYgdGhpcy5fdHggPT09IG14Ll90eCAmJiB0aGlzLl90eSA9PT0gbXguX3R5XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ1tbJyArIFtmLm51bWJlcih0aGlzLl9hKSwgZi5udW1iZXIodGhpcy5fYiksXG5cdFx0XHRcdFx0Zi5udW1iZXIodGhpcy5fdHgpXS5qb2luKCcsICcpICsgJ10sIFsnXG5cdFx0XHRcdCsgW2YubnVtYmVyKHRoaXMuX2MpLCBmLm51bWJlcih0aGlzLl9kKSxcblx0XHRcdFx0XHRmLm51bWJlcih0aGlzLl90eSldLmpvaW4oJywgJykgKyAnXV0nO1xuXHR9LFxuXG5cdHJlc2V0OiBmdW5jdGlvbihfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX2EgPSB0aGlzLl9kID0gMTtcblx0XHR0aGlzLl9jID0gdGhpcy5fYiA9IHRoaXMuX3R4ID0gdGhpcy5fdHkgPSAwO1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YXBwbHk6IGZ1bmN0aW9uKHJlY3Vyc2l2ZWx5LCBfc2V0QXBwbHlNYXRyaXgpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdG93bmVyLnRyYW5zZm9ybShudWxsLCB0cnVlLCBCYXNlLnBpY2socmVjdXJzaXZlbHksIHRydWUpLFxuXHRcdFx0XHRcdF9zZXRBcHBseU1hdHJpeCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0lkZW50aXR5KCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0dGhpcy5fdHggKz0geCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYjtcblx0XHR0aGlzLl90eSArPSB4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzY2FsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjYWxlID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0dGhpcy5fYSAqPSBzY2FsZS54O1xuXHRcdHRoaXMuX2MgKj0gc2NhbGUueDtcblx0XHR0aGlzLl9iICo9IHNjYWxlLnk7XG5cdFx0dGhpcy5fZCAqPSBzY2FsZS55O1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlICkge1xuXHRcdGFuZ2xlICo9IE1hdGguUEkgLyAxODA7XG5cdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSxcblx0XHRcdHggPSBjZW50ZXIueCxcblx0XHRcdHkgPSBjZW50ZXIueSxcblx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcblx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdHR4ID0geCAtIHggKiBjb3MgKyB5ICogc2luLFxuXHRcdFx0dHkgPSB5IC0geCAqIHNpbiAtIHkgKiBjb3MsXG5cdFx0XHRhID0gdGhpcy5fYSxcblx0XHRcdGIgPSB0aGlzLl9iLFxuXHRcdFx0YyA9IHRoaXMuX2MsXG5cdFx0XHRkID0gdGhpcy5fZDtcblx0XHR0aGlzLl9hID0gY29zICogYSArIHNpbiAqIGI7XG5cdFx0dGhpcy5fYiA9IC1zaW4gKiBhICsgY29zICogYjtcblx0XHR0aGlzLl9jID0gY29zICogYyArIHNpbiAqIGQ7XG5cdFx0dGhpcy5fZCA9IC1zaW4gKiBjICsgY29zICogZDtcblx0XHR0aGlzLl90eCArPSB0eCAqIGEgKyB0eSAqIGI7XG5cdFx0dGhpcy5fdHkgKz0gdHggKiBjICsgdHkgKiBkO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzaGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNoZWFyID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLFxuXHRcdFx0YyA9IHRoaXMuX2M7XG5cdFx0dGhpcy5fYSArPSBzaGVhci55ICogdGhpcy5fYjtcblx0XHR0aGlzLl9jICs9IHNoZWFyLnkgKiB0aGlzLl9kO1xuXHRcdHRoaXMuX2IgKz0gc2hlYXIueCAqIGE7XG5cdFx0dGhpcy5fZCArPSBzaGVhci54ICogYztcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2tldzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNrZXcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdHRvUmFkaWFucyA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHRzaGVhciA9IG5ldyBQb2ludChNYXRoLnRhbihza2V3LnggKiB0b1JhZGlhbnMpLFxuXHRcdFx0XHRNYXRoLnRhbihza2V3LnkgKiB0b1JhZGlhbnMpKTtcblx0XHRyZXR1cm4gdGhpcy5zaGVhcihzaGVhciwgY2VudGVyKTtcblx0fSxcblxuXHRjb25jYXRlbmF0ZTogZnVuY3Rpb24obXgpIHtcblx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0YjEgPSB0aGlzLl9iLFxuXHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdGIyID0gbXguX2IsXG5cdFx0XHRjMiA9IG14Ll9jLFxuXHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdHR4MiA9IG14Ll90eCxcblx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHR0aGlzLl9hID0gYTIgKiBhMSArIGMyICogYjE7XG5cdFx0dGhpcy5fYiA9IGIyICogYTEgKyBkMiAqIGIxO1xuXHRcdHRoaXMuX2MgPSBhMiAqIGMxICsgYzIgKiBkMTtcblx0XHR0aGlzLl9kID0gYjIgKiBjMSArIGQyICogZDE7XG5cdFx0dGhpcy5fdHggKz0gdHgyICogYTEgKyB0eTIgKiBiMTtcblx0XHR0aGlzLl90eSArPSB0eDIgKiBjMSArIHR5MiAqIGQxO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwcmVDb25jYXRlbmF0ZTogZnVuY3Rpb24obXgpIHtcblx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0YjEgPSB0aGlzLl9iLFxuXHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0dHgxID0gdGhpcy5fdHgsXG5cdFx0XHR0eTEgPSB0aGlzLl90eSxcblx0XHRcdGEyID0gbXguX2EsXG5cdFx0XHRiMiA9IG14Ll9iLFxuXHRcdFx0YzIgPSBteC5fYyxcblx0XHRcdGQyID0gbXguX2QsXG5cdFx0XHR0eDIgPSBteC5fdHgsXG5cdFx0XHR0eTIgPSBteC5fdHk7XG5cdFx0dGhpcy5fYSA9IGEyICogYTEgKyBiMiAqIGMxO1xuXHRcdHRoaXMuX2IgPSBhMiAqIGIxICsgYjIgKiBkMTtcblx0XHR0aGlzLl9jID0gYzIgKiBhMSArIGQyICogYzE7XG5cdFx0dGhpcy5fZCA9IGMyICogYjEgKyBkMiAqIGQxO1xuXHRcdHRoaXMuX3R4ID0gYTIgKiB0eDEgKyBiMiAqIHR5MSArIHR4Mjtcblx0XHR0aGlzLl90eSA9IGMyICogdHgxICsgZDIgKiB0eTEgKyB0eTI7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNoYWluOiBmdW5jdGlvbihteCkge1xuXHRcdHZhciBhMSA9IHRoaXMuX2EsXG5cdFx0XHRiMSA9IHRoaXMuX2IsXG5cdFx0XHRjMSA9IHRoaXMuX2MsXG5cdFx0XHRkMSA9IHRoaXMuX2QsXG5cdFx0XHR0eDEgPSB0aGlzLl90eCxcblx0XHRcdHR5MSA9IHRoaXMuX3R5LFxuXHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdGIyID0gbXguX2IsXG5cdFx0XHRjMiA9IG14Ll9jLFxuXHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdHR4MiA9IG14Ll90eCxcblx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeChcblx0XHRcdFx0YTIgKiBhMSArIGMyICogYjEsXG5cdFx0XHRcdGEyICogYzEgKyBjMiAqIGQxLFxuXHRcdFx0XHRiMiAqIGExICsgZDIgKiBiMSxcblx0XHRcdFx0YjIgKiBjMSArIGQyICogZDEsXG5cdFx0XHRcdHR4MSArIHR4MiAqIGExICsgdHkyICogYjEsXG5cdFx0XHRcdHR5MSArIHR4MiAqIGMxICsgdHkyICogZDEpO1xuXHR9LFxuXG5cdGlzSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hID09PSAxICYmIHRoaXMuX2MgPT09IDAgJiYgdGhpcy5fYiA9PT0gMCAmJiB0aGlzLl9kID09PSAxXG5cdFx0XHRcdCYmIHRoaXMuX3R4ID09PSAwICYmIHRoaXMuX3R5ID09PSAwO1xuXHR9LFxuXG5cdG9yTnVsbElmSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKSA/IG51bGwgOiB0aGlzO1xuXHR9LFxuXG5cdGlzSW52ZXJ0aWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0fSxcblxuXHRpc1Npbmd1bGFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2dldERldGVybWluYW50KCk7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbiggc3JjLCBkc3QsIGNvdW50KSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAzXG5cdFx0XHQ/IHRoaXMuX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSlcblx0XHRcdDogdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoc3JjLCBkc3QsIGNvdW50KTtcblx0fSxcblxuXHRfdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciB4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUG9pbnQoKTtcblx0XHRyZXR1cm4gZGVzdC5zZXQoXG5cdFx0XHR4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iICsgdGhpcy5fdHgsXG5cdFx0XHR4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHksXG5cdFx0XHRfZG9udE5vdGlmeVxuXHRcdCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbihzcmMsIGRzdCwgY291bnQpIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRqID0gMCxcblx0XHRcdG1heCA9IDIgKiBjb3VudDtcblx0XHR3aGlsZSAoaSA8IG1heCkge1xuXHRcdFx0dmFyIHggPSBzcmNbaSsrXSxcblx0XHRcdFx0eSA9IHNyY1tpKytdO1xuXHRcdFx0ZHN0W2orK10gPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iICsgdGhpcy5fdHg7XG5cdFx0XHRkc3RbaisrXSA9IHggKiB0aGlzLl9jICsgeSAqIHRoaXMuX2QgKyB0aGlzLl90eTtcblx0XHR9XG5cdFx0cmV0dXJuIGRzdDtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29ybmVyczogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciB4MSA9IHJlY3QueCxcblx0XHRcdHkxID0gcmVjdC55LFxuXHRcdFx0eDIgPSB4MSArIHJlY3Qud2lkdGgsXG5cdFx0XHR5MiA9IHkxICsgcmVjdC5oZWlnaHQsXG5cdFx0XHRjb29yZHMgPSBbIHgxLCB5MSwgeDIsIHkxLCB4MiwgeTIsIHgxLCB5MiBdO1xuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhjb29yZHMsIGNvb3JkcywgNCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUJvdW5kczogZnVuY3Rpb24oYm91bmRzLCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLl90cmFuc2Zvcm1Db3JuZXJzKGJvdW5kcyksXG5cdFx0XHRtaW4gPSBjb29yZHMuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBjb29yZHMuc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpID0gMjsgaSA8IDg7IGkrKykge1xuXHRcdFx0dmFyIHZhbCA9IGNvb3Jkc1tpXSxcblx0XHRcdFx0aiA9IGkgJiAxO1xuXHRcdFx0aWYgKHZhbCA8IG1pbltqXSlcblx0XHRcdFx0bWluW2pdID0gdmFsO1xuXHRcdFx0ZWxzZSBpZiAodmFsID4gbWF4W2pdKVxuXHRcdFx0XHRtYXhbal0gPSB2YWw7XG5cdFx0fVxuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSxcblx0XHRcdFx0X2RvbnROb3RpZnkpO1xuXHR9LFxuXG5cdGludmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2dldERldGVybWluYW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fYSAqIHRoaXMuX2QgLSB0aGlzLl9iICogdGhpcy5fYztcblx0XHRyZXR1cm4gaXNGaW5pdGUoZGV0KSAmJiAhTnVtZXJpY2FsLmlzWmVybyhkZXQpXG5cdFx0XHRcdCYmIGlzRmluaXRlKHRoaXMuX3R4KSAmJiBpc0Zpbml0ZSh0aGlzLl90eSlcblx0XHRcdFx0PyBkZXQgOiBudWxsO1xuXHR9LFxuXG5cdF9pbnZlcnNlVHJhbnNmb3JtOiBmdW5jdGlvbihwb2ludCwgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0XHRpZiAoIWRldClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMuX3R4LFxuXHRcdFx0eSA9IHBvaW50LnkgLSB0aGlzLl90eTtcblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFBvaW50KCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KFxuXHRcdFx0KHggKiB0aGlzLl9kIC0geSAqIHRoaXMuX2IpIC8gZGV0LFxuXHRcdFx0KHkgKiB0aGlzLl9hIC0geCAqIHRoaXMuX2MpIC8gZGV0LFxuXHRcdFx0X2RvbnROb3RpZnlcblx0XHQpO1xuXHR9LFxuXG5cdGRlY29tcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLCBiID0gdGhpcy5fYiwgYyA9IHRoaXMuX2MsIGQgPSB0aGlzLl9kO1xuXHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGEgKiBkIC0gYiAqIGMpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXHRcdGEgLz0gc2NhbGVYO1xuXHRcdGIgLz0gc2NhbGVYO1xuXG5cdFx0dmFyIHNoZWFyID0gYSAqIGMgKyBiICogZDtcblx0XHRjIC09IGEgKiBzaGVhcjtcblx0XHRkIC09IGIgKiBzaGVhcjtcblxuXHRcdHZhciBzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCk7XG5cdFx0YyAvPSBzY2FsZVk7XG5cdFx0ZCAvPSBzY2FsZVk7XG5cdFx0c2hlYXIgLz0gc2NhbGVZO1xuXG5cdFx0aWYgKGEgKiBkIDwgYiAqIGMpIHtcblx0XHRcdGEgPSAtYTtcblx0XHRcdGIgPSAtYjtcblx0XHRcdHNoZWFyID0gLXNoZWFyO1xuXHRcdFx0c2NhbGVYID0gLXNjYWxlWDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2NhbGluZzogbmV3IFBvaW50KHNjYWxlWCwgc2NhbGVZKSxcblx0XHRcdHJvdGF0aW9uOiAtTWF0aC5hdGFuMihiLCBhKSAqIDE4MCAvIE1hdGguUEksXG5cdFx0XHRzaGVhcmluZzogc2hlYXJcblx0XHR9O1xuXHR9LFxuXG5cdGdldFZhbHVlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFsgdGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5IF07XG5cdH0sXG5cblx0Z2V0VHJhbnNsYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fSxcblxuXHRnZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGVjb21wb3NlKCkgfHwge30pLnNjYWxpbmc7XG5cdH0sXG5cblx0Z2V0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5kZWNvbXBvc2UoKSB8fCB7fSkucm90YXRpb247XG5cdH0sXG5cblx0aW52ZXJ0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZXQgPSB0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHRcdHJldHVybiBkZXQgJiYgbmV3IE1hdHJpeChcblx0XHRcdFx0dGhpcy5fZCAvIGRldCxcblx0XHRcdFx0LXRoaXMuX2MgLyBkZXQsXG5cdFx0XHRcdC10aGlzLl9iIC8gZGV0LFxuXHRcdFx0XHR0aGlzLl9hIC8gZGV0LFxuXHRcdFx0XHQodGhpcy5fYiAqIHRoaXMuX3R5IC0gdGhpcy5fZCAqIHRoaXMuX3R4KSAvIGRldCxcblx0XHRcdFx0KHRoaXMuX2MgKiB0aGlzLl90eCAtIHRoaXMuX2EgKiB0aGlzLl90eSkgLyBkZXQpO1xuXHR9LFxuXG5cdHNoaWZ0bGVzczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgMCwgMCk7XG5cdH0sXG5cblx0YXBwbHlUb0NvbnRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC50cmFuc2Zvcm0odGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fVxufSwgQmFzZS5lYWNoKFsnYScsICdjJywgJ2InLCAnZCcsICd0eCcsICd0eSddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdHByb3AgPSAnXycgKyBuYW1lO1xuXHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpc1twcm9wXTtcblx0fTtcblx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzW3Byb3BdID0gdmFsdWU7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0xpbmUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExpbmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuXHRcdHZhciBhc1ZlY3RvciA9IGZhbHNlO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcblx0XHRcdHRoaXMuX3B4ID0gYXJnMDtcblx0XHRcdHRoaXMuX3B5ID0gYXJnMTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMjtcblx0XHRcdHRoaXMuX3Z5ID0gYXJnMztcblx0XHRcdGFzVmVjdG9yID0gYXJnNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHggPSBhcmcwLng7XG5cdFx0XHR0aGlzLl9weSA9IGFyZzAueTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMS54O1xuXHRcdFx0dGhpcy5fdnkgPSBhcmcxLnk7XG5cdFx0XHRhc1ZlY3RvciA9IGFyZzI7XG5cdFx0fVxuXHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdHRoaXMuX3Z4IC09IHRoaXMuX3B4O1xuXHRcdFx0dGhpcy5fdnkgLT0gdGhpcy5fcHk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3B4LCB0aGlzLl9weSk7XG5cdH0sXG5cblx0Z2V0VmVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3Z4LCB0aGlzLl92eSk7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRWZWN0b3IoKS5nZXRMZW5ndGgoKTtcblx0fSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKGxpbmUsIGlzSW5maW5pdGUpIHtcblx0XHRyZXR1cm4gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRsaW5lLl9weCwgbGluZS5fcHksIGxpbmUuX3Z4LCBsaW5lLl92eSxcblx0XHRcdFx0dHJ1ZSwgaXNJbmZpbml0ZSk7XG5cdH0sXG5cblx0Z2V0U2lkZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTGluZS5nZXRTaWRlKFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0cG9pbnQueCwgcG9pbnQueSwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRwb2ludC54LCBwb2ludC55LCB0cnVlKSk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdGludGVyc2VjdDogZnVuY3Rpb24oYXB4LCBhcHksIGF2eCwgYXZ5LCBicHgsIGJweSwgYnZ4LCBidnksIGFzVmVjdG9yLFxuXHRcdFx0XHRpc0luZmluaXRlKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdGF2eCAtPSBhcHg7XG5cdFx0XHRcdGF2eSAtPSBhcHk7XG5cdFx0XHRcdGJ2eCAtPSBicHg7XG5cdFx0XHRcdGJ2eSAtPSBicHk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3Jvc3MgPSBhdnggKiBidnkgLSBhdnkgKiBidng7XG5cdFx0XHRpZiAoIU51bWVyaWNhbC5pc1plcm8oY3Jvc3MpKSB7XG5cdFx0XHRcdHZhciBkeCA9IGFweCAtIGJweCxcblx0XHRcdFx0XHRkeSA9IGFweSAtIGJweSxcblx0XHRcdFx0XHR0YSA9IChidnggKiBkeSAtIGJ2eSAqIGR4KSAvIGNyb3NzLFxuXHRcdFx0XHRcdHRiID0gKGF2eCAqIGR5IC0gYXZ5ICogZHgpIC8gY3Jvc3M7XG5cdFx0XHRcdGlmIChpc0luZmluaXRlIHx8IDAgPD0gdGEgJiYgdGEgPD0gMSAmJiAwIDw9IHRiICYmIHRiIDw9IDEpXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0XHRhcHggKyB0YSAqIGF2eCxcblx0XHRcdFx0XHRcdFx0XHRhcHkgKyB0YSAqIGF2eSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldFNpZGU6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2eCAtPSBweDtcblx0XHRcdFx0dnkgLT0gcHk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdjJ4ID0geCAtIHB4LFxuXHRcdFx0XHR2MnkgPSB5IC0gcHksXG5cdFx0XHRcdGNjdyA9IHYyeCAqIHZ5IC0gdjJ5ICogdng7XG5cdFx0XHRpZiAoY2N3ID09PSAwKSB7XG5cdFx0XHRcdGNjdyA9IHYyeCAqIHZ4ICsgdjJ5ICogdnk7XG5cdFx0XHRcdGlmIChjY3cgPiAwKSB7XG5cdFx0XHRcdFx0djJ4IC09IHZ4O1xuXHRcdFx0XHRcdHYyeSAtPSB2eTtcblx0XHRcdFx0XHRjY3cgPSB2MnggKiB2eCArIHYyeSAqIHZ5O1xuXHRcdFx0XHRcdGlmIChjY3cgPCAwKVxuXHRcdFx0XHRcdFx0Y2N3ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNjdyA8IDAgPyAtMSA6IGNjdyA+IDAgPyAxIDogMDtcblx0XHR9LFxuXG5cdFx0Z2V0U2lnbmVkRGlzdGFuY2U6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2eCAtPSBweDtcblx0XHRcdFx0dnkgLT0gcHk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gTnVtZXJpY2FsLmlzWmVybyh2eClcblx0XHRcdFx0XHQ/IHZ5ID49IDAgPyBweCAtIHggOiB4IC0gcHhcblx0XHRcdFx0XHQ6IE51bWVyaWNhbC5pc1plcm8odnkpXG5cdFx0XHRcdFx0XHQ/IHZ4ID49IDAgPyB5IC0gcHkgOiBweSAtIHlcblx0XHRcdFx0XHRcdDogKHZ4ICogKHkgLSBweSkgLSB2eSAqICh4IC0gcHgpKSAvIE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIFByb2plY3QgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQcm9qZWN0Jyxcblx0X2xpc3Q6ICdwcm9qZWN0cycsXG5cdF9yZWZlcmVuY2U6ICdwcm9qZWN0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQcm9qZWN0KGVsZW1lbnQpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMsIHRydWUpO1xuXHRcdHRoaXMubGF5ZXJzID0gW107XG5cdFx0dGhpcy5fYWN0aXZlTGF5ZXIgPSBudWxsO1xuXHRcdHRoaXMuc3ltYm9scyA9IFtdO1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZSA9IG5ldyBTdHlsZShudWxsLCBudWxsLCB0aGlzKTtcblx0XHR0aGlzLl92aWV3ID0gVmlldy5jcmVhdGUodGhpcyxcblx0XHRcdFx0ZWxlbWVudCB8fCBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoMSwgMSkpO1xuXHRcdHRoaXMuX3NlbGVjdGVkSXRlbXMgPSB7fTtcblx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCA9IDA7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IDA7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmxheWVycywgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMubGF5ZXJzW2ldLnJlbW92ZSgpO1xuXHRcdHRoaXMuc3ltYm9scyA9IFtdO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxheWVycy5sZW5ndGggPT09IDA7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG5cdFx0aWYgKCFyZW1vdmUuYmFzZS5jYWxsKHRoaXMpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmICh0aGlzLl92aWV3KVxuXHRcdFx0dGhpcy5fdmlldy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmlldztcblx0fSxcblxuXHRnZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50U3R5bGU7XG5cdH0sXG5cblx0c2V0Q3VycmVudFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZS5pbml0aWFsaXplKHN0eWxlKTtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGdldE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY29wZS5zZXR0aW5ncztcblx0fSxcblxuXHRnZXRBY3RpdmVMYXllcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZUxheWVyIHx8IG5ldyBMYXllcih7IHByb2plY3Q6IHRoaXMgfSk7XG5cdH0sXG5cblx0Z2V0U2VsZWN0ZWRJdGVtczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fc2VsZWN0ZWRJdGVtcykge1xuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9zZWxlY3RlZEl0ZW1zW2lkXTtcblx0XHRcdGlmIChpdGVtLmlzSW5zZXJ0ZWQoKSlcblx0XHRcdFx0aXRlbXMucHVzaChpdGVtKTtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdGluc2VydENoaWxkOiBmdW5jdGlvbihpbmRleCwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBMYXllcikge1xuXHRcdFx0aXRlbS5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblx0XHRcdEJhc2Uuc3BsaWNlKHRoaXMubGF5ZXJzLCBbaXRlbV0sIGluZGV4LCAwKTtcblx0XHRcdGl0ZW0uX3NldFByb2plY3QodGhpcywgdHJ1ZSk7XG5cdFx0XHRpZiAodGhpcy5fY2hhbmdlcylcblx0XHRcdFx0aXRlbS5fY2hhbmdlZCg1KTtcblx0XHRcdGlmICghdGhpcy5fYWN0aXZlTGF5ZXIpXG5cdFx0XHRcdHRoaXMuX2FjdGl2ZUxheWVyID0gaXRlbTtcblx0XHR9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtKSB7XG5cdFx0XHQodGhpcy5fYWN0aXZlTGF5ZXJcblx0XHRcdFx0fHwgdGhpcy5pbnNlcnRDaGlsZChpbmRleCwgbmV3IExheWVyKEl0ZW0uTk9fSU5TRVJUKSkpXG5cdFx0XHRcdFx0Lmluc2VydENoaWxkKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpdGVtID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH0sXG5cblx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKHVuZGVmaW5lZCwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRzZWxlY3RlZEl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcztcblx0XHRpZiAoaXRlbS5fc2VsZWN0ZWQpIHtcblx0XHRcdGlmIChzZWxlY3RlZEl0ZW1zW2lkXSAhPT0gaXRlbSkge1xuXHRcdFx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCsrO1xuXHRcdFx0XHRzZWxlY3RlZEl0ZW1zW2lkXSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzZWxlY3RlZEl0ZW1zW2lkXSA9PT0gaXRlbSkge1xuXHRcdFx0dGhpcy5fc2VsZWN0ZWRJdGVtQ291bnQtLTtcblx0XHRcdGRlbGV0ZSBzZWxlY3RlZEl0ZW1zW2lkXTtcblx0XHR9XG5cdH0sXG5cblx0c2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bGF5ZXJzW2ldLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0ZGVzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3RlZEl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcztcblx0XHRmb3IgKHZhciBpIGluIHNlbGVjdGVkSXRlbXMpXG5cdFx0XHRzZWxlY3RlZEl0ZW1zW2ldLnNldEZ1bGx5U2VsZWN0ZWQoZmFsc2UpO1xuXHR9LFxuXG5cdGhpdFRlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdG9wdGlvbnMgPSBIaXRSZXN1bHQuZ2V0T3B0aW9ucyhCYXNlLnJlYWQoYXJndW1lbnRzKSk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgcmVzID0gdGhpcy5sYXllcnNbaV0uX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHJlcykgcmV0dXJuIHJlcztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0SXRlbXM6IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMubGF5ZXJzLCBtYXRjaCk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5sYXllcnMsIG1hdGNoLCBudWxsLCBudWxsLCB0cnVlKVswXSB8fCBudWxsO1xuXHR9LFxuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcblx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5fYWN0aXZlTGF5ZXI7XG5cdFx0cmV0dXJuIEJhc2UuaW1wb3J0SlNPTihqc29uLCBsYXllciAmJiBsYXllci5pc0VtcHR5KCkgJiYgbGF5ZXIpO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBwaXhlbFJhdGlvKSB7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbisrO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0dmFyIHBhcmFtID0gbmV3IEJhc2Uoe1xuXHRcdFx0b2Zmc2V0OiBuZXcgUG9pbnQoMCwgMCksXG5cdFx0XHRwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuXHRcdFx0dmlld01hdHJpeDogbWF0cml4LmlzSWRlbnRpdHkoKSA/IG51bGwgOiBtYXRyaXgsXG5cdFx0XHRtYXRyaWNlczogW25ldyBNYXRyaXgoKV0sXG5cdFx0XHR1cGRhdGVNYXRyaXg6IHRydWVcblx0XHR9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGF5ZXJzID0gdGhpcy5sYXllcnMsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bGF5ZXJzW2ldLmRyYXcoY3R4LCBwYXJhbSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblxuXHRcdGlmICh0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCA+IDApIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc3Ryb2tlV2lkdGggPSAxO1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcyxcblx0XHRcdFx0c2l6ZSA9IHRoaXMuX3Njb3BlLnNldHRpbmdzLmhhbmRsZVNpemUsXG5cdFx0XHRcdHZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uO1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gaXRlbXMpXG5cdFx0XHRcdGl0ZW1zW2lkXS5fZHJhd1NlbGVjdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgaXRlbXMsIHZlcnNpb24pO1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgU3ltYm9sID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTeW1ib2wnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN5bWJvbChpdGVtLCBkb250Q2VudGVyKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KCk7XG5cdFx0dGhpcy5wcm9qZWN0ID0gcGFwZXIucHJvamVjdDtcblx0XHR0aGlzLnByb2plY3Quc3ltYm9scy5wdXNoKHRoaXMpO1xuXHRcdGlmIChpdGVtKVxuXHRcdFx0dGhpcy5zZXREZWZpbml0aW9uKGl0ZW0sIGRvbnRDZW50ZXIpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gZGljdGlvbmFyeS5hZGQodGhpcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX2NsYXNzLCB0aGlzLl9kZWZpbml0aW9uXSxcblx0XHRcdFx0XHRvcHRpb25zLCBmYWxzZSwgZGljdGlvbmFyeSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0aWYgKGZsYWdzICYgOCkge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcblx0XHR9XG5cdFx0aWYgKGZsYWdzICYgMSkge1xuXHRcdFx0dGhpcy5wcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdldERlZmluaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuXHR9LFxuXG5cdHNldERlZmluaXRpb246IGZ1bmN0aW9uKGl0ZW0sIF9kb250Q2VudGVyKSB7XG5cdFx0aWYgKGl0ZW0uX3BhcmVudFN5bWJvbClcblx0XHRcdGl0ZW0gPSBpdGVtLmNsb25lKCk7XG5cdFx0aWYgKHRoaXMuX2RlZmluaXRpb24pXG5cdFx0XHR0aGlzLl9kZWZpbml0aW9uLl9wYXJlbnRTeW1ib2wgPSBudWxsO1xuXHRcdHRoaXMuX2RlZmluaXRpb24gPSBpdGVtO1xuXHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0aXRlbS5zZXRTZWxlY3RlZChmYWxzZSk7XG5cdFx0aWYgKCFfZG9udENlbnRlcilcblx0XHRcdGl0ZW0uc2V0UG9zaXRpb24obmV3IFBvaW50KCkpO1xuXHRcdGl0ZW0uX3BhcmVudFN5bWJvbCA9IHRoaXM7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRwbGFjZTogZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRyZXR1cm4gbmV3IFBsYWNlZFN5bWJvbCh0aGlzLCBwb3NpdGlvbik7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU3ltYm9sKHRoaXMuX2RlZmluaXRpb24uY2xvbmUoZmFsc2UpKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdHJldHVybiBzeW1ib2wgPT09IHRoaXNcblx0XHRcdFx0fHwgc3ltYm9sICYmIHRoaXMuZGVmaW5pdGlvbi5lcXVhbHMoc3ltYm9sLmRlZmluaXRpb24pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9XG59KTtcblxudmFyIEl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cdHN0YXRpY3M6IHtcblx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChzcmMpIHtcblx0XHRcdGlmIChzcmMuX3NlcmlhbGl6ZUZpZWxkcylcblx0XHRcdFx0c3JjLl9zZXJpYWxpemVGaWVsZHMgPSBuZXcgQmFzZShcblx0XHRcdFx0XHRcdHRoaXMucHJvdG90eXBlLl9zZXJpYWxpemVGaWVsZHMsIHNyYy5fc2VyaWFsaXplRmllbGRzKTtcblx0XHRcdHJldHVybiBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHROT19JTlNFUlQ6IHsgaW5zZXJ0OiBmYWxzZSB9XG5cdH0sXG5cblx0X2NsYXNzOiAnSXRlbScsXG5cdF9hcHBseU1hdHJpeDogdHJ1ZSxcblx0X2NhbkFwcGx5TWF0cml4OiB0cnVlLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IGZhbHNlLFxuXHRfc2VsZWN0Q2hpbGRyZW46IGZhbHNlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0bmFtZTogbnVsbCxcblx0XHRhcHBseU1hdHJpeDogbnVsbCxcblx0XHRtYXRyaXg6IG5ldyBNYXRyaXgoKSxcblx0XHRwaXZvdDogbnVsbCxcblx0XHRsb2NrZWQ6IGZhbHNlLFxuXHRcdHZpc2libGU6IHRydWUsXG5cdFx0YmxlbmRNb2RlOiAnbm9ybWFsJyxcblx0XHRvcGFjaXR5OiAxLFxuXHRcdGd1aWRlOiBmYWxzZSxcblx0XHRzZWxlY3RlZDogZmFsc2UsXG5cdFx0Y2xpcE1hc2s6IGZhbHNlLFxuXHRcdGRhdGE6IHt9XG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gSXRlbSgpIHtcblx0fSxcblxuXHRfaW5pdGlhbGl6ZTogZnVuY3Rpb24ocHJvcHMsIHBvaW50KSB7XG5cdFx0dmFyIGhhc1Byb3BzID0gcHJvcHMgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHByb3BzKSxcblx0XHRcdGludGVybmFsID0gaGFzUHJvcHMgJiYgcHJvcHMuaW50ZXJuYWwgPT09IHRydWUsXG5cdFx0XHRtYXRyaXggPSB0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCksXG5cdFx0XHRwcm9qZWN0ID0gaGFzUHJvcHMgJiYgcHJvcHMucHJvamVjdCB8fCBwYXBlci5wcm9qZWN0O1xuXHRcdGlmICghaW50ZXJuYWwpXG5cdFx0XHR0aGlzLl9pZCA9IFVJRC5nZXQoKTtcblx0XHR0aGlzLl9hcHBseU1hdHJpeCA9IHRoaXMuX2NhbkFwcGx5TWF0cml4ICYmIHBhcGVyLnNldHRpbmdzLmFwcGx5TWF0cml4O1xuXHRcdGlmIChwb2ludClcblx0XHRcdG1hdHJpeC50cmFuc2xhdGUocG9pbnQpO1xuXHRcdG1hdHJpeC5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX3N0eWxlID0gbmV3IFN0eWxlKHByb2plY3QuX2N1cnJlbnRTdHlsZSwgdGhpcywgcHJvamVjdCk7XG5cdFx0aWYgKCF0aGlzLl9wcm9qZWN0KSB7XG5cdFx0XHRpZiAoaW50ZXJuYWwgfHwgaGFzUHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuXHRcdFx0fSBlbHNlIGlmIChoYXNQcm9wcyAmJiBwcm9wcy5wYXJlbnQpIHtcblx0XHRcdFx0dGhpcy5zZXRQYXJlbnQocHJvcHMucGFyZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdChwcm9qZWN0Ll9hY3RpdmVMYXllciB8fCBuZXcgTGF5ZXIoKSkuYWRkQ2hpbGQodGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChoYXNQcm9wcyAmJiBwcm9wcyAhPT0gSXRlbS5OT19JTlNFUlQpXG5cdFx0XHR0aGlzLl9zZXQocHJvcHMsIHsgaW5zZXJ0OiB0cnVlLCBwcm9qZWN0OiB0cnVlLCBwYXJlbnQ6IHRydWUgfSxcblx0XHRcdFx0XHR0cnVlKTtcblx0XHRyZXR1cm4gaGFzUHJvcHM7XG5cdH0sXG5cblx0X2V2ZW50czogbmV3IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG1vdXNlRmxhZ3MgPSB7XG5cdFx0XHRtb3VzZWRvd246IHtcblx0XHRcdFx0bW91c2Vkb3duOiAxLFxuXHRcdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRcdGNsaWNrOiAxLFxuXHRcdFx0XHRkb3VibGVjbGljazogMVxuXHRcdFx0fSxcblx0XHRcdG1vdXNldXA6IHtcblx0XHRcdFx0bW91c2V1cDogMSxcblx0XHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0XHRjbGljazogMSxcblx0XHRcdFx0ZG91YmxlY2xpY2s6IDFcblx0XHRcdH0sXG5cdFx0XHRtb3VzZW1vdmU6IHtcblx0XHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0XHRtb3VzZW1vdmU6IDEsXG5cdFx0XHRcdG1vdXNlZW50ZXI6IDEsXG5cdFx0XHRcdG1vdXNlbGVhdmU6IDFcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIG1vdXNlRXZlbnQgPSB7XG5cdFx0XHRpbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdHZhciBjb3VudGVycyA9IHRoaXMuZ2V0VmlldygpLl9ldmVudENvdW50ZXJzO1xuXHRcdFx0XHRpZiAoY291bnRlcnMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbW91c2VGbGFncykge1xuXHRcdFx0XHRcdFx0Y291bnRlcnNba2V5XSA9IChjb3VudGVyc1trZXldIHx8IDApXG5cdFx0XHRcdFx0XHRcdFx0KyAobW91c2VGbGFnc1trZXldW3R5cGVdIHx8IDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHR2YXIgY291bnRlcnMgPSB0aGlzLmdldFZpZXcoKS5fZXZlbnRDb3VudGVycztcblx0XHRcdFx0aWYgKGNvdW50ZXJzKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG1vdXNlRmxhZ3MpXG5cdFx0XHRcdFx0XHRjb3VudGVyc1trZXldIC09IG1vdXNlRmxhZ3Nba2V5XVt0eXBlXSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJldHVybiBCYXNlLmVhY2goWydvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZURyYWcnLCAnb25DbGljaycsXG5cdFx0XHQnb25Eb3VibGVDbGljaycsICdvbk1vdXNlTW92ZScsICdvbk1vdXNlRW50ZXInLCAnb25Nb3VzZUxlYXZlJ10sXG5cdFx0XHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdHRoaXNbbmFtZV0gPSBtb3VzZUV2ZW50O1xuXHRcdFx0fSwge1xuXHRcdFx0XHRvbkZyYW1lOiB7XG5cdFx0XHRcdFx0aW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hbmltYXRlSXRlbSh0cnVlKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hbmltYXRlSXRlbShmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdG9uTG9hZDoge31cblx0XHRcdH1cblx0XHQpO1xuXHR9LFxuXG5cdF9hbmltYXRlSXRlbTogZnVuY3Rpb24oYW5pbWF0ZSkge1xuXHRcdHRoaXMuZ2V0VmlldygpLl9hbmltYXRlSXRlbSh0aGlzLCBhbmltYXRlKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0dmFyIHByb3BzID0ge30sXG5cdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZShmaWVsZHMpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBmaWVsZHMpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhhdFtrZXldO1xuXHRcdFx0XHRpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBrZXkgPT09ICdsZWFkaW5nJ1xuXHRcdFx0XHRcdFx0PyBmaWVsZHMuZm9udFNpemUgKiAxLjIgOiBmaWVsZHNba2V5XSkpIHtcblx0XHRcdFx0XHRwcm9wc1trZXldID0gQmFzZS5zZXJpYWxpemUodmFsdWUsIG9wdGlvbnMsXG5cdFx0XHRcdFx0XHRcdGtleSAhPT0gJ2RhdGEnLCBkaWN0aW9uYXJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlcmlhbGl6ZSh0aGlzLl9zZXJpYWxpemVGaWVsZHMpO1xuXHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBHcm91cCkpXG5cdFx0XHRzZXJpYWxpemUodGhpcy5fc3R5bGUuX2RlZmF1bHRzKTtcblx0XHRyZXR1cm4gWyB0aGlzLl9jbGFzcywgcHJvcHMgXTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oZmxhZ3MpIHtcblx0XHR2YXIgc3ltYm9sID0gdGhpcy5fcGFyZW50U3ltYm9sLFxuXHRcdFx0Y2FjaGVQYXJlbnQgPSB0aGlzLl9wYXJlbnQgfHwgc3ltYm9sLFxuXHRcdFx0cHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0aWYgKGZsYWdzICYgOCkge1xuXHRcdFx0dGhpcy5fYm91bmRzID0gdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2VkID1cblx0XHRcdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSB0aGlzLl9jdXJyZW50UGF0aCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKGNhY2hlUGFyZW50XG5cdFx0XHRcdCYmIChmbGFncyAmIDQwKSkge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZShjYWNoZVBhcmVudCk7XG5cdFx0fVxuXHRcdGlmIChmbGFncyAmIDIpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUodGhpcyk7XG5cdFx0fVxuXHRcdGlmIChwcm9qZWN0KSB7XG5cdFx0XHRpZiAoZmxhZ3MgJiAxKSB7XG5cdFx0XHRcdHByb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChwcm9qZWN0Ll9jaGFuZ2VzKSB7XG5cdFx0XHRcdHZhciBlbnRyeSA9IHByb2plY3QuX2NoYW5nZXNCeUlkW3RoaXMuX2lkXTtcblx0XHRcdFx0aWYgKGVudHJ5KSB7XG5cdFx0XHRcdFx0ZW50cnkuZmxhZ3MgfD0gZmxhZ3M7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZW50cnkgPSB7IGl0ZW06IHRoaXMsIGZsYWdzOiBmbGFncyB9O1xuXHRcdFx0XHRcdHByb2plY3QuX2NoYW5nZXNCeUlkW3RoaXMuX2lkXSA9IGVudHJ5O1xuXHRcdFx0XHRcdHByb2plY3QuX2NoYW5nZXMucHVzaChlbnRyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHN5bWJvbClcblx0XHRcdHN5bWJvbC5fY2hhbmdlZChmbGFncyk7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbihwcm9wcykge1xuXHRcdGlmIChwcm9wcylcblx0XHRcdHRoaXMuX3NldChwcm9wcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0SWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pZDtcblx0fSxcblxuXHRnZXROYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmFtZTtcblx0fSxcblxuXHRzZXROYW1lOiBmdW5jdGlvbihuYW1lLCB1bmlxdWUpIHtcblxuXHRcdGlmICh0aGlzLl9uYW1lKVxuXHRcdFx0dGhpcy5fcmVtb3ZlTmFtZWQoKTtcblx0XHRpZiAobmFtZSA9PT0gKCtuYW1lKSArICcnKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdOYW1lcyBjb25zaXN0aW5nIG9ubHkgb2YgbnVtYmVycyBhcmUgbm90IHN1cHBvcnRlZC4nKTtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChuYW1lICYmIHBhcmVudCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IHBhcmVudC5fbmFtZWRDaGlsZHJlbixcblx0XHRcdFx0b3JpZyA9IG5hbWUsXG5cdFx0XHRcdGkgPSAxO1xuXHRcdFx0d2hpbGUgKHVuaXF1ZSAmJiBjaGlsZHJlbltuYW1lXSlcblx0XHRcdFx0bmFtZSA9IG9yaWcgKyAnICcgKyAoaSsrKTtcblx0XHRcdChuYW1lZENoaWxkcmVuW25hbWVdID0gbmFtZWRDaGlsZHJlbltuYW1lXSB8fCBbXSkucHVzaCh0aGlzKTtcblx0XHRcdGNoaWxkcmVuW25hbWVdID0gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5fbmFtZSA9IG5hbWUgfHwgdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2NoYW5nZWQoMTI4KTtcblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0eWxlO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuZ2V0U3R5bGUoKS5zZXQoc3R5bGUpO1xuXHR9XG59LCBCYXNlLmVhY2goWydsb2NrZWQnLCAndmlzaWJsZScsICdibGVuZE1vZGUnLCAnb3BhY2l0eScsICdndWlkZSddLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRuYW1lID0gJ18nICsgbmFtZTtcblx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHRcdH07XG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzW25hbWVdKSB7XG5cdFx0XHRcdHRoaXNbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlZChuYW1lID09PSAnX2xvY2tlZCdcblx0XHRcdFx0XHRcdD8gMTI4IDogMTI5KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxue30pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9sb2NrZWQ6IGZhbHNlLFxuXG5cdF92aXNpYmxlOiB0cnVlLFxuXG5cdF9ibGVuZE1vZGU6ICdub3JtYWwnLFxuXG5cdF9vcGFjaXR5OiAxLFxuXG5cdF9ndWlkZTogZmFsc2UsXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoY2hpbGRyZW5baV0uaXNTZWxlY3RlZCgpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkLCBub0NoaWxkcmVuKSB7XG5cdFx0aWYgKCFub0NoaWxkcmVuICYmIHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdGlmICgoc2VsZWN0ZWQgPSAhIXNlbGVjdGVkKSBeIHRoaXMuX3NlbGVjdGVkKSB7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xuXHRcdFx0dGhpcy5fcHJvamVjdC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMjkpO1xuXHRcdH1cblx0fSxcblxuXHRfc2VsZWN0ZWQ6IGZhbHNlLFxuXG5cdGlzRnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuICYmIHRoaXMuX3NlbGVjdGVkKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKCFjaGlsZHJlbltpXS5pc0Z1bGx5U2VsZWN0ZWQoKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uc2V0RnVsbHlTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdHRoaXMuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIHRydWUpO1xuXHR9LFxuXG5cdGlzQ2xpcE1hc2s6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbGlwTWFzaztcblx0fSxcblxuXHRzZXRDbGlwTWFzazogZnVuY3Rpb24oY2xpcE1hc2spIHtcblx0XHRpZiAodGhpcy5fY2xpcE1hc2sgIT0gKGNsaXBNYXNrID0gISFjbGlwTWFzaykpIHtcblx0XHRcdHRoaXMuX2NsaXBNYXNrID0gY2xpcE1hc2s7XG5cdFx0XHRpZiAoY2xpcE1hc2spIHtcblx0XHRcdFx0dGhpcy5zZXRGaWxsQ29sb3IobnVsbCk7XG5cdFx0XHRcdHRoaXMuc2V0U3Ryb2tlQ29sb3IobnVsbCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDEyOSk7XG5cdFx0XHRpZiAodGhpcy5fcGFyZW50KVxuXHRcdFx0XHR0aGlzLl9wYXJlbnQuX2NoYW5nZWQoMTAyNCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jbGlwTWFzazogZmFsc2UsXG5cblx0Z2V0RGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9kYXRhKVxuXHRcdFx0dGhpcy5fZGF0YSA9IHt9O1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9LFxuXG5cdHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR0aGlzLl9kYXRhID0gZGF0YTtcblx0fSxcblxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24sXG5cdFx0XHRjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRpZiAoIXBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdDtcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gPSBwaXZvdFxuXHRcdFx0XHRcdD8gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwaXZvdClcblx0XHRcdFx0XHQ6IHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IGN0b3IocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdGhpcywgJ3NldFBvc2l0aW9uJyk7XG5cdH0sXG5cblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5zdWJ0cmFjdCh0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH0sXG5cblx0Z2V0UGl2b3Q6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuXHRcdGlmIChwaXZvdCkge1xuXHRcdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdFx0cGl2b3QgPSBuZXcgY3RvcihwaXZvdC54LCBwaXZvdC55LCB0aGlzLCAnc2V0UGl2b3QnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBpdm90O1xuXHR9LFxuXG5cdHNldFBpdm90OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9waXZvdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IGNsb25lOiB0cnVlLCByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRfcGl2b3Q6IG51bGwsXG59LCBCYXNlLmVhY2goWydib3VuZHMnLCAnc3Ryb2tlQm91bmRzJywgJ2hhbmRsZUJvdW5kcycsICdyb3VnaEJvdW5kcycsXG5cdFx0J2ludGVybmFsQm91bmRzJywgJ2ludGVybmFsUm91Z2hCb3VuZHMnXSxcblx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIGdldHRlciA9ICdnZXQnICsgQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0XHRtYXRjaCA9IGtleS5tYXRjaCgvXmludGVybmFsKC4qKSQvKSxcblx0XHRcdGludGVybmFsR2V0dGVyID0gbWF0Y2ggPyAnZ2V0JyArIG1hdGNoWzFdIDogbnVsbDtcblx0XHR0aGlzW2dldHRlcl0gPSBmdW5jdGlvbihfbWF0cml4KSB7XG5cdFx0XHR2YXIgYm91bmRzR2V0dGVyID0gdGhpcy5fYm91bmRzR2V0dGVyLFxuXHRcdFx0XHRuYW1lID0gIWludGVybmFsR2V0dGVyICYmICh0eXBlb2YgYm91bmRzR2V0dGVyID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyBib3VuZHNHZXR0ZXIgOiBib3VuZHNHZXR0ZXIgJiYgYm91bmRzR2V0dGVyW2dldHRlcl0pXG5cdFx0XHRcdFx0XHR8fCBnZXR0ZXIsXG5cdFx0XHRcdGJvdW5kcyA9IHRoaXMuX2dldENhY2hlZEJvdW5kcyhuYW1lLCBfbWF0cml4LCB0aGlzLFxuXHRcdFx0XHRcdFx0aW50ZXJuYWxHZXR0ZXIpO1xuXHRcdFx0cmV0dXJuIGtleSA9PT0gJ2JvdW5kcydcblx0XHRcdFx0XHQ/IG5ldyBMaW5rZWRSZWN0YW5nbGUoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsXG5cdFx0XHRcdFx0XHRcdGJvdW5kcy5oZWlnaHQsIHRoaXMsICdzZXRCb3VuZHMnKVxuXHRcdFx0XHRcdDogYm91bmRzO1xuXHRcdH07XG5cdH0sXG57XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoIWNoaWxkcmVuIHx8IGNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHRJdGVtLl91cGRhdGVCb3VuZHNDYWNoZSh0aGlzLCBjYWNoZUl0ZW0pO1xuXHRcdHZhciB4MSA9IEluZmluaXR5LFxuXHRcdFx0eDIgPSAteDEsXG5cdFx0XHR5MSA9IHgxLFxuXHRcdFx0eTIgPSB4Mjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQuX3Zpc2libGUgJiYgIWNoaWxkLmlzRW1wdHkoKSkge1xuXHRcdFx0XHR2YXIgcmVjdCA9IGNoaWxkLl9nZXRDYWNoZWRCb3VuZHMoZ2V0dGVyLFxuXHRcdFx0XHRcdFx0bWF0cml4ICYmIG1hdHJpeC5jaGFpbihjaGlsZC5fbWF0cml4KSwgY2FjaGVJdGVtKTtcblx0XHRcdFx0eDEgPSBNYXRoLm1pbihyZWN0LngsIHgxKTtcblx0XHRcdFx0eTEgPSBNYXRoLm1pbihyZWN0LnksIHkxKTtcblx0XHRcdFx0eDIgPSBNYXRoLm1heChyZWN0LnggKyByZWN0LndpZHRoLCB4Mik7XG5cdFx0XHRcdHkyID0gTWF0aC5tYXgocmVjdC55ICsgcmVjdC5oZWlnaHQsIHkyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGlzRmluaXRlKHgxKVxuXHRcdFx0XHQ/IG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKVxuXHRcdFx0XHQ6IG5ldyBSZWN0YW5nbGUoKTtcblx0fSxcblxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCksXG5cdFx0XHRjZW50ZXIgPSByZWN0LmdldENlbnRlcigpO1xuXHRcdG1hdHJpeC50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRpZiAocmVjdC53aWR0aCAhPSBib3VuZHMud2lkdGggfHwgcmVjdC5oZWlnaHQgIT0gYm91bmRzLmhlaWdodCkge1xuXHRcdFx0bWF0cml4LnNjYWxlKFxuXHRcdFx0XHRcdGJvdW5kcy53aWR0aCAhPSAwID8gcmVjdC53aWR0aCAvIGJvdW5kcy53aWR0aCA6IDEsXG5cdFx0XHRcdFx0Ym91bmRzLmhlaWdodCAhPSAwID8gcmVjdC5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0IDogMSk7XG5cdFx0fVxuXHRcdGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKTtcblx0XHRtYXRyaXgudHJhbnNsYXRlKC1jZW50ZXIueCwgLWNlbnRlci55KTtcblx0XHR0aGlzLnRyYW5zZm9ybShtYXRyaXgpO1xuXHR9LFxuXG5cdF9nZXRDYWNoZWRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0sIGludGVybmFsR2V0dGVyKSB7XG5cdFx0bWF0cml4ID0gbWF0cml4ICYmIG1hdHJpeC5vck51bGxJZklkZW50aXR5KCk7XG5cdFx0dmFyIF9tYXRyaXggPSBpbnRlcm5hbEdldHRlciA/IG51bGwgOiB0aGlzLl9tYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpLFxuXHRcdFx0Y2FjaGUgPSAoIW1hdHJpeCB8fCBtYXRyaXguZXF1YWxzKF9tYXRyaXgpKSAmJiBnZXR0ZXI7XG5cdFx0SXRlbS5fdXBkYXRlQm91bmRzQ2FjaGUodGhpcy5fcGFyZW50IHx8IHRoaXMuX3BhcmVudFN5bWJvbCwgY2FjaGVJdGVtKTtcblx0XHRpZiAoY2FjaGUgJiYgdGhpcy5fYm91bmRzICYmIHRoaXMuX2JvdW5kc1tjYWNoZV0pXG5cdFx0XHRyZXR1cm4gdGhpcy5fYm91bmRzW2NhY2hlXS5jbG9uZSgpO1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9nZXRCb3VuZHMoaW50ZXJuYWxHZXR0ZXIgfHwgZ2V0dGVyLFxuXHRcdFx0XHRtYXRyaXggfHwgX21hdHJpeCwgY2FjaGVJdGVtKTtcblx0XHRpZiAoY2FjaGUpIHtcblx0XHRcdGlmICghdGhpcy5fYm91bmRzKVxuXHRcdFx0XHR0aGlzLl9ib3VuZHMgPSB7fTtcblx0XHRcdHZhciBjYWNoZWQgPSB0aGlzLl9ib3VuZHNbY2FjaGVdID0gYm91bmRzLmNsb25lKCk7XG5cdFx0XHRjYWNoZWQuX2ludGVybmFsID0gISFpbnRlcm5hbEdldHRlcjtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0X3VwZGF0ZUJvdW5kc0NhY2hlOiBmdW5jdGlvbihwYXJlbnQsIGl0ZW0pIHtcblx0XHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRcdFx0cmVmID0gcGFyZW50Ll9ib3VuZHNDYWNoZSA9IHBhcmVudC5fYm91bmRzQ2FjaGUgfHwge1xuXHRcdFx0XHRcdFx0aWRzOiB7fSxcblx0XHRcdFx0XHRcdGxpc3Q6IFtdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCFyZWYuaWRzW2lkXSkge1xuXHRcdFx0XHRcdHJlZi5saXN0LnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0cmVmLmlkc1tpZF0gPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jbGVhckJvdW5kc0NhY2hlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgY2FjaGUgPSBpdGVtLl9ib3VuZHNDYWNoZTtcblx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHRpdGVtLl9ib3VuZHMgPSBpdGVtLl9wb3NpdGlvbiA9IGl0ZW0uX2JvdW5kc0NhY2hlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNhY2hlLmxpc3QsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0dmFyIG90aGVyID0gbGlzdFtpXTtcblx0XHRcdFx0XHRpZiAob3RoZXIgIT09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdG90aGVyLl9ib3VuZHMgPSBvdGhlci5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIuX2JvdW5kc0NhY2hlKVxuXHRcdFx0XHRcdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKG90aGVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxufSksIHtcblx0YmVhbnM6IHRydWUsXG5cblx0X2RlY29tcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RlY29tcG9zZWQgPSB0aGlzLl9tYXRyaXguZGVjb21wb3NlKCk7XG5cdH0sXG5cblx0Z2V0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZCB8fCB0aGlzLl9kZWNvbXBvc2UoKTtcblx0XHRyZXR1cm4gZGVjb21wb3NlZCAmJiBkZWNvbXBvc2VkLnJvdGF0aW9uO1xuXHR9LFxuXG5cdHNldFJvdGF0aW9uOiBmdW5jdGlvbihyb3RhdGlvbikge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXHRcdGlmIChjdXJyZW50ICE9IG51bGwgJiYgcm90YXRpb24gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkO1xuXHRcdFx0dGhpcy5yb3RhdGUocm90YXRpb24gLSBjdXJyZW50KTtcblx0XHRcdGRlY29tcG9zZWQucm90YXRpb24gPSByb3RhdGlvbjtcblx0XHRcdHRoaXMuX2RlY29tcG9zZWQgPSBkZWNvbXBvc2VkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTY2FsaW5nOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQgfHwgdGhpcy5fZGVjb21wb3NlKCksXG5cdFx0XHRzY2FsaW5nID0gZGVjb21wb3NlZCAmJiBkZWNvbXBvc2VkLnNjYWxpbmcsXG5cdFx0XHRjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gc2NhbGluZyAmJiBuZXcgY3RvcihzY2FsaW5nLngsIHNjYWxpbmcueSwgdGhpcywgJ3NldFNjYWxpbmcnKTtcblx0fSxcblxuXHRzZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0U2NhbGluZygpO1xuXHRcdGlmIChjdXJyZW50KSB7XG5cdFx0XHR2YXIgc2NhbGluZyA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IGNsb25lOiB0cnVlIH0pLFxuXHRcdFx0XHRkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZDtcblx0XHRcdHRoaXMuc2NhbGUoc2NhbGluZy54IC8gY3VycmVudC54LCBzY2FsaW5nLnkgLyBjdXJyZW50LnkpO1xuXHRcdFx0ZGVjb21wb3NlZC5zY2FsaW5nID0gc2NhbGluZztcblx0XHRcdHRoaXMuX2RlY29tcG9zZWQgPSBkZWNvbXBvc2VkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXg7XG5cdH0sXG5cblx0c2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuXHRcdG1hdHJpeC5pbml0aWFsaXplLmFwcGx5KG1hdHJpeCwgYXJndW1lbnRzKTtcblx0XHRpZiAodGhpcy5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRHbG9iYWxNYXRyaXg6IGZ1bmN0aW9uKF9kb250Q2xvbmUpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4LFxuXHRcdFx0dXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG5cdFx0aWYgKG1hdHJpeCAmJiBtYXRyaXguX3VwZGF0ZVZlcnNpb24gIT09IHVwZGF0ZVZlcnNpb24pXG5cdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdGlmICghbWF0cml4KSB7XG5cdFx0XHRtYXRyaXggPSB0aGlzLl9nbG9iYWxNYXRyaXggPSB0aGlzLl9tYXRyaXguY2xvbmUoKTtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0XHRpZiAocGFyZW50KVxuXHRcdFx0XHRtYXRyaXgucHJlQ29uY2F0ZW5hdGUocGFyZW50LmdldEdsb2JhbE1hdHJpeCh0cnVlKSk7XG5cdFx0XHRtYXRyaXguX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuXHRcdH1cblx0XHRyZXR1cm4gX2RvbnRDbG9uZSA/IG1hdHJpeCA6IG1hdHJpeC5jbG9uZSgpO1xuXHR9LFxuXG5cdGdldEFwcGx5TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXBwbHlNYXRyaXg7XG5cdH0sXG5cblx0c2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uKGFwcGx5KSB7XG5cdFx0aWYgKHRoaXMuX2FwcGx5TWF0cml4ID0gdGhpcy5fY2FuQXBwbHlNYXRyaXggJiYgISFhcHBseSlcblx0XHRcdHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHR9LFxuXG5cdGdldFRyYW5zZm9ybUNvbnRlbnQ6ICcjZ2V0QXBwbHlNYXRyaXgnLFxuXHRzZXRUcmFuc2Zvcm1Db250ZW50OiAnI3NldEFwcGx5TWF0cml4Jyxcbn0sIHtcblx0Z2V0UHJvamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3Q7XG5cdH0sXG5cblx0X3NldFByb2plY3Q6IGZ1bmN0aW9uKHByb2plY3QsIGluc3RhbGxFdmVudHMpIHtcblx0XHRpZiAodGhpcy5fcHJvamVjdCAhPT0gcHJvamVjdCkge1xuXHRcdFx0aWYgKHRoaXMuX3Byb2plY3QpXG5cdFx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuXHRcdFx0dGhpcy5fcHJvamVjdCA9IHByb2plY3Q7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5fc2V0UHJvamVjdChwcm9qZWN0KTtcblx0XHRcdGluc3RhbGxFdmVudHMgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoaW5zdGFsbEV2ZW50cylcblx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHModHJ1ZSk7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuZ2V0VmlldygpO1xuXHR9LFxuXG5cdF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbiBfaW5zdGFsbEV2ZW50cyhpbnN0YWxsKSB7XG5cdFx0X2luc3RhbGxFdmVudHMuYmFzZS5jYWxsKHRoaXMsIGluc3RhbGwpO1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0uX2luc3RhbGxFdmVudHMoaW5zdGFsbCk7XG5cdH0sXG5cblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzO1xuXHRcdHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIExheWVyKVxuXHRcdFx0XHRyZXR1cm4gcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQ7XG5cdH0sXG5cblx0c2V0UGFyZW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0uYWRkQ2hpbGQodGhpcyk7XG5cdH0sXG5cblx0Z2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbjtcblx0fSxcblxuXHRzZXRDaGlsZHJlbjogZnVuY3Rpb24oaXRlbXMpIHtcblx0XHR0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG5cdFx0dGhpcy5hZGRDaGlsZHJlbihpdGVtcyk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0TGFzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW5bdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMV1cblx0XHRcdFx0fHwgbnVsbDtcblx0fSxcblxuXHRnZXROZXh0U2libGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuW3RoaXMuX2luZGV4ICsgMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5fcGFyZW50Ll9jaGlsZHJlblt0aGlzLl9pbmRleCAtIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSA9PT0gdGhpcyB8fCBpdGVtICYmIHRoaXMuX2NsYXNzID09PSBpdGVtLl9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9zdHlsZS5lcXVhbHMoaXRlbS5fc3R5bGUpXG5cdFx0XHRcdCYmIHRoaXMuX21hdHJpeC5lcXVhbHMoaXRlbS5fbWF0cml4KVxuXHRcdFx0XHQmJiB0aGlzLl9sb2NrZWQgPT09IGl0ZW0uX2xvY2tlZFxuXHRcdFx0XHQmJiB0aGlzLl92aXNpYmxlID09PSBpdGVtLl92aXNpYmxlXG5cdFx0XHRcdCYmIHRoaXMuX2JsZW5kTW9kZSA9PT0gaXRlbS5fYmxlbmRNb2RlXG5cdFx0XHRcdCYmIHRoaXMuX29wYWNpdHkgPT09IGl0ZW0uX29wYWNpdHlcblx0XHRcdFx0JiYgdGhpcy5fY2xpcE1hc2sgPT09IGl0ZW0uX2NsaXBNYXNrXG5cdFx0XHRcdCYmIHRoaXMuX2d1aWRlID09PSBpdGVtLl9ndWlkZVxuXHRcdFx0XHQmJiB0aGlzLl9lcXVhbHMoaXRlbSlcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBCYXNlLmVxdWFscyh0aGlzLl9jaGlsZHJlbiwgaXRlbS5fY2hpbGRyZW4pO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUobmV3IHRoaXMuY29uc3RydWN0b3IoSXRlbS5OT19JTlNFUlQpLCBpbnNlcnQpO1xuXHR9LFxuXG5cdF9jbG9uZTogZnVuY3Rpb24oY29weSwgaW5zZXJ0LCBpbmNsdWRlTWF0cml4KSB7XG5cdFx0dmFyIGtleXMgPSBbJ19sb2NrZWQnLCAnX3Zpc2libGUnLCAnX2JsZW5kTW9kZScsICdfb3BhY2l0eScsXG5cdFx0XHRcdCdfY2xpcE1hc2snLCAnX2d1aWRlJ10sXG5cdFx0XHRjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGNvcHkuc2V0U3R5bGUodGhpcy5fc3R5bGUpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb3B5LmFkZENoaWxkKGNoaWxkcmVuW2ldLmNsb25lKGZhbHNlKSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSlcblx0XHRcdFx0Y29weVtrZXldID0gdGhpc1trZXldO1xuXHRcdH1cblx0XHRpZiAoaW5jbHVkZU1hdHJpeCAhPT0gZmFsc2UpXG5cdFx0XHRjb3B5Ll9tYXRyaXguaW5pdGlhbGl6ZSh0aGlzLl9tYXRyaXgpO1xuXHRcdGNvcHkuc2V0QXBwbHlNYXRyaXgodGhpcy5fYXBwbHlNYXRyaXgpO1xuXHRcdGNvcHkuc2V0UGl2b3QodGhpcy5fcGl2b3QpO1xuXHRcdGNvcHkuc2V0U2VsZWN0ZWQodGhpcy5fc2VsZWN0ZWQpO1xuXHRcdGNvcHkuX2RhdGEgPSB0aGlzLl9kYXRhID8gQmFzZS5jbG9uZSh0aGlzLl9kYXRhKSA6IG51bGw7XG5cdFx0aWYgKGluc2VydCB8fCBpbnNlcnQgPT09IHVuZGVmaW5lZClcblx0XHRcdGNvcHkuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHRjb3B5LnNldE5hbWUodGhpcy5fbmFtZSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIGNvcHk7XG5cdH0sXG5cblx0Y29weVRvOiBmdW5jdGlvbihpdGVtT3JQcm9qZWN0KSB7XG5cdFx0cmV0dXJuIGl0ZW1PclByb2plY3QuYWRkQ2hpbGQodGhpcy5jbG9uZShmYWxzZSkpO1xuXHR9LFxuXG5cdHJhc3Rlcml6ZTogZnVuY3Rpb24ocmVzb2x1dGlvbikge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFN0cm9rZUJvdW5kcygpLFxuXHRcdFx0c2NhbGUgPSAocmVzb2x1dGlvbiB8fCB0aGlzLmdldFZpZXcoKS5nZXRSZXNvbHV0aW9uKCkpIC8gNzIsXG5cdFx0XHR0b3BMZWZ0ID0gYm91bmRzLmdldFRvcExlZnQoKS5mbG9vcigpLFxuXHRcdFx0Ym90dG9tUmlnaHQgPSBib3VuZHMuZ2V0Qm90dG9tUmlnaHQoKS5jZWlsKCksXG5cdFx0XHRzaXplID0gbmV3IFNpemUoYm90dG9tUmlnaHQuc3VidHJhY3QodG9wTGVmdCkpLFxuXHRcdFx0Y2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUubXVsdGlwbHkoc2NhbGUpKSxcblx0XHRcdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuXHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnNjYWxlKHNjYWxlKS50cmFuc2xhdGUodG9wTGVmdC5uZWdhdGUoKSk7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHR0aGlzLmRyYXcoY3R4LCBuZXcgQmFzZSh7IG1hdHJpY2VzOiBbbWF0cml4XSB9KSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR2YXIgcmFzdGVyID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cmFzdGVyLnNldENhbnZhcyhjYW52YXMpO1xuXHRcdHJhc3Rlci50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZSh0b3BMZWZ0LmFkZChzaXplLmRpdmlkZSgyKSkpXG5cdFx0XHRcdC5zY2FsZSgxIC8gc2NhbGUpKTtcblx0XHRyYXN0ZXIuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0cmV0dXJuIHJhc3Rlcjtcblx0fSxcblxuXHRjb250YWluczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fY29udGFpbnMoXG5cdFx0XHRcdHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpKTtcblx0fSxcblxuXHRfY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKHRoaXMuX2NoaWxkcmVuW2ldLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50LmlzSW5zaWRlKHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSk7XG5cdH0sXG5cblx0aXNJbnNpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLmNvbnRhaW5zKHRoaXMuZ2V0Qm91bmRzKCkpO1xuXHR9LFxuXG5cdF9hc1BhdGhJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBhdGguUmVjdGFuZ2xlKHtcblx0XHRcdHJlY3RhbmdsZTogdGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpLFxuXHRcdFx0bWF0cml4OiB0aGlzLl9tYXRyaXgsXG5cdFx0XHRpbnNlcnQ6IGZhbHNlLFxuXHRcdH0pO1xuXHR9LFxuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uKGl0ZW0sIF9tYXRyaXgpIHtcblx0XHRpZiAoIShpdGVtIGluc3RhbmNlb2YgSXRlbSkpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXMuX2FzUGF0aEl0ZW0oKS5nZXRJbnRlcnNlY3Rpb25zKGl0ZW0uX2FzUGF0aEl0ZW0oKSxcblx0XHRcdFx0X21hdHJpeCB8fCBpdGVtLl9tYXRyaXgpLmxlbmd0aCA+IDA7XG5cdH0sXG5cblx0aGl0VGVzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hpdFRlc3QoXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0SGl0UmVzdWx0LmdldE9wdGlvbnMoQmFzZS5yZWFkKGFyZ3VtZW50cykpKTtcblx0fSxcblxuXHRfaGl0VGVzdDogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcblx0XHRpZiAodGhpcy5fbG9ja2VkIHx8ICF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX2d1aWRlICYmICFvcHRpb25zLmd1aWRlc1xuXHRcdFx0XHR8fCB0aGlzLmlzRW1wdHkoKSlcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdHBhcmVudFRvdGFsTWF0cml4ID0gb3B0aW9ucy5fdG90YWxNYXRyaXgsXG5cdFx0XHR2aWV3ID0gdGhpcy5nZXRWaWV3KCksXG5cdFx0XHR0b3RhbE1hdHJpeCA9IG9wdGlvbnMuX3RvdGFsTWF0cml4ID0gcGFyZW50VG90YWxNYXRyaXhcblx0XHRcdFx0XHQ/IHBhcmVudFRvdGFsTWF0cml4LmNoYWluKG1hdHJpeClcblx0XHRcdFx0XHQ6IHRoaXMuZ2V0R2xvYmFsTWF0cml4KCkucHJlQ29uY2F0ZW5hdGUodmlldy5fbWF0cml4KSxcblx0XHRcdHRvbGVyYW5jZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nID0gbmV3IFNpemUoXG5cdFx0XHRcdFx0XHRQYXRoLl9nZXRQZW5QYWRkaW5nKDEsIHRvdGFsTWF0cml4LmludmVydGVkKCkpXG5cdFx0XHRcdFx0KS5tdWx0aXBseShcblx0XHRcdFx0XHRcdE1hdGgubWF4KG9wdGlvbnMudG9sZXJhbmNlLCAwLjAwMDAwMSlcblx0XHRcdFx0XHQpO1xuXHRcdHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHBvaW50KTtcblxuXHRcdGlmICghdGhpcy5fY2hpbGRyZW4gJiYgIXRoaXMuZ2V0SW50ZXJuYWxSb3VnaEJvdW5kcygpXG5cdFx0XHRcdC5leHBhbmQodG9sZXJhbmNlUGFkZGluZy5tdWx0aXBseSgyKSkuX2NvbnRhaW5zUG9pbnQocG9pbnQpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIGNoZWNrU2VsZiA9ICEob3B0aW9ucy5ndWlkZXMgJiYgIXRoaXMuX2d1aWRlXG5cdFx0XHRcdHx8IG9wdGlvbnMuc2VsZWN0ZWQgJiYgIXRoaXMuX3NlbGVjdGVkXG5cdFx0XHRcdHx8IG9wdGlvbnMudHlwZSAmJiBvcHRpb25zLnR5cGUgIT09IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKVxuXHRcdFx0XHR8fCBvcHRpb25zLmNsYXNzICYmICEodGhpcyBpbnN0YW5jZW9mIG9wdGlvbnMuY2xhc3MpKSxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0cmVzO1xuXG5cdFx0ZnVuY3Rpb24gY2hlY2tCb3VuZHModHlwZSwgcGFydCkge1xuXHRcdFx0dmFyIHB0ID0gYm91bmRzWydnZXQnICsgcGFydF0oKTtcblx0XHRcdGlmIChwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHRvbGVyYW5jZVBhZGRpbmcpLmxlbmd0aCA8PSAxKVxuXHRcdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCh0eXBlLCB0aGF0LFxuXHRcdFx0XHRcdFx0eyBuYW1lOiBCYXNlLmh5cGhlbmF0ZShwYXJ0KSwgcG9pbnQ6IHB0IH0pO1xuXHRcdH1cblxuXHRcdGlmIChjaGVja1NlbGYgJiYgKG9wdGlvbnMuY2VudGVyIHx8IG9wdGlvbnMuYm91bmRzKSAmJiB0aGlzLl9wYXJlbnQpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEludGVybmFsQm91bmRzKCk7XG5cdFx0XHRpZiAob3B0aW9ucy5jZW50ZXIpXG5cdFx0XHRcdHJlcyA9IGNoZWNrQm91bmRzKCdjZW50ZXInLCAnQ2VudGVyJyk7XG5cdFx0XHRpZiAoIXJlcyAmJiBvcHRpb25zLmJvdW5kcykge1xuXHRcdFx0XHR2YXIgcG9pbnRzID0gW1xuXHRcdFx0XHRcdCdUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbUxlZnQnLCAnQm90dG9tUmlnaHQnLFxuXHRcdFx0XHRcdCdMZWZ0Q2VudGVyJywgJ1RvcENlbnRlcicsICdSaWdodENlbnRlcicsICdCb3R0b21DZW50ZXInXG5cdFx0XHRcdF07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgOCAmJiAhcmVzOyBpKyspXG5cdFx0XHRcdFx0cmVzID0gY2hlY2tCb3VuZHMoJ2JvdW5kcycsIHBvaW50c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNoaWxkcmVuID0gIXJlcyAmJiB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdHZhciBvcHRzID0gdGhpcy5fZ2V0Q2hpbGRIaXRUZXN0T3B0aW9ucyhvcHRpb25zKTtcblx0XHRcdGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDAgJiYgIXJlczsgaS0tKVxuXHRcdFx0XHRyZXMgPSBjaGlsZHJlbltpXS5faGl0VGVzdChwb2ludCwgb3B0cyk7XG5cdFx0fVxuXHRcdGlmICghcmVzICYmIGNoZWNrU2VsZilcblx0XHRcdHJlcyA9IHRoaXMuX2hpdFRlc3RTZWxmKHBvaW50LCBvcHRpb25zKTtcblx0XHRpZiAocmVzICYmIHJlcy5wb2ludClcblx0XHRcdHJlcy5wb2ludCA9IG1hdHJpeC50cmFuc2Zvcm0ocmVzLnBvaW50KTtcblx0XHRvcHRpb25zLl90b3RhbE1hdHJpeCA9IHBhcmVudFRvdGFsTWF0cml4O1xuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0X2dldENoaWxkSGl0VGVzdE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMuZmlsbCAmJiB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLl9jb250YWlucyhwb2ludCkpXG5cdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpO1xuXHR9LFxuXG5cdG1hdGNoZXM6IGZ1bmN0aW9uKG5hbWUsIGNvbXBhcmUpIHtcblx0XHRmdW5jdGlvbiBtYXRjaE9iamVjdChvYmoxLCBvYmoyKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIG9iajEpIHtcblx0XHRcdFx0aWYgKG9iajEuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHR2YXIgdmFsMSA9IG9iajFbaV0sXG5cdFx0XHRcdFx0XHR2YWwyID0gb2JqMltpXTtcblx0XHRcdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KHZhbDEpICYmIEJhc2UuaXNQbGFpbk9iamVjdCh2YWwyKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaE9iamVjdCh2YWwxLCB2YWwyKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbDEsIHZhbDIpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgbmFtZTtcblx0XHRpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG5cdFx0XHRcdGlmIChuYW1lLmhhc093blByb3BlcnR5KGtleSkgJiYgIXRoaXMubWF0Y2hlcyhrZXksIG5hbWVba2V5XSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIG5hbWUodGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB2YWx1ZSA9IC9eKGVtcHR5fGVkaXRhYmxlKSQvLnRlc3QobmFtZSlcblx0XHRcdFx0XHQ/IHRoaXNbJ2lzJyArIEJhc2UuY2FwaXRhbGl6ZShuYW1lKV0oKVxuXHRcdFx0XHRcdDogbmFtZSA9PT0gJ3R5cGUnXG5cdFx0XHRcdFx0XHQ/IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKVxuXHRcdFx0XHRcdFx0OiB0aGlzW25hbWVdO1xuXHRcdFx0aWYgKC9eKGNvbnN0cnVjdG9yfGNsYXNzKSQvLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIGNvbXBhcmUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoY29tcGFyZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdFx0XHRpZiAoIWNvbXBhcmUudGVzdCh2YWx1ZSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRpZiAoIWNvbXBhcmUodmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGNvbXBhcmUpKSB7XG5cdFx0XHRcdGlmICghbWF0Y2hPYmplY3QoY29tcGFyZSwgdmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBjb21wYXJlKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGdldEl0ZW1zOiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLl9jaGlsZHJlbiwgbWF0Y2gsIHRoaXMuX21hdHJpeCk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5fY2hpbGRyZW4sIG1hdGNoLCB0aGlzLl9tYXRyaXgsIG51bGwsIHRydWUpXG5cdFx0XHRcdFswXSB8fCBudWxsO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRfZ2V0SXRlbXM6IGZ1bmN0aW9uIF9nZXRJdGVtcyhjaGlsZHJlbiwgbWF0Y2gsIG1hdHJpeCwgcGFyYW0sXG5cdFx0XHRcdGZpcnN0T25seSkge1xuXHRcdFx0aWYgKCFwYXJhbSAmJiB0eXBlb2YgbWF0Y2ggPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHZhciBvdmVybGFwcGluZyA9IG1hdGNoLm92ZXJsYXBwaW5nLFxuXHRcdFx0XHRcdGluc2lkZSA9IG1hdGNoLmluc2lkZSxcblx0XHRcdFx0XHRib3VuZHMgPSBvdmVybGFwcGluZyB8fCBpbnNpZGUsXG5cdFx0XHRcdFx0cmVjdCA9XHRib3VuZHMgJiYgUmVjdGFuZ2xlLnJlYWQoW2JvdW5kc10pO1xuXHRcdFx0XHRwYXJhbSA9IHtcblx0XHRcdFx0XHRpdGVtczogW10sXG5cdFx0XHRcdFx0aW5zaWRlOiAhIWluc2lkZSxcblx0XHRcdFx0XHRvdmVybGFwcGluZzogISFvdmVybGFwcGluZyxcblx0XHRcdFx0XHRyZWN0OiByZWN0LFxuXHRcdFx0XHRcdHBhdGg6IG92ZXJsYXBwaW5nICYmIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG5cdFx0XHRcdFx0XHRyZWN0YW5nbGU6IHJlY3QsXG5cdFx0XHRcdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKGJvdW5kcylcblx0XHRcdFx0XHRtYXRjaCA9IEJhc2Uuc2V0KHt9LCBtYXRjaCxcblx0XHRcdFx0XHRcdFx0eyBpbnNpZGU6IHRydWUsIG92ZXJsYXBwaW5nOiB0cnVlIH0pO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGl0ZW1zID0gcGFyYW0gJiYgcGFyYW0uaXRlbXMsXG5cdFx0XHRcdHJlY3QgPSBwYXJhbSAmJiBwYXJhbS5yZWN0O1xuXHRcdFx0bWF0cml4ID0gcmVjdCAmJiAobWF0cml4IHx8IG5ldyBNYXRyaXgoKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0XHRjaGlsZE1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oY2hpbGQuX21hdHJpeCksXG5cdFx0XHRcdFx0YWRkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHJlY3QpIHtcblx0XHRcdFx0XHR2YXIgYm91bmRzID0gY2hpbGQuZ2V0Qm91bmRzKGNoaWxkTWF0cml4KTtcblx0XHRcdFx0XHRpZiAoIXJlY3QuaW50ZXJzZWN0cyhib3VuZHMpKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0aWYgKCEocGFyYW0uaW5zaWRlICYmIHJlY3QuY29udGFpbnMoYm91bmRzKSlcblx0XHRcdFx0XHRcdFx0JiYgIShwYXJhbS5vdmVybGFwcGluZyAmJiAoYm91bmRzLmNvbnRhaW5zKHJlY3QpXG5cdFx0XHRcdFx0XHRcdFx0fHwgcGFyYW0ucGF0aC5pbnRlcnNlY3RzKGNoaWxkLCBjaGlsZE1hdHJpeCkpKSlcblx0XHRcdFx0XHRcdGFkZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhZGQgJiYgY2hpbGQubWF0Y2hlcyhtYXRjaCkpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRpZiAoZmlyc3RPbmx5KVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0X2dldEl0ZW1zKGNoaWxkLl9jaGlsZHJlbiwgbWF0Y2gsXG5cdFx0XHRcdFx0XHRjaGlsZE1hdHJpeCwgcGFyYW0sXG5cdFx0XHRcdFx0XHRmaXJzdE9ubHkpO1xuXHRcdFx0XHRpZiAoZmlyc3RPbmx5ICYmIGl0ZW1zLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fVxuXHR9XG59LCB7XG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuXHRcdHZhciByZXMgPSBCYXNlLmltcG9ydEpTT04oanNvbiwgdGhpcyk7XG5cdFx0cmV0dXJuIHJlcyAhPT0gdGhpc1xuXHRcdFx0XHQ/IHRoaXMuYWRkQ2hpbGQocmVzKVxuXHRcdFx0XHQ6IHJlcztcblx0fSxcblxuXHRhZGRDaGlsZDogZnVuY3Rpb24oaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQodW5kZWZpbmVkLCBpdGVtLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydENoaWxkOiBmdW5jdGlvbihpbmRleCwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0dmFyIHJlcyA9IGl0ZW0gPyB0aGlzLmluc2VydENoaWxkcmVuKGluZGV4LCBbaXRlbV0sIF9wcmVzZXJ2ZSkgOiBudWxsO1xuXHRcdHJldHVybiByZXMgJiYgcmVzWzBdO1xuXHR9LFxuXG5cdGFkZENoaWxkcmVuOiBmdW5jdGlvbihpdGVtcywgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4ubGVuZ3RoLCBpdGVtcywgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRpbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24oaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUsIF9wcm90bykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbiAmJiBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpdGVtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShpdGVtcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdFx0aWYgKF9wcm90byAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBfcHJvdG8pKSB7XG5cdFx0XHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBzaGlmdCA9IGl0ZW0uX3BhcmVudCA9PT0gdGhpcyAmJiBpdGVtLl9pbmRleCA8IGluZGV4O1xuXHRcdFx0XHRcdGlmIChpdGVtLl9yZW1vdmUoZmFsc2UsIHRydWUpICYmIHNoaWZ0KVxuXHRcdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0QmFzZS5zcGxpY2UoY2hpbGRyZW4sIGl0ZW1zLCBpbmRleCwgMCk7XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdG5vdGlmeVNlbGYgPSBwcm9qZWN0ICYmIHByb2plY3QuX2NoYW5nZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0XHRpdGVtLl9wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHRpdGVtLl9zZXRQcm9qZWN0KHRoaXMuX3Byb2plY3QsIHRydWUpO1xuXHRcdFx0XHRpZiAoaXRlbS5fbmFtZSlcblx0XHRcdFx0XHRpdGVtLnNldE5hbWUoaXRlbS5fbmFtZSk7XG5cdFx0XHRcdGlmIChub3RpZnlTZWxmKVxuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZWQoNSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXRlbXMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH0sXG5cblx0X2luc2VydFNpYmxpbmc6IGZ1bmN0aW9uKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50XG5cdFx0XHRcdD8gdGhpcy5fcGFyZW50Lmluc2VydENoaWxkKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpXG5cdFx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRpbnNlcnRBYm92ZTogZnVuY3Rpb24oaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIGl0ZW0uX2luc2VydFNpYmxpbmcoaXRlbS5faW5kZXggKyAxLCB0aGlzLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydEJlbG93OiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gaXRlbS5faW5zZXJ0U2libGluZyhpdGVtLl9pbmRleCwgdGhpcywgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRzZW5kVG9CYWNrOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuX3BhcmVudCB8fCB0aGlzIGluc3RhbmNlb2YgTGF5ZXIgJiYgdGhpcy5fcHJvamVjdClcblx0XHRcdFx0Lmluc2VydENoaWxkKDAsIHRoaXMpO1xuXHR9LFxuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9wYXJlbnQgfHwgdGhpcyBpbnN0YW5jZW9mIExheWVyICYmIHRoaXMuX3Byb2plY3QpXG5cdFx0XHRcdC5hZGRDaGlsZCh0aGlzKTtcblx0fSxcblxuXHRhcHBlbmRUb3A6ICcjYWRkQ2hpbGQnLFxuXG5cdGFwcGVuZEJvdHRvbTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKDAsIGl0ZW0pO1xuXHR9LFxuXG5cdG1vdmVBYm92ZTogJyNpbnNlcnRBYm92ZScsXG5cblx0bW92ZUJlbG93OiAnI2luc2VydEJlbG93JyxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuWzBdLnJlZHVjZSgpO1xuXHRcdFx0Y2hpbGQuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRjaGlsZC5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcmVtb3ZlTmFtZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IHBhcmVudC5fbmFtZWRDaGlsZHJlbixcblx0XHRcdFx0bmFtZSA9IHRoaXMuX25hbWUsXG5cdFx0XHRcdG5hbWVkQXJyYXkgPSBuYW1lZENoaWxkcmVuW25hbWVdLFxuXHRcdFx0XHRpbmRleCA9IG5hbWVkQXJyYXkgPyBuYW1lZEFycmF5LmluZGV4T2YodGhpcykgOiAtMTtcblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0aWYgKGNoaWxkcmVuW25hbWVdID09IHRoaXMpXG5cdFx0XHRcdFx0ZGVsZXRlIGNoaWxkcmVuW25hbWVdO1xuXHRcdFx0XHRuYW1lZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdGlmIChuYW1lZEFycmF5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGNoaWxkcmVuW25hbWVdID0gbmFtZWRBcnJheVtuYW1lZEFycmF5Lmxlbmd0aCAtIDFdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlbGV0ZSBuYW1lZENoaWxkcmVuW25hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmU6IGZ1bmN0aW9uKG5vdGlmeVNlbGYsIG5vdGlmeVBhcmVudCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHRcdHRoaXMuX3JlbW92ZU5hbWVkKCk7XG5cdFx0XHRpZiAodGhpcy5faW5kZXggIT0gbnVsbClcblx0XHRcdFx0QmFzZS5zcGxpY2UocGFyZW50Ll9jaGlsZHJlbiwgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHRpZiAobm90aWZ5U2VsZikge1xuXHRcdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0XHRcdGlmIChwcm9qZWN0ICYmIHByb2plY3QuX2NoYW5nZXMpXG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlZCg1KTtcblx0XHRcdH1cblx0XHRcdGlmIChub3RpZnlQYXJlbnQpXG5cdFx0XHRcdHBhcmVudC5fY2hhbmdlZCgxMSk7XG5cdFx0XHR0aGlzLl9wYXJlbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZW1vdmUodHJ1ZSwgdHJ1ZSk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgb2sgPSBpdGVtICYmIGl0ZW0uaW5zZXJ0QmVsb3codGhpcyk7XG5cdFx0aWYgKG9rKVxuXHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gb2s7XG5cdH0sXG5cblx0cmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0aWYgKCF0aGlzLl9jaGlsZHJlbilcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGZyb20gPSBmcm9tIHx8IDA7XG5cdFx0dG8gPSBCYXNlLnBpY2sodG8sIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCk7XG5cdFx0dmFyIHJlbW92ZWQgPSBCYXNlLnNwbGljZSh0aGlzLl9jaGlsZHJlbiwgbnVsbCwgZnJvbSwgdG8gLSBmcm9tKTtcblx0XHRmb3IgKHZhciBpID0gcmVtb3ZlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0cmVtb3ZlZFtpXS5fcmVtb3ZlKHRydWUsIGZhbHNlKTtcblx0XHR9XG5cdFx0aWYgKHJlbW92ZWQubGVuZ3RoID4gMClcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZUNoaWxkcmVuJyxcblxuXHRyZXZlcnNlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX2NoaWxkcmVuW2ldLl9pbmRleCA9IGk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jaGlsZHJlbiB8fCB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPT09IDA7XG5cdH0sXG5cblx0aXNFZGl0YWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzO1xuXHRcdHdoaWxlIChpdGVtKSB7XG5cdFx0XHRpZiAoIWl0ZW0uX3Zpc2libGUgfHwgaXRlbS5fbG9ja2VkKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRpdGVtID0gaXRlbS5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRoYXNGaWxsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc0ZpbGwoKTtcblx0fSxcblxuXHRoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU3Ryb2tlKCk7XG5cdH0sXG5cblx0aGFzU2hhZG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1NoYWRvdygpO1xuXHR9LFxuXG5cdF9nZXRPcmRlcjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGZ1bmN0aW9uIGdldExpc3QoaXRlbSkge1xuXHRcdFx0dmFyIGxpc3QgPSBbXTtcblx0XHRcdGRvIHtcblx0XHRcdFx0bGlzdC51bnNoaWZ0KGl0ZW0pO1xuXHRcdFx0fSB3aGlsZSAoaXRlbSA9IGl0ZW0uX3BhcmVudCk7XG5cdFx0XHRyZXR1cm4gbGlzdDtcblx0XHR9XG5cdFx0dmFyIGxpc3QxID0gZ2V0TGlzdCh0aGlzKSxcblx0XHRcdGxpc3QyID0gZ2V0TGlzdChpdGVtKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGxpc3QxLmxlbmd0aCwgbGlzdDIubGVuZ3RoKTsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGxpc3QxW2ldICE9IGxpc3QyW2ldKSB7XG5cdFx0XHRcdHJldHVybiBsaXN0MVtpXS5faW5kZXggPCBsaXN0MltpXS5faW5kZXggPyAxIDogLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdGhhc0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID4gMDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmlzSW5zZXJ0ZWQoKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGlzQWJvdmU6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IC0xO1xuXHR9LFxuXG5cdGlzQmVsb3c6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IDE7XG5cdH0sXG5cblx0aXNQYXJlbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID09PSBpdGVtO1xuXHR9LFxuXG5cdGlzQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSAmJiBpdGVtLl9wYXJlbnQgPT09IHRoaXM7XG5cdH0sXG5cblx0aXNEZXNjZW5kYW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXM7XG5cdFx0d2hpbGUgKHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50ID09IGl0ZW0pXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aXNBbmNlc3RvcjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtID8gaXRlbS5pc0Rlc2NlbmRhbnQodGhpcykgOiBmYWxzZTtcblx0fSxcblxuXHRpc0dyb3VwZWRXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50Ll9wYXJlbnRcblx0XHRcdFx0JiYgL14oR3JvdXB8TGF5ZXJ8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcylcblx0XHRcdFx0JiYgaXRlbS5pc0Rlc2NlbmRhbnQocGFyZW50KSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbXggPSBuZXcgTWF0cml4KCk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG14LnRyYW5zbGF0ZS5hcHBseShteCwgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSApIHtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnJvdGF0ZShhbmdsZSxcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMsIDEsIHsgcmVhZE51bGw6IHRydWUgfSlcblx0XHRcdFx0XHR8fCB0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ3NjYWxlJywgJ3NoZWFyJywgJ3NrZXcnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKVtuYW1lXShwb2ludCxcblx0XHRcdFx0Y2VudGVyIHx8IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcblx0fTtcbn0sIHtcblxufSksIHtcblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgsIF9hcHBseU1hdHJpeCwgX2FwcGx5UmVjdXJzaXZlbHksXG5cdFx0XHRfc2V0QXBwbHlNYXRyaXgpIHtcblx0XHRpZiAobWF0cml4ICYmIG1hdHJpeC5pc0lkZW50aXR5KCkpXG5cdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdHZhciBfbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0YXBwbHlNYXRyaXggPSAoX2FwcGx5TWF0cml4IHx8IHRoaXMuX2FwcGx5TWF0cml4KVxuXHRcdFx0XHRcdCYmICgoIV9tYXRyaXguaXNJZGVudGl0eSgpIHx8IG1hdHJpeClcblx0XHRcdFx0XHRcdHx8IF9hcHBseU1hdHJpeCAmJiBfYXBwbHlSZWN1cnNpdmVseSAmJiB0aGlzLl9jaGlsZHJlbik7XG5cdFx0aWYgKCFtYXRyaXggJiYgIWFwcGx5TWF0cml4KVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdF9tYXRyaXgucHJlQ29uY2F0ZW5hdGUobWF0cml4KTtcblx0XHRpZiAoYXBwbHlNYXRyaXggPSBhcHBseU1hdHJpeCAmJiB0aGlzLl90cmFuc2Zvcm1Db250ZW50KF9tYXRyaXgsXG5cdFx0XHRcdFx0X2FwcGx5UmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkpIHtcblx0XHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90LFxuXHRcdFx0XHRzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0XHRmaWxsQ29sb3IgPSBzdHlsZS5nZXRGaWxsQ29sb3IodHJ1ZSksXG5cdFx0XHRcdHN0cm9rZUNvbG9yID0gc3R5bGUuZ2V0U3Ryb2tlQ29sb3IodHJ1ZSk7XG5cdFx0XHRpZiAocGl2b3QpXG5cdFx0XHRcdF9tYXRyaXguX3RyYW5zZm9ybVBvaW50KHBpdm90LCBwaXZvdCwgdHJ1ZSk7XG5cdFx0XHRpZiAoZmlsbENvbG9yKVxuXHRcdFx0XHRmaWxsQ29sb3IudHJhbnNmb3JtKF9tYXRyaXgpO1xuXHRcdFx0aWYgKHN0cm9rZUNvbG9yKVxuXHRcdFx0XHRzdHJva2VDb2xvci50cmFuc2Zvcm0oX21hdHJpeCk7XG5cdFx0XHRfbWF0cml4LnJlc2V0KHRydWUpO1xuXHRcdFx0aWYgKF9zZXRBcHBseU1hdHJpeCAmJiB0aGlzLl9jYW5BcHBseU1hdHJpeClcblx0XHRcdFx0dGhpcy5fYXBwbHlNYXRyaXggPSB0cnVlO1xuXHRcdH1cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzLFxuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdHZhciBkZWNvbXAgPSBib3VuZHMgJiYgbWF0cml4ICYmIG1hdHJpeC5kZWNvbXBvc2UoKTtcblx0XHRpZiAoZGVjb21wICYmICFkZWNvbXAuc2hlYXJpbmcgJiYgZGVjb21wLnJvdGF0aW9uICUgOTAgPT09IDApIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBib3VuZHMpIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBib3VuZHNba2V5XTtcblx0XHRcdFx0aWYgKGFwcGx5TWF0cml4IHx8ICFyZWN0Ll9pbnRlcm5hbClcblx0XHRcdFx0XHRtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0LCByZWN0KTtcblx0XHRcdH1cblx0XHRcdHZhciBnZXR0ZXIgPSB0aGlzLl9ib3VuZHNHZXR0ZXIsXG5cdFx0XHRcdHJlY3QgPSBib3VuZHNbZ2V0dGVyICYmIGdldHRlci5nZXRCb3VuZHMgfHwgZ2V0dGVyIHx8ICdnZXRCb3VuZHMnXTtcblx0XHRcdGlmIChyZWN0KVxuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbiA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0dGhpcy5fYm91bmRzID0gYm91bmRzO1xuXHRcdH0gZWxzZSBpZiAobWF0cml4ICYmIHBvc2l0aW9uKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbiA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9zaXRpb24sIHBvc2l0aW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvbnRlbnQ6IGZ1bmN0aW9uKG1hdHJpeCwgYXBwbHlSZWN1cnNpdmVseSwgc2V0QXBwbHlNYXRyaXgpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS50cmFuc2Zvcm0obWF0cml4LCB0cnVlLCBhcHBseVJlY3Vyc2l2ZWx5LFxuXHRcdFx0XHRcdFx0c2V0QXBwbHlNYXRyaXgpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdsb2JhbFRvTG9jYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKS5faW52ZXJzZVRyYW5zZm9ybShcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRsb2NhbFRvR2xvYmFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkuX3RyYW5zZm9ybVBvaW50KFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHBhcmVudFRvTG9jYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRsb2NhbFRvUGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGZpdEJvdW5kczogZnVuY3Rpb24ocmVjdGFuZ2xlLCBmaWxsKSB7XG5cdFx0cmVjdGFuZ2xlID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdGl0ZW1SYXRpbyA9IGJvdW5kcy5oZWlnaHQgLyBib3VuZHMud2lkdGgsXG5cdFx0XHRyZWN0UmF0aW8gPSByZWN0YW5nbGUuaGVpZ2h0IC8gcmVjdGFuZ2xlLndpZHRoLFxuXHRcdFx0c2NhbGUgPSAoZmlsbCA/IGl0ZW1SYXRpbyA+IHJlY3RSYXRpbyA6IGl0ZW1SYXRpbyA8IHJlY3RSYXRpbylcblx0XHRcdFx0XHQ/IHJlY3RhbmdsZS53aWR0aCAvIGJvdW5kcy53aWR0aFxuXHRcdFx0XHRcdDogcmVjdGFuZ2xlLmhlaWdodCAvIGJvdW5kcy5oZWlnaHQsXG5cdFx0XHRuZXdCb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLFxuXHRcdFx0XHRcdG5ldyBTaXplKGJvdW5kcy53aWR0aCAqIHNjYWxlLCBib3VuZHMuaGVpZ2h0ICogc2NhbGUpKTtcblx0XHRuZXdCb3VuZHMuc2V0Q2VudGVyKHJlY3RhbmdsZS5nZXRDZW50ZXIoKSk7XG5cdFx0dGhpcy5zZXRCb3VuZHMobmV3Qm91bmRzKTtcblx0fSxcblxuXHRfc2V0U3R5bGVzOiBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGZpbGxDb2xvciA9IHN0eWxlLmdldEZpbGxDb2xvcigpLFxuXHRcdFx0c3Ryb2tlQ29sb3IgPSBzdHlsZS5nZXRTdHJva2VDb2xvcigpLFxuXHRcdFx0c2hhZG93Q29sb3IgPSBzdHlsZS5nZXRTaGFkb3dDb2xvcigpO1xuXHRcdGlmIChmaWxsQ29sb3IpXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcblx0XHRpZiAoc3Ryb2tlQ29sb3IpIHtcblx0XHRcdHZhciBzdHJva2VXaWR0aCA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCk7XG5cdFx0XHRpZiAoc3Ryb2tlV2lkdGggPiAwKSB7XG5cdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuXHRcdFx0XHR2YXIgc3Ryb2tlSm9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcblx0XHRcdFx0XHRzdHJva2VDYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKSxcblx0XHRcdFx0XHRtaXRlckxpbWl0ID0gc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0XHRpZiAoc3Ryb2tlSm9pbilcblx0XHRcdFx0XHRjdHgubGluZUpvaW4gPSBzdHJva2VKb2luO1xuXHRcdFx0XHRpZiAoc3Ryb2tlQ2FwKVxuXHRcdFx0XHRcdGN0eC5saW5lQ2FwID0gc3Ryb2tlQ2FwO1xuXHRcdFx0XHRpZiAobWl0ZXJMaW1pdClcblx0XHRcdFx0XHRjdHgubWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQ7XG5cdFx0XHRcdGlmIChwYXBlci5zdXBwb3J0Lm5hdGl2ZURhc2gpIHtcblx0XHRcdFx0XHR2YXIgZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG5cdFx0XHRcdFx0XHRkYXNoT2Zmc2V0ID0gc3R5bGUuZ2V0RGFzaE9mZnNldCgpO1xuXHRcdFx0XHRcdGlmIChkYXNoQXJyYXkgJiYgZGFzaEFycmF5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKCdzZXRMaW5lRGFzaCcgaW4gY3R4KSB7XG5cdFx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuXHRcdFx0XHRcdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y3R4Lm1vekRhc2ggPSBkYXNoQXJyYXk7XG5cdFx0XHRcdFx0XHRcdGN0eC5tb3pEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHNoYWRvd0NvbG9yKSB7XG5cdFx0XHR2YXIgc2hhZG93Qmx1ciA9IHN0eWxlLmdldFNoYWRvd0JsdXIoKTtcblx0XHRcdGlmIChzaGFkb3dCbHVyID4gMCkge1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvci50b0NhbnZhc1N0eWxlKGN0eCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dCbHVyID0gc2hhZG93Qmx1cjtcblx0XHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuZ2V0U2hhZG93T2Zmc2V0KCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dPZmZzZXRYID0gb2Zmc2V0Lng7XG5cdFx0XHRcdGN0eC5zaGFkb3dPZmZzZXRZID0gb2Zmc2V0Lnk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHBhcmVudFN0cm9rZU1hdHJpeCkge1xuXHRcdHZhciB1cGRhdGVWZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG5cdFx0aWYgKCF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX29wYWNpdHkgPT09IDApXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIG1hdHJpY2VzID0gcGFyYW0ubWF0cmljZXMsXG5cdFx0XHR2aWV3TWF0cml4ID0gcGFyYW0udmlld01hdHJpeCxcblx0XHRcdG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdGdsb2JhbE1hdHJpeCA9IG1hdHJpY2VzW21hdHJpY2VzLmxlbmd0aCAtIDFdLmNoYWluKG1hdHJpeCk7XG5cdFx0aWYgKCFnbG9iYWxNYXRyaXguaXNJbnZlcnRpYmxlKCkpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRmdW5jdGlvbiBnZXRWaWV3TWF0cml4KG1hdHJpeCkge1xuXHRcdFx0cmV0dXJuIHZpZXdNYXRyaXggPyB2aWV3TWF0cml4LmNoYWluKG1hdHJpeCkgOiBtYXRyaXg7XG5cdFx0fVxuXG5cdFx0bWF0cmljZXMucHVzaChnbG9iYWxNYXRyaXgpO1xuXHRcdGlmIChwYXJhbS51cGRhdGVNYXRyaXgpIHtcblx0XHRcdGdsb2JhbE1hdHJpeC5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSBnbG9iYWxNYXRyaXg7XG5cdFx0fVxuXG5cdFx0dmFyIGJsZW5kTW9kZSA9IHRoaXMuX2JsZW5kTW9kZSxcblx0XHRcdG9wYWNpdHkgPSB0aGlzLl9vcGFjaXR5LFxuXHRcdFx0bm9ybWFsQmxlbmQgPSBibGVuZE1vZGUgPT09ICdub3JtYWwnLFxuXHRcdFx0bmF0aXZlQmxlbmQgPSBCbGVuZE1vZGUubmF0aXZlTW9kZXNbYmxlbmRNb2RlXSxcblx0XHRcdGRpcmVjdCA9IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPT09IDFcblx0XHRcdFx0XHR8fCBwYXJhbS5kb250U3RhcnRcblx0XHRcdFx0XHR8fCBwYXJhbS5jbGlwXG5cdFx0XHRcdFx0fHwgKG5hdGl2ZUJsZW5kIHx8IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPCAxKVxuXHRcdFx0XHRcdFx0JiYgdGhpcy5fY2FuQ29tcG9zaXRlKCksXG5cdFx0XHRwaXhlbFJhdGlvID0gcGFyYW0ucGl4ZWxSYXRpbyB8fCAxLFxuXHRcdFx0bWFpbkN0eCwgaXRlbU9mZnNldCwgcHJldk9mZnNldDtcblx0XHRpZiAoIWRpcmVjdCkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKGdldFZpZXdNYXRyaXgoZ2xvYmFsTWF0cml4KSk7XG5cdFx0XHRpZiAoIWJvdW5kcy53aWR0aCB8fCAhYm91bmRzLmhlaWdodClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0cHJldk9mZnNldCA9IHBhcmFtLm9mZnNldDtcblx0XHRcdGl0ZW1PZmZzZXQgPSBwYXJhbS5vZmZzZXQgPSBib3VuZHMuZ2V0VG9wTGVmdCgpLmZsb29yKCk7XG5cdFx0XHRtYWluQ3R4ID0gY3R4O1xuXHRcdFx0Y3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChib3VuZHMuZ2V0U2l6ZSgpLmNlaWwoKS5hZGQoMSlcblx0XHRcdFx0XHQubXVsdGlwbHkocGl4ZWxSYXRpbykpO1xuXHRcdFx0aWYgKHBpeGVsUmF0aW8gIT09IDEpXG5cdFx0XHRcdGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR2YXIgc3Ryb2tlTWF0cml4ID0gcGFyZW50U3Ryb2tlTWF0cml4XG5cdFx0XHRcdD8gcGFyZW50U3Ryb2tlTWF0cml4LmNoYWluKG1hdHJpeClcblx0XHRcdFx0OiAhdGhpcy5nZXRTdHJva2VTY2FsaW5nKHRydWUpICYmIGdldFZpZXdNYXRyaXgoZ2xvYmFsTWF0cml4KSxcblx0XHRcdGNsaXAgPSAhZGlyZWN0ICYmIHBhcmFtLmNsaXBJdGVtLFxuXHRcdFx0dHJhbnNmb3JtID0gIXN0cm9rZU1hdHJpeCB8fCBjbGlwO1xuXHRcdGlmIChkaXJlY3QpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cdFx0XHRpZiAobmF0aXZlQmxlbmQpXG5cdFx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGU7XG5cdFx0fSBlbHNlIGlmICh0cmFuc2Zvcm0pIHtcblx0XHRcdGN0eC50cmFuc2xhdGUoLWl0ZW1PZmZzZXQueCwgLWl0ZW1PZmZzZXQueSk7XG5cdFx0fVxuXHRcdGlmICh0cmFuc2Zvcm0pXG5cdFx0XHQoZGlyZWN0ID8gbWF0cml4IDogZ2V0Vmlld01hdHJpeChnbG9iYWxNYXRyaXgpKS5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdGlmIChjbGlwKVxuXHRcdFx0cGFyYW0uY2xpcEl0ZW0uZHJhdyhjdHgsIHBhcmFtLmV4dGVuZCh7IGNsaXA6IHRydWUgfSkpO1xuXHRcdGlmIChzdHJva2VNYXRyaXgpIHtcblx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuXHRcdFx0aWYgKG9mZnNldClcblx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgtb2Zmc2V0LngsIC1vZmZzZXQueSk7XG5cdFx0fVxuXHRcdHRoaXMuX2RyYXcoY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdG1hdHJpY2VzLnBvcCgpO1xuXHRcdGlmIChwYXJhbS5jbGlwICYmICFwYXJhbS5kb250RmluaXNoKVxuXHRcdFx0Y3R4LmNsaXAoKTtcblx0XHRpZiAoIWRpcmVjdCkge1xuXHRcdFx0QmxlbmRNb2RlLnByb2Nlc3MoYmxlbmRNb2RlLCBjdHgsIG1haW5DdHgsIG9wYWNpdHksXG5cdFx0XHRcdFx0aXRlbU9mZnNldC5zdWJ0cmFjdChwcmV2T2Zmc2V0KS5tdWx0aXBseShwaXhlbFJhdGlvKSk7XG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHRwYXJhbS5vZmZzZXQgPSBwcmV2T2Zmc2V0O1xuXHRcdH1cblx0fSxcblxuXHRfaXNVcGRhdGVkOiBmdW5jdGlvbih1cGRhdGVWZXJzaW9uKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKVxuXHRcdFx0cmV0dXJuIHBhcmVudC5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pO1xuXHRcdHZhciB1cGRhdGVkID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9PT0gdXBkYXRlVmVyc2lvbjtcblx0XHRpZiAoIXVwZGF0ZWQgJiYgcGFyZW50ICYmIHBhcmVudC5fdmlzaWJsZVxuXHRcdFx0XHQmJiBwYXJlbnQuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHVwZGF0ZWQ7XG5cdH0sXG5cblx0X2RyYXdTZWxlY3Rpb246IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBzaXplLCBzZWxlY3RlZEl0ZW1zLCB1cGRhdGVWZXJzaW9uKSB7XG5cdFx0aWYgKCh0aGlzLl9kcmF3U2VsZWN0ZWQgfHwgdGhpcy5fYm91bmRzU2VsZWN0ZWQpXG5cdFx0XHRcdCYmIHRoaXMuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuXHRcdFx0dmFyIGNvbG9yID0gdGhpcy5nZXRTZWxlY3RlZENvbG9yKHRydWUpXG5cdFx0XHRcdFx0fHwgdGhpcy5nZXRMYXllcigpLmdldFNlbGVjdGVkQ29sb3IodHJ1ZSksXG5cdFx0XHRcdG14ID0gbWF0cml4LmNoYWluKHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpKTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBjb2xvclxuXHRcdFx0XHRcdD8gY29sb3IudG9DYW52YXNTdHlsZShjdHgpIDogJyMwMDlkZWMnO1xuXHRcdFx0aWYgKHRoaXMuX2RyYXdTZWxlY3RlZClcblx0XHRcdFx0dGhpcy5fZHJhd1NlbGVjdGVkKGN0eCwgbXgsIHNlbGVjdGVkSXRlbXMpO1xuXHRcdFx0aWYgKHRoaXMuX2JvdW5kc1NlbGVjdGVkKSB7XG5cdFx0XHRcdHZhciBoYWxmID0gc2l6ZSAvIDI7XG5cdFx0XHRcdFx0Y29vcmRzID0gbXguX3RyYW5zZm9ybUNvcm5lcnModGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKylcblx0XHRcdFx0XHRjdHhbaSA9PT0gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGNvb3Jkc1tpXSwgY29vcmRzWysraV0pO1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspXG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KGNvb3Jkc1tpXSAtIGhhbGYsIGNvb3Jkc1srK2ldIC0gaGFsZixcblx0XHRcdFx0XHRcdFx0c2l6ZSwgc2l6ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSwgQmFzZS5lYWNoKFsnZG93bicsICdkcmFnJywgJ3VwJywgJ21vdmUnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR0aGlzWydyZW1vdmVPbicgKyBCYXNlLmNhcGl0YWxpemUobmFtZSldID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc2ggPSB7fTtcblx0XHRoYXNoW25hbWVdID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVPbihoYXNoKTtcblx0fTtcbn0sIHtcblxuXHRyZW1vdmVPbjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmopIHtcblx0XHRcdGlmIChvYmpbbmFtZV0pIHtcblx0XHRcdFx0dmFyIGtleSA9ICdtb3VzZScgKyBuYW1lLFxuXHRcdFx0XHRcdHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRcdHNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyB8fCB7fTtcblx0XHRcdFx0c2V0c1trZXldID0gc2V0c1trZXldIHx8IHt9O1xuXHRcdFx0XHRzZXRzW2tleV1bdGhpcy5faWRdID0gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pKTtcblxudmFyIEdyb3VwID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcm91cCcsXG5cdF9zZWxlY3RDaGlsZHJlbjogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyb3VwKGFyZykge1xuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKVxuXHRcdFx0dGhpcy5hZGRDaGlsZHJlbihBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuXHRcdF9jaGFuZ2VkLmJhc2UuY2FsbCh0aGlzLCBmbGFncyk7XG5cdFx0aWYgKGZsYWdzICYgMTAyNikge1xuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRDbGlwSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNsaXBJdGVtID0gdGhpcy5fY2xpcEl0ZW07XG5cdFx0aWYgKGNsaXBJdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNsaXBJdGVtID0gbnVsbDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQuX2NsaXBNYXNrKSB7XG5cdFx0XHRcdFx0Y2xpcEl0ZW0gPSBjaGlsZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSBjbGlwSXRlbTtcblx0XHR9XG5cdFx0cmV0dXJuIGNsaXBJdGVtO1xuXHR9LFxuXG5cdGlzQ2xpcHBlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblx0fSxcblxuXHRzZXRDbGlwcGVkOiBmdW5jdGlvbihjbGlwcGVkKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0aWYgKGNoaWxkKVxuXHRcdFx0Y2hpbGQuc2V0Q2xpcE1hc2soY2xpcHBlZCk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcblx0XHR2YXIgY2xpcCA9IHBhcmFtLmNsaXAsXG5cdFx0XHRjbGlwSXRlbSA9ICFjbGlwICYmIHRoaXMuX2dldENsaXBJdGVtKCksXG5cdFx0XHRkcmF3ID0gdHJ1ZTtcblx0XHRwYXJhbSA9IHBhcmFtLmV4dGVuZCh7IGNsaXBJdGVtOiBjbGlwSXRlbSwgY2xpcDogZmFsc2UgfSk7XG5cdFx0aWYgKGNsaXApIHtcblx0XHRcdGlmICh0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHRcdFx0ZHJhdyA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRwYXJhbS5kb250U3RhcnQgPSBwYXJhbS5kb250RmluaXNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNsaXBJdGVtKSB7XG5cdFx0XHRjbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHsgY2xpcDogdHJ1ZSB9KSk7XG5cdFx0fVxuXHRcdGlmIChkcmF3KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoaXRlbSAhPT0gY2xpcEl0ZW0pXG5cdFx0XHRcdFx0aXRlbS5kcmF3KGN0eCwgcGFyYW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2xpcCkge1xuXHRcdFx0dGhpcy5fY3VycmVudFBhdGggPSBjdHguY3VycmVudFBhdGg7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIExheWVyID0gR3JvdXAuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTGF5ZXInLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExheWVyKGFyZykge1xuXHRcdHZhciBwcm9wcyA9IEJhc2UuaXNQbGFpbk9iamVjdChhcmcpXG5cdFx0XHRcdD8gbmV3IEJhc2UoYXJnKVxuXHRcdFx0XHQ6IHsgY2hpbGRyZW46IEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyB9LFxuXHRcdFx0aW5zZXJ0ID0gcHJvcHMuaW5zZXJ0O1xuXHRcdHByb3BzLmluc2VydCA9IGZhbHNlO1xuXHRcdEdyb3VwLmNhbGwodGhpcywgcHJvcHMpO1xuXHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX3Byb2plY3QuYWRkQ2hpbGQodGhpcyk7XG5cdFx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmU6IGZ1bmN0aW9uIF9yZW1vdmUobm90aWZ5U2VsZiwgbm90aWZ5UGFyZW50KSB7XG5cdFx0aWYgKHRoaXMuX3BhcmVudClcblx0XHRcdHJldHVybiBfcmVtb3ZlLmJhc2UuY2FsbCh0aGlzLCBub3RpZnlTZWxmLCBub3RpZnlQYXJlbnQpO1xuXHRcdGlmICh0aGlzLl9pbmRleCAhPSBudWxsKSB7XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0XHRpZiAocHJvamVjdC5fYWN0aXZlTGF5ZXIgPT09IHRoaXMpXG5cdFx0XHRcdHByb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcy5nZXROZXh0U2libGluZygpXG5cdFx0XHRcdFx0XHR8fCB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuXHRcdFx0QmFzZS5zcGxpY2UocHJvamVjdC5sYXllcnMsIG51bGwsIHRoaXMuX2luZGV4LCAxKTtcblx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuXHRcdFx0aWYgKG5vdGlmeVNlbGYgJiYgcHJvamVjdC5fY2hhbmdlcylcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCg1KTtcblx0XHRcdGlmIChub3RpZnlQYXJlbnQpIHtcblx0XHRcdFx0cHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRnZXROZXh0U2libGluZzogZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IGdldE5leHRTaWJsaW5nLmJhc2UuY2FsbCh0aGlzKVxuXHRcdFx0XHQ6IHRoaXMuX3Byb2plY3QubGF5ZXJzW3RoaXMuX2luZGV4ICsgMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uIGdldFByZXZpb3VzU2libGluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gZ2V0UHJldmlvdXNTaWJsaW5nLmJhc2UuY2FsbCh0aGlzKVxuXHRcdFx0XHQ6IHRoaXMuX3Byb2plY3QubGF5ZXJzW3RoaXMuX2luZGV4IC0gMV0gfHwgbnVsbDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbiBpc0luc2VydGVkKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyBpc0luc2VydGVkLmJhc2UuY2FsbCh0aGlzKSA6IHRoaXMuX2luZGV4ICE9IG51bGw7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Byb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcztcblx0fSxcblxuXHRfaW5zZXJ0U2libGluZzogZnVuY3Rpb24gX2luc2VydFNpYmxpbmcoaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiAhdGhpcy5fcGFyZW50XG5cdFx0XHRcdD8gdGhpcy5fcHJvamVjdC5pbnNlcnRDaGlsZChpbmRleCwgaXRlbSwgX3ByZXNlcnZlKVxuXHRcdFx0XHQ6IF9pbnNlcnRTaWJsaW5nLmJhc2UuY2FsbCh0aGlzLCBpbmRleCwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fVxufSk7XG5cbnZhciBTaGFwZSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2hhcGUnLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHR0eXBlOiBudWxsLFxuXHRcdHNpemU6IG51bGwsXG5cdFx0cmFkaXVzOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2hhcGUocHJvcHMpIHtcblx0XHR0aGlzLl9pbml0aWFsaXplKHByb3BzKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IGl0ZW0uX3R5cGVcblx0XHRcdCYmIHRoaXMuX3NpemUuZXF1YWxzKGl0ZW0uX3NpemUpXG5cdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl9yYWRpdXMsIGl0ZW0uX3JhZGl1cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFNoYXBlKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRjb3B5LnNldFR5cGUodGhpcy5fdHlwZSk7XG5cdFx0Y29weS5zZXRTaXplKHRoaXMuX3NpemUpO1xuXHRcdGNvcHkuc2V0UmFkaXVzKHRoaXMuX3JhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0Z2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdH0sXG5cblx0c2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuXHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHR9LFxuXG5cdGdldFNoYXBlOiAnI2dldFR5cGUnLFxuXHRzZXRTaGFwZTogJyNzZXRUeXBlJyxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gc2l6ZS5jbG9uZSgpO1xuXHRcdH0gZWxzZSBpZiAoIXRoaXMuX3NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IFNpemUubWluKHRoaXMuX3JhZGl1cywgc2l6ZS5kaXZpZGUoMikpO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cy53aWR0aCwgcmFkaXVzLmhlaWdodCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdHdpZHRoID0gaGVpZ2h0ID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cyA9IHdpZHRoIC8gMjtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQod2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NpemUuc2V0KHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmFkID0gdGhpcy5fcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLl90eXBlID09PSAnY2lyY2xlJ1xuXHRcdFx0XHQ/IHJhZFxuXHRcdFx0XHQ6IG5ldyBMaW5rZWRTaXplKHJhZC53aWR0aCwgcmFkLmhlaWdodCwgdGhpcywgJ3NldFJhZGl1cycpO1xuXHR9LFxuXG5cdHNldFJhZGl1czogZnVuY3Rpb24ocmFkaXVzKSB7XG5cdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlO1xuXHRcdGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0aWYgKHJhZGl1cyA9PT0gdGhpcy5fcmFkaXVzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgc2l6ZSA9IHJhZGl1cyAqIDI7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0XHR0aGlzLl9zaXplLnNldChzaXplLCBzaXplKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoIXRoaXMuX3JhZGl1cykge1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXMuY2xvbmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9yYWRpdXMuZXF1YWxzKHJhZGl1cykpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cy53aWR0aCwgcmFkaXVzLmhlaWdodCk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBzaXplID0gU2l6ZS5tYXgodGhpcy5fc2l6ZSwgcmFkaXVzLm11bHRpcGx5KDIpKTtcblx0XHRcdFx0XHR0aGlzLl9zaXplLnNldChzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2l6ZS5zZXQocmFkaXVzLndpZHRoICogMiwgcmFkaXVzLmhlaWdodCAqIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRvUGF0aDogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9jbG9uZShuZXcgUGF0aFtCYXNlLmNhcGl0YWxpemUodGhpcy5fdHlwZSldKHtcblx0XHRcdGNlbnRlcjogbmV3IFBvaW50KCksXG5cdFx0XHRzaXplOiB0aGlzLl9zaXplLFxuXHRcdFx0cmFkaXVzOiB0aGlzLl9yYWRpdXMsXG5cdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0fSksIGluc2VydCk7XG5cdFx0aWYgKHBhcGVyLnNldHRpbmdzLmFwcGx5TWF0cml4KVxuXHRcdFx0cGF0aC5zZXRBcHBseU1hdHJpeCh0cnVlKTtcblx0XHRyZXR1cm4gcGF0aDtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG5cdFx0XHR1bnRyYW5zZm9ybWVkID0gIXN0cm9rZU1hdHJpeDtcblx0XHRpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgfHwgZG9udFBhaW50KSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHJhZGl1cyA9IHRoaXMuX3JhZGl1cyxcblx0XHRcdFx0aXNDaXJjbGUgPSB0eXBlID09PSAnY2lyY2xlJztcblx0XHRcdGlmICghcGFyYW0uZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRpZiAodW50cmFuc2Zvcm1lZCAmJiBpc0NpcmNsZSkge1xuXHRcdFx0XHRjdHguYXJjKDAsIDAsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJ4ID0gaXNDaXJjbGUgPyByYWRpdXMgOiByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSBpc0NpcmNsZSA/IHJhZGl1cyA6IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0c2l6ZSA9IHRoaXMuX3NpemUsXG5cdFx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0XHRpZiAodW50cmFuc2Zvcm1lZCAmJiB0eXBlID09PSAncmVjdGFuZ2xlJyAmJiByeCA9PT0gMCAmJiByeSA9PT0gMCkge1xuXHRcdFx0XHRcdGN0eC5yZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgeCA9IHdpZHRoIC8gMixcblx0XHRcdFx0XHRcdHkgPSBoZWlnaHQgLyAyLFxuXHRcdFx0XHRcdFx0a2FwcGEgPSAxIC0gMC41NTIyODQ3NDk4MzA3OTM2LFxuXHRcdFx0XHRcdFx0Y3ggPSByeCAqIGthcHBhLFxuXHRcdFx0XHRcdFx0Y3kgPSByeSAqIGthcHBhLFxuXHRcdFx0XHRcdFx0YyA9IFtcblx0XHRcdFx0XHRcdFx0LXgsIC15ICsgcnksXG5cdFx0XHRcdFx0XHRcdC14LCAteSArIGN5LFxuXHRcdFx0XHRcdFx0XHQteCArIGN4LCAteSxcblx0XHRcdFx0XHRcdFx0LXggKyByeCwgLXksXG5cdFx0XHRcdFx0XHRcdHggLSByeCwgLXksXG5cdFx0XHRcdFx0XHRcdHggLSBjeCwgLXksXG5cdFx0XHRcdFx0XHRcdHgsIC15ICsgY3ksXG5cdFx0XHRcdFx0XHRcdHgsIC15ICsgcnksXG5cdFx0XHRcdFx0XHRcdHgsIHkgLSByeSxcblx0XHRcdFx0XHRcdFx0eCwgeSAtIGN5LFxuXHRcdFx0XHRcdFx0XHR4IC0gY3gsIHksXG5cdFx0XHRcdFx0XHRcdHggLSByeCwgeSxcblx0XHRcdFx0XHRcdFx0LXggKyByeCwgeSxcblx0XHRcdFx0XHRcdFx0LXggKyBjeCwgeSxcblx0XHRcdFx0XHRcdFx0LXgsIHkgLSBjeSxcblx0XHRcdFx0XHRcdFx0LXgsIHkgLSByeVxuXHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHRpZiAoc3Ryb2tlTWF0cml4KVxuXHRcdFx0XHRcdFx0c3Ryb2tlTWF0cml4LnRyYW5zZm9ybShjLCBjLCAzMik7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjWzBdLCBjWzFdKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzJdLCBjWzNdLCBjWzRdLCBjWzVdLCBjWzZdLCBjWzddKTtcblx0XHRcdFx0XHRpZiAoeCAhPT0gcngpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbOF0sIGNbOV0pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMTBdLCBjWzExXSwgY1sxMl0sIGNbMTNdLCBjWzE0XSwgY1sxNV0pO1xuXHRcdFx0XHRcdGlmICh5ICE9PSByeSlcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oY1sxNl0sIGNbMTddKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzE4XSwgY1sxOV0sIGNbMjBdLCBjWzIxXSwgY1syMl0sIGNbMjNdKTtcblx0XHRcdFx0XHRpZiAoeCAhPT0gcngpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbMjRdLCBjWzI1XSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1syNl0sIGNbMjddLCBjWzI4XSwgY1syOV0sIGNbMzBdLCBjWzMxXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHR9XG5cdFx0aWYgKCFkb250UGFpbnQgJiYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlKSkge1xuXHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHRpZiAoaGFzRmlsbCkge1xuXHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRXaW5kaW5nUnVsZSgpKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc1N0cm9rZSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpKTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCk7XG5cdFx0aWYgKGdldHRlciAhPT0gJ2dldEJvdW5kcycgJiYgdGhpcy5oYXNTdHJva2UoKSlcblx0XHRcdHJlY3QgPSByZWN0LmV4cGFuZCh0aGlzLmdldFN0cm9rZVdpZHRoKCkpO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KSA6IHJlY3Q7XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0Q29ybmVyQ2VudGVyKHRoYXQsIHBvaW50LCBleHBhbmQpIHtcblx0XHR2YXIgcmFkaXVzID0gdGhhdC5fcmFkaXVzO1xuXHRcdGlmICghcmFkaXVzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgaGFsZlNpemUgPSB0aGF0Ll9zaXplLmRpdmlkZSgyKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdHZhciBkaXIgPSBuZXcgUG9pbnQoaSAmIDEgPyAxIDogLTEsIGkgPiAxID8gMSA6IC0xKSxcblx0XHRcdFx0XHRjb3JuZXIgPSBkaXIubXVsdGlwbHkoaGFsZlNpemUpLFxuXHRcdFx0XHRcdGNlbnRlciA9IGNvcm5lci5zdWJ0cmFjdChkaXIubXVsdGlwbHkocmFkaXVzKSksXG5cdFx0XHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUoY29ybmVyLCBjZW50ZXIpO1xuXHRcdFx0XHRpZiAoKGV4cGFuZCA/IHJlY3QuZXhwYW5kKGV4cGFuZCkgOiByZWN0KS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0cmV0dXJuIGNlbnRlcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRFbGxpcHNlUmFkaXVzKHBvaW50LCByYWRpdXMpIHtcblx0XHR2YXIgYW5nbGUgPSBwb2ludC5nZXRBbmdsZUluUmFkaWFucygpLFxuXHRcdFx0d2lkdGggPSByYWRpdXMud2lkdGggKiAyLFxuXHRcdFx0aGVpZ2h0ID0gcmFkaXVzLmhlaWdodCAqIDIsXG5cdFx0XHR4ID0gd2lkdGggKiBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHR5ID0gaGVpZ2h0ICogTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHJldHVybiB3aWR0aCAqIGhlaWdodCAvICgyICogTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2NvbnRhaW5zOiBmdW5jdGlvbiBfY29udGFpbnMocG9pbnQpIHtcblx0XHRcdGlmICh0aGlzLl90eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHR2YXIgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNlbnRlclxuXHRcdFx0XHRcdFx0PyBwb2ludC5zdWJ0cmFjdChjZW50ZXIpLmRpdmlkZSh0aGlzLl9yYWRpdXMpXG5cdFx0XHRcdFx0XHRcdC5nZXRMZW5ndGgoKSA8PSAxXG5cdFx0XHRcdFx0XHQ6IF9jb250YWlucy5iYXNlLmNhbGwodGhpcywgcG9pbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHBvaW50LmRpdmlkZSh0aGlzLnNpemUpLmdldExlbmd0aCgpIDw9IDAuNTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbiBfaGl0VGVzdFNlbGYocG9pbnQsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBoaXQgPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0XHRyYWRpdXMgPSB0aGlzLl9yYWRpdXMsXG5cdFx0XHRcdFx0c3Ryb2tlV2lkdGggPSB0aGlzLmdldFN0cm9rZVdpZHRoKCkgKyAyICogb3B0aW9ucy50b2xlcmFuY2U7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQsIHN0cm9rZVdpZHRoKTtcblx0XHRcdFx0XHRpZiAoY2VudGVyKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHQgPSBwb2ludC5zdWJ0cmFjdChjZW50ZXIpO1xuXHRcdFx0XHRcdFx0aGl0ID0gMiAqIE1hdGguYWJzKHB0LmdldExlbmd0aCgpXG5cdFx0XHRcdFx0XHRcdFx0LSBnZXRFbGxpcHNlUmFkaXVzKHB0LCByYWRpdXMpKSA8PSBzdHJva2VXaWR0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKSxcblx0XHRcdFx0XHRcdFx0b3V0ZXIgPSByZWN0LmV4cGFuZChzdHJva2VXaWR0aCksXG5cdFx0XHRcdFx0XHRcdGlubmVyID0gcmVjdC5leHBhbmQoLXN0cm9rZVdpZHRoKTtcblx0XHRcdFx0XHRcdGhpdCA9IG91dGVyLl9jb250YWluc1BvaW50KHBvaW50KVxuXHRcdFx0XHRcdFx0XHRcdCYmICFpbm5lci5fY29udGFpbnNQb2ludChwb2ludCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSAnZWxsaXBzZScpXG5cdFx0XHRcdFx0XHRyYWRpdXMgPSBnZXRFbGxpcHNlUmFkaXVzKHBvaW50LCByYWRpdXMpO1xuXHRcdFx0XHRcdGhpdCA9IDIgKiBNYXRoLmFicyhwb2ludC5nZXRMZW5ndGgoKSAtIHJhZGl1cylcblx0XHRcdFx0XHRcdFx0PD0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBoaXRcblx0XHRcdFx0XHQ/IG5ldyBIaXRSZXN1bHQoJ3N0cm9rZScsIHRoaXMpXG5cdFx0XHRcdFx0OiBfaGl0VGVzdFNlbGYuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcbn0sIHtcblxuc3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBjcmVhdGVTaGFwZSh0eXBlLCBwb2ludCwgc2l6ZSwgcmFkaXVzLCBhcmdzKSB7XG5cdFx0dmFyIGl0ZW0gPSBuZXcgU2hhcGUoQmFzZS5nZXROYW1lZChhcmdzKSk7XG5cdFx0aXRlbS5fdHlwZSA9IHR5cGU7XG5cdFx0aXRlbS5fc2l6ZSA9IHNpemU7XG5cdFx0aXRlbS5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiBpdGVtLnRyYW5zbGF0ZShwb2ludCk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdENpcmNsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKTtcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgnY2lyY2xlJywgY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMgKiAyKSwgcmFkaXVzLFxuXHRcdFx0XHRcdGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJlY3RhbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKFNpemUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpLFxuXHRcdFx0XHRcdFx0cmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ3JlY3RhbmdsZScsIHJlY3QuZ2V0Q2VudGVyKHRydWUpLFxuXHRcdFx0XHRcdHJlY3QuZ2V0U2l6ZSh0cnVlKSwgcmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRFbGxpcHNlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlbGxpcHNlID0gU2hhcGUuX3JlYWRFbGxpcHNlKGFyZ3VtZW50cyksXG5cdFx0XHRcdHJhZGl1cyA9IGVsbGlwc2UucmFkaXVzO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdlbGxpcHNlJywgZWxsaXBzZS5jZW50ZXIsIHJhZGl1cy5tdWx0aXBseSgyKSxcblx0XHRcdFx0XHRyYWRpdXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdF9yZWFkRWxsaXBzZTogZnVuY3Rpb24oYXJncykge1xuXHRcdFx0dmFyIGNlbnRlcixcblx0XHRcdFx0cmFkaXVzO1xuXHRcdFx0aWYgKEJhc2UuaGFzTmFtZWQoYXJncywgJ3JhZGl1cycpKSB7XG5cdFx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyk7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyk7XG5cdFx0XHRcdGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0XHRyYWRpdXMgPSByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHsgY2VudGVyOiBjZW50ZXIsIHJhZGl1czogcmFkaXVzIH07XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgUmFzdGVyID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdSYXN0ZXInLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzR2V0dGVyOiAnZ2V0Qm91bmRzJyxcblx0X2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y3Jvc3NPcmlnaW46IG51bGwsXG5cdFx0c291cmNlOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmFzdGVyKG9iamVjdCwgcG9zaXRpb24pIHtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUob2JqZWN0LFxuXHRcdFx0XHRwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSkpIHtcblx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFNvdXJjZShvYmplY3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRJbWFnZShvYmplY3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXRoaXMuX3NpemUpIHtcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgU2l6ZSgpO1xuXHRcdFx0dGhpcy5fbG9hZGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoKSA9PT0gaXRlbS5nZXRTb3VyY2UoKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKSxcblx0XHRcdGltYWdlID0gdGhpcy5faW1hZ2UsXG5cdFx0XHRjYW52YXMgPSB0aGlzLl9jYW52YXM7XG5cdFx0aWYgKGltYWdlKSB7XG5cdFx0XHRjb3B5LnNldEltYWdlKGltYWdlKTtcblx0XHR9IGVsc2UgaWYgKGNhbnZhcykge1xuXHRcdFx0dmFyIGNvcHlDYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXModGhpcy5fc2l6ZSk7XG5cdFx0XHRjb3B5Q2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG5cdFx0XHRjb3B5LnNldEltYWdlKGNvcHlDYW52YXMpO1xuXHRcdH1cblx0XHRjb3B5Ll9jcm9zc09yaWdpbiA9IHRoaXMuX2Nyb3NzT3JpZ2luO1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZSA/IHNpemUud2lkdGggOiAwLCBzaXplID8gc2l6ZS5oZWlnaHQgOiAwLFxuXHRcdFx0XHR0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCFzaXplLmVxdWFscyh0aGlzLl9zaXplKSkge1xuXHRcdFx0aWYgKHNpemUud2lkdGggPiAwICYmIHNpemUuaGVpZ2h0ID4gMCkge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXHRcdFx0XHR0aGlzLnNldEltYWdlKENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKSk7XG5cdFx0XHRcdGlmIChlbGVtZW50KVxuXHRcdFx0XHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoZWxlbWVudCwgMCwgMCxcblx0XHRcdFx0XHRcdFx0c2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX2NhbnZhcylcblx0XHRcdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKHRoaXMuX2NhbnZhcyk7XG5cdFx0XHRcdHRoaXMuX3NpemUgPSBzaXplLmNsb25lKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUud2lkdGggOiAwO1xuXHR9LFxuXG5cdHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuXHRcdHRoaXMuc2V0U2l6ZSh3aWR0aCwgdGhpcy5nZXRIZWlnaHQoKSk7XG5cdH0sXG5cblx0Z2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUuaGVpZ2h0IDogMDtcblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuc2V0U2l6ZSh0aGlzLmdldFdpZHRoKCksIGhlaWdodCk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdHJldHVybiAhc2l6ZSB8fCBzaXplLndpZHRoID09PSAwICYmIHNpemUuaGVpZ2h0ID09PSAwO1xuXHR9LFxuXG5cdGdldFJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRvcmlnID0gbmV3IFBvaW50KDAsIDApLnRyYW5zZm9ybShtYXRyaXgpLFxuXHRcdFx0dSA9IG5ldyBQb2ludCgxLCAwKS50cmFuc2Zvcm0obWF0cml4KS5zdWJ0cmFjdChvcmlnKSxcblx0XHRcdHYgPSBuZXcgUG9pbnQoMCwgMSkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0NzIgLyB1LmdldExlbmd0aCgpLFxuXHRcdFx0NzIgLyB2LmdldExlbmd0aCgpXG5cdFx0KTtcblx0fSxcblxuXHRnZXRQcGk6ICcjZ2V0UmVzb2x1dGlvbicsXG5cblx0Z2V0SW1hZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcblx0fSxcblxuXHRzZXRJbWFnZTogZnVuY3Rpb24oaW1hZ2UpIHtcblx0XHRpZiAodGhpcy5fY2FudmFzKVxuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZSh0aGlzLl9jYW52YXMpO1xuXHRcdGlmIChpbWFnZSAmJiBpbWFnZS5nZXRDb250ZXh0KSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBpbWFnZTtcblx0XHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gaW1hZ2U7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBudWxsO1xuXHRcdFx0dGhpcy5fbG9hZGVkID0gaW1hZ2UgJiYgaW1hZ2UuY29tcGxldGU7XG5cdFx0fVxuXHRcdHRoaXMuX3NpemUgPSBuZXcgU2l6ZShcblx0XHRcdFx0aW1hZ2UgPyBpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2Uud2lkdGggOiAwLFxuXHRcdFx0XHRpbWFnZSA/IGltYWdlLm5hdHVyYWxIZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0IDogMCk7XG5cdFx0dGhpcy5fY29udGV4dCA9IG51bGw7XG5cdFx0dGhpcy5fY2hhbmdlZCg1MjEpO1xuXHR9LFxuXG5cdGdldENhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9jYW52YXMpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KHRoaXMuX3NpemUpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHRoaXMuX2ltYWdlKVxuXHRcdFx0XHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDApO1xuXHRcdFx0XHR0aGlzLl9jYW52YXMgPSBjdHguY2FudmFzO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jYW52YXM7XG5cdH0sXG5cblx0c2V0Q2FudmFzOiAnI3NldEltYWdlJyxcblxuXHRnZXRDb250ZXh0OiBmdW5jdGlvbihtb2RpZnkpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRleHQpXG5cdFx0XHR0aGlzLl9jb250ZXh0ID0gdGhpcy5nZXRDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGlmIChtb2RpZnkpIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHRcdHRoaXMuX2NoYW5nZWQoNTEzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRleHQ7XG5cdH0sXG5cblx0c2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXHR9LFxuXG5cdGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLnNyYyB8fCB0aGlzLnRvRGF0YVVSTCgpO1xuXHR9LFxuXG5cdHNldFNvdXJjZTogZnVuY3Rpb24oc3JjKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0Y3Jvc3NPcmlnaW4gPSB0aGlzLl9jcm9zc09yaWdpbixcblx0XHRcdGltYWdlO1xuXG5cdFx0ZnVuY3Rpb24gbG9hZGVkKCkge1xuXHRcdFx0dmFyIHZpZXcgPSB0aGF0LmdldFZpZXcoKTtcblx0XHRcdGlmICh2aWV3KSB7XG5cdFx0XHRcdHBhcGVyID0gdmlldy5fc2NvcGU7XG5cdFx0XHRcdHRoYXQuc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdFx0XHR0aGF0LmVtaXQoJ2xvYWQnKTtcblx0XHRcdFx0dmlldy51cGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpbWFnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNyYykgfHwgbmV3IEltYWdlKCk7XG5cdFx0aWYgKGNyb3NzT3JpZ2luKVxuXHRcdFx0aW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHRpZiAoaW1hZ2UubmF0dXJhbFdpZHRoICYmIGltYWdlLm5hdHVyYWxIZWlnaHQpIHtcblx0XHRcdHNldFRpbWVvdXQobG9hZGVkLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tRXZlbnQuYWRkKGltYWdlLCB7IGxvYWQ6IGxvYWRlZCB9KTtcblx0XHRcdGlmICghaW1hZ2Uuc3JjKVxuXHRcdFx0XHRpbWFnZS5zcmMgPSBzcmM7XG5cdFx0fVxuXHRcdHRoaXMuc2V0SW1hZ2UoaW1hZ2UpO1xuXHR9LFxuXG5cdGdldENyb3NzT3JpZ2luOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2UuY3Jvc3NPcmlnaW4gfHwgdGhpcy5fY3Jvc3NPcmlnaW4gfHwgJyc7XG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKGNyb3NzT3JpZ2luKSB7XG5cdFx0dGhpcy5fY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHRpZiAodGhpcy5faW1hZ2UpXG5cdFx0XHR0aGlzLl9pbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jYW52YXMgfHwgdGhpcy5fbG9hZGVkICYmIHRoaXMuX2ltYWdlO1xuXHR9XG59LCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRTdWJDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQocmVjdC5nZXRTaXplKCkpO1xuXHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5nZXRDYW52YXMoKSwgcmVjdC54LCByZWN0LnksXG5cdFx0XHRcdHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCAwLCAwLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIGN0eC5jYW52YXM7XG5cdH0sXG5cblx0Z2V0U3ViUmFzdGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRyYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRyYXN0ZXIuc2V0SW1hZ2UodGhpcy5nZXRTdWJDYW52YXMocmVjdCkpO1xuXHRcdHJhc3Rlci50cmFuc2xhdGUocmVjdC5nZXRDZW50ZXIoKS5zdWJ0cmFjdCh0aGlzLmdldFNpemUoKS5kaXZpZGUoMikpKTtcblx0XHRyYXN0ZXIuX21hdHJpeC5wcmVDb25jYXRlbmF0ZSh0aGlzLl9tYXRyaXgpO1xuXHRcdHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRyZXR1cm4gcmFzdGVyO1xuXHR9LFxuXG5cdHRvRGF0YVVSTDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNyYyA9IHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLnNyYztcblx0XHRpZiAoL15kYXRhOi8udGVzdChzcmMpKVxuXHRcdFx0cmV0dXJuIHNyYztcblx0XHR2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcblx0XHRyZXR1cm4gY2FudmFzID8gY2FudmFzLnRvRGF0YVVSTCgpIDogbnVsbDtcblx0fSxcblxuXHRkcmF3SW1hZ2U6IGZ1bmN0aW9uKGltYWdlICkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKTtcblx0XHR0aGlzLmdldENvbnRleHQodHJ1ZSkuZHJhd0ltYWdlKGltYWdlLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRBdmVyYWdlQ29sb3I6IGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdHZhciBib3VuZHMsIHBhdGg7XG5cdFx0aWYgKCFvYmplY3QpIHtcblx0XHRcdGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG5cdFx0fSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBQYXRoSXRlbSkge1xuXHRcdFx0cGF0aCA9IG9iamVjdDtcblx0XHRcdGJvdW5kcyA9IG9iamVjdC5nZXRCb3VuZHMoKTtcblx0XHR9IGVsc2UgaWYgKG9iamVjdC53aWR0aCkge1xuXHRcdFx0Ym91bmRzID0gbmV3IFJlY3RhbmdsZShvYmplY3QpO1xuXHRcdH0gZWxzZSBpZiAob2JqZWN0LngpIHtcblx0XHRcdGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0LnggLSAwLjUsIG9iamVjdC55IC0gMC41LCAxLCAxKTtcblx0XHR9XG5cdFx0dmFyIHNhbXBsZVNpemUgPSAzMixcblx0XHRcdHdpZHRoID0gTWF0aC5taW4oYm91bmRzLndpZHRoLCBzYW1wbGVTaXplKSxcblx0XHRcdGhlaWdodCA9IE1hdGgubWluKGJvdW5kcy5oZWlnaHQsIHNhbXBsZVNpemUpO1xuXHRcdHZhciBjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQ7XG5cdFx0aWYgKCFjdHgpIHtcblx0XHRcdGN0eCA9IFJhc3Rlci5fc2FtcGxlQ29udGV4dCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoXG5cdFx0XHRcdFx0bmV3IFNpemUoc2FtcGxlU2l6ZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHNhbXBsZVNpemUgKyAxLCBzYW1wbGVTaXplICsgMSk7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKVxuXHRcdFx0XHQuc2NhbGUod2lkdGggLyBib3VuZHMud2lkdGgsIGhlaWdodCAvIGJvdW5kcy5oZWlnaHQpXG5cdFx0XHRcdC50cmFuc2xhdGUoLWJvdW5kcy54LCAtYm91bmRzLnkpO1xuXHRcdG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdGlmIChwYXRoKVxuXHRcdFx0cGF0aC5kcmF3KGN0eCwgbmV3IEJhc2UoeyBjbGlwOiB0cnVlLCBtYXRyaWNlczogW21hdHJpeF0gfSkpO1xuXHRcdHRoaXMuX21hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCksXG5cdFx0XHRzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRpZiAoZWxlbWVudClcblx0XHRcdGN0eC5kcmF3SW1hZ2UoZWxlbWVudCwgLXNpemUud2lkdGggLyAyLCAtc2l6ZS5oZWlnaHQgLyAyKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHZhciBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAuNSwgMC41LCBNYXRoLmNlaWwod2lkdGgpLFxuXHRcdFx0XHRNYXRoLmNlaWwoaGVpZ2h0KSkuZGF0YSxcblx0XHRcdGNoYW5uZWxzID0gWzAsIDAsIDBdLFxuXHRcdFx0dG90YWwgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuXHRcdFx0dmFyIGFscGhhID0gcGl4ZWxzW2kgKyAzXTtcblx0XHRcdHRvdGFsICs9IGFscGhhO1xuXHRcdFx0YWxwaGEgLz0gMjU1O1xuXHRcdFx0Y2hhbm5lbHNbMF0gKz0gcGl4ZWxzW2ldICogYWxwaGE7XG5cdFx0XHRjaGFubmVsc1sxXSArPSBwaXhlbHNbaSArIDFdICogYWxwaGE7XG5cdFx0XHRjaGFubmVsc1syXSArPSBwaXhlbHNbaSArIDJdICogYWxwaGE7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKVxuXHRcdFx0Y2hhbm5lbHNbaV0gLz0gdG90YWw7XG5cdFx0cmV0dXJuIHRvdGFsID8gQ29sb3IucmVhZChjaGFubmVscykgOiBudWxsO1xuXHR9LFxuXG5cdGdldFBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEocG9pbnQueCwgcG9pbnQueSwgMSwgMSkuZGF0YTtcblx0XHRyZXR1cm4gbmV3IENvbG9yKCdyZ2InLCBbZGF0YVswXSAvIDI1NSwgZGF0YVsxXSAvIDI1NSwgZGF0YVsyXSAvIDI1NV0sXG5cdFx0XHRcdGRhdGFbM10gLyAyNTUpO1xuXHR9LFxuXG5cdHNldFBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjb2xvciA9IENvbG9yLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNvbXBvbmVudHMgPSBjb2xvci5fY29udmVydCgncmdiJyksXG5cdFx0XHRhbHBoYSA9IGNvbG9yLl9hbHBoYSxcblx0XHRcdGN0eCA9IHRoaXMuZ2V0Q29udGV4dCh0cnVlKSxcblx0XHRcdGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEoMSwgMSksXG5cdFx0XHRkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0ZGF0YVswXSA9IGNvbXBvbmVudHNbMF0gKiAyNTU7XG5cdFx0ZGF0YVsxXSA9IGNvbXBvbmVudHNbMV0gKiAyNTU7XG5cdFx0ZGF0YVsyXSA9IGNvbXBvbmVudHNbMl0gKiAyNTU7XG5cdFx0ZGF0YVszXSA9IGFscGhhICE9IG51bGwgPyBhbHBoYSAqIDI1NSA6IDI1NTtcblx0XHRjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Y3JlYXRlSW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLmdldENvbnRleHQoKS5jcmVhdGVJbWFnZURhdGEoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdGdldEltYWdlRGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmIChyZWN0LmlzRW1wdHkoKSlcblx0XHRcdHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpO1xuXHRcdHJldHVybiB0aGlzLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEocmVjdC54LCByZWN0LnksXG5cdFx0XHRcdHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0fSxcblxuXHRzZXRJbWFnZURhdGE6IGZ1bmN0aW9uKGRhdGEgKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpO1xuXHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5wdXRJbWFnZURhdGEoZGF0YSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcblx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KSA6IHJlY3Q7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdGlmICh0aGlzLl9jb250YWlucyhwb2ludCkpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KCdwaXhlbCcsIHRoYXQsIHtcblx0XHRcdFx0b2Zmc2V0OiBwb2ludC5hZGQodGhhdC5fc2l6ZS5kaXZpZGUoMikpLnJvdW5kKCksXG5cdFx0XHRcdGNvbG9yOiB7XG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGF0LmdldFBpeGVsKHRoaXMub2Zmc2V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fb3BhY2l0eTtcblx0XHRcdGN0eC5kcmF3SW1hZ2UoZWxlbWVudCxcblx0XHRcdFx0XHQtdGhpcy5fc2l6ZS53aWR0aCAvIDIsIC10aGlzLl9zaXplLmhlaWdodCAvIDIpO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBQbGFjZWRTeW1ib2wgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BsYWNlZFN5bWJvbCcsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9ib3VuZHNHZXR0ZXI6IHsgZ2V0Qm91bmRzOiAnZ2V0U3Ryb2tlQm91bmRzJyB9LFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzeW1ib2w6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQbGFjZWRTeW1ib2woYXJnMCwgYXJnMSkge1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcwLFxuXHRcdFx0XHRhcmcxICE9PSB1bmRlZmluZWQgJiYgUG9pbnQucmVhZChhcmd1bWVudHMsIDEpKSlcblx0XHRcdHRoaXMuc2V0U3ltYm9sKGFyZzAgaW5zdGFuY2VvZiBTeW1ib2wgPyBhcmcwIDogbmV3IFN5bWJvbChhcmcwKSk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9zeW1ib2wgPT09IGl0ZW0uX3N5bWJvbDtcblx0fSxcblxuXHRnZXRTeW1ib2w6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zeW1ib2w7XG5cdH0sXG5cblx0c2V0U3ltYm9sOiBmdW5jdGlvbihzeW1ib2wpIHtcblx0XHR0aGlzLl9zeW1ib2wgPSBzeW1ib2w7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgUGxhY2VkU3ltYm9sKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRjb3B5LnNldFN5bWJvbCh0aGlzLl9zeW1ib2wpO1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zeW1ib2wuX2RlZmluaXRpb24uaXNFbXB0eSgpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0pIHtcblx0XHR2YXIgZGVmaW5pdGlvbiA9IHRoaXMuc3ltYm9sLl9kZWZpbml0aW9uO1xuXHRcdHJldHVybiBkZWZpbml0aW9uLl9nZXRDYWNoZWRCb3VuZHMoZ2V0dGVyLFxuXHRcdFx0XHRtYXRyaXggJiYgbWF0cml4LmNoYWluKGRlZmluaXRpb24uX21hdHJpeCksIGNhY2hlSXRlbSk7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdHZhciByZXMgPSB0aGlzLl9zeW1ib2wuX2RlZmluaXRpb24uX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMpO1xuXHRcdGlmIChyZXMpXG5cdFx0XHRyZXMuaXRlbSA9IHRoaXM7XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSkge1xuXHRcdHRoaXMuc3ltYm9sLl9kZWZpbml0aW9uLmRyYXcoY3R4LCBwYXJhbSk7XG5cdH1cblxufSk7XG5cbnZhciBIaXRSZXN1bHQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0hpdFJlc3VsdCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gSGl0UmVzdWx0KHR5cGUsIGl0ZW0sIHZhbHVlcykge1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5pdGVtID0gaXRlbTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHR2YWx1ZXMuZW51bWVyYWJsZSA9IHRydWU7XG5cdFx0XHR0aGlzLmluamVjdCh2YWx1ZXMpO1xuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0Z2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG5ldyBCYXNlKHtcblx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0dG9sZXJhbmNlOiBwYXBlci5zZXR0aW5ncy5oaXRUb2xlcmFuY2UsXG5cdFx0XHRcdGZpbGw6ICFvcHRpb25zLFxuXHRcdFx0XHRzdHJva2U6ICFvcHRpb25zLFxuXHRcdFx0XHRzZWdtZW50czogIW9wdGlvbnMsXG5cdFx0XHRcdGhhbmRsZXM6IGZhbHNlLFxuXHRcdFx0XHRlbmRzOiBmYWxzZSxcblx0XHRcdFx0Y2VudGVyOiBmYWxzZSxcblx0XHRcdFx0Ym91bmRzOiBmYWxzZSxcblx0XHRcdFx0Z3VpZGVzOiBmYWxzZSxcblx0XHRcdFx0c2VsZWN0ZWQ6IGZhbHNlXG5cdFx0XHR9LCBvcHRpb25zKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgU2VnbWVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2VnbWVudCcsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnQoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRwb2ludCwgaGFuZGxlSW4sIGhhbmRsZU91dDtcblx0XHRpZiAoY291bnQgPT09IDApIHtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG5cdFx0XHRpZiAoYXJnMC5wb2ludCkge1xuXHRcdFx0XHRwb2ludCA9IGFyZzAucG9pbnQ7XG5cdFx0XHRcdGhhbmRsZUluID0gYXJnMC5oYW5kbGVJbjtcblx0XHRcdFx0aGFuZGxlT3V0ID0gYXJnMC5oYW5kbGVPdXQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludCA9IGFyZzA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMiAmJiB0eXBlb2YgYXJnMCA9PT0gJ251bWJlcicpIHtcblx0XHRcdHBvaW50ID0gYXJndW1lbnRzO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPD0gMykge1xuXHRcdFx0cG9pbnQgPSBhcmcwO1xuXHRcdFx0aGFuZGxlSW4gPSBhcmcxO1xuXHRcdFx0aGFuZGxlT3V0ID0gYXJnMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cG9pbnQgPSBhcmcwICE9PSB1bmRlZmluZWQgPyBbIGFyZzAsIGFyZzEgXSA6IG51bGw7XG5cdFx0XHRoYW5kbGVJbiA9IGFyZzIgIT09IHVuZGVmaW5lZCA/IFsgYXJnMiwgYXJnMyBdIDogbnVsbDtcblx0XHRcdGhhbmRsZU91dCA9IGFyZzQgIT09IHVuZGVmaW5lZCA/IFsgYXJnNCwgYXJnNSBdIDogbnVsbDtcblx0XHR9XG5cdFx0bmV3IFNlZ21lbnRQb2ludChwb2ludCwgdGhpcywgJ19wb2ludCcpO1xuXHRcdG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlSW4sIHRoaXMsICdfaGFuZGxlSW4nKTtcblx0XHRuZXcgU2VnbWVudFBvaW50KGhhbmRsZU91dCwgdGhpcywgJ19oYW5kbGVPdXQnKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuaXNTdHJhaWdodCgpID8gdGhpcy5fcG9pbnRcblx0XHRcdFx0OiBbdGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXRdLFxuXHRcdFx0XHRvcHRpb25zLCB0cnVlKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0aWYgKCFwYXRoKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBjdXJ2ZXMgPSBwYXRoLl9jdXJ2ZXMsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4LFxuXHRcdFx0Y3VydmU7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0aWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVJbilcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBpbmRleCA+IDAgPyBjdXJ2ZXNbaW5kZXggLSAxXSA6IHBhdGguX2Nsb3NlZFxuXHRcdFx0XHRcdFx0PyBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdIDogbnVsbCkpXG5cdFx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0XHRpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZU91dClcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBjdXJ2ZXNbaW5kZXhdKSlcblx0XHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0cGF0aC5fY2hhbmdlZCgyNSk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZUluO1xuXHR9LFxuXG5cdHNldEhhbmRsZUluOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5faGFuZGxlSW4uc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZU91dDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGVPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9oYW5kbGVPdXQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5pc1N0cmFpZ2h0KCk7XG5cdH0sXG5cblx0aXNTdHJhaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZUluLmlzWmVybygpICYmIHRoaXMuX2hhbmRsZU91dC5pc1plcm8oKTtcblx0fSxcblxuXHRpc0xpbmVhcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFNlZ21lbnQuaXNMaW5lYXIodGhpcywgdGhpcy5nZXROZXh0KCkpO1xuXHR9LFxuXG5cdGlzQ29sbGluZWFyOiBmdW5jdGlvbihzZWdtZW50KSB7XG5cdFx0cmV0dXJuIFNlZ21lbnQuaXNDb2xsaW5lYXIodGhpcywgdGhpcy5nZXROZXh0KCksXG5cdFx0XHRcdHNlZ21lbnQsIHNlZ21lbnQuZ2V0TmV4dCgpKTtcblx0fSxcblxuXHRpc0NvbGluZWFyOiAnI2lzQ29sbGluZWFyJyxcblxuXHRpc09ydGhvZ29uYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBTZWdtZW50LmlzT3J0aG9nb25hbCh0aGlzLmdldFByZXZpb3VzKCksIHRoaXMsIHRoaXMuZ2V0TmV4dCgpKTtcblx0fSxcblxuXHRpc09ydGhvZ29uYWxBcmM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBTZWdtZW50LmlzT3J0aG9nb25hbEFyYyh0aGlzLCB0aGlzLmdldE5leHQoKSk7XG5cdH0sXG5cblx0aXNBcmM6ICcjaXNPcnRob2dvbmFsQXJjJyxcblxuXHRfc2VsZWN0aW9uU3RhdGU6IDAsXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oX3BvaW50KSB7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGU7XG5cdFx0cmV0dXJuICFfcG9pbnQgPyAhIShzdGF0ZSAmIDcpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5fcG9pbnQgPyAhIShzdGF0ZSAmIDQpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlSW4gPyAhIShzdGF0ZSAmIDEpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gISEoc3RhdGUgJiAyKVxuXHRcdFx0OiBmYWxzZTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIF9wb2ludCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aCxcblx0XHRcdHNlbGVjdGVkID0gISFzZWxlY3RlZCxcblx0XHRcdHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGUsXG5cdFx0XHRvbGRTdGF0ZSA9IHN0YXRlLFxuXHRcdFx0ZmxhZyA9ICFfcG9pbnQgPyA3XG5cdFx0XHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX3BvaW50ID8gNFxuXHRcdFx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9oYW5kbGVJbiA/IDFcblx0XHRcdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gMlxuXHRcdFx0XHRcdDogMDtcblx0XHRpZiAoc2VsZWN0ZWQpIHtcblx0XHRcdHN0YXRlIHw9IGZsYWc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXRlICY9IH5mbGFnO1xuXHRcdH1cblx0XHR0aGlzLl9zZWxlY3Rpb25TdGF0ZSA9IHN0YXRlO1xuXHRcdGlmIChwYXRoICYmIHN0YXRlICE9PSBvbGRTdGF0ZSkge1xuXHRcdFx0cGF0aC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMsIG9sZFN0YXRlLCBzdGF0ZSk7XG5cdFx0XHRwYXRoLl9jaGFuZ2VkKDEyOSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2luZGV4IDogbnVsbDtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGgsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4O1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHRpZiAoaW5kZXggPiAwICYmICFwYXRoLl9jbG9zZWRcblx0XHRcdFx0XHQmJiBpbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSlcblx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdHJldHVybiBwYXRoLmdldEN1cnZlcygpW2luZGV4XSB8fCBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZVxuXHRcdFx0XHQ/IG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCB0aGlzID09PSBjdXJ2ZS5fc2VnbWVudDEgPyAwIDogMSlcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1swXSkgfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcblx0XHRyZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlT3V0LCB0aGlzLl9oYW5kbGVJbik7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCA/ICEhdGhpcy5fcGF0aC5yZW1vdmVTZWdtZW50KHRoaXMuX2luZGV4KSA6IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2VnbWVudCkge1xuXHRcdHJldHVybiBzZWdtZW50ID09PSB0aGlzIHx8IHNlZ21lbnQgJiYgdGhpcy5fY2xhc3MgPT09IHNlZ21lbnQuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3BvaW50LmVxdWFscyhzZWdtZW50Ll9wb2ludClcblx0XHRcdFx0JiYgdGhpcy5faGFuZGxlSW4uZXF1YWxzKHNlZ21lbnQuX2hhbmRsZUluKVxuXHRcdFx0XHQmJiB0aGlzLl9oYW5kbGVPdXQuZXF1YWxzKHNlZ21lbnQuX2hhbmRsZU91dClcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50OiAnICsgdGhpcy5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX2hhbmRsZUluLmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlSW46ICcgKyB0aGlzLl9oYW5kbGVJbik7XG5cdFx0aWYgKCF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGVPdXQ6ICcgKyB0aGlzLl9oYW5kbGVPdXQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgdHJ1ZSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db29yZGluYXRlczogZnVuY3Rpb24obWF0cml4LCBjb29yZHMsIGNoYW5nZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX3BvaW50LFxuXHRcdFx0aGFuZGxlSW4gPSAhY2hhbmdlIHx8ICF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5faGFuZGxlSW4gOiBudWxsLFxuXHRcdFx0aGFuZGxlT3V0ID0gIWNoYW5nZSB8fCAhdGhpcy5faGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9oYW5kbGVPdXQgOiBudWxsLFxuXHRcdFx0eCA9IHBvaW50Ll94LFxuXHRcdFx0eSA9IHBvaW50Ll95LFxuXHRcdFx0aSA9IDI7XG5cdFx0Y29vcmRzWzBdID0geDtcblx0XHRjb29yZHNbMV0gPSB5O1xuXHRcdGlmIChoYW5kbGVJbikge1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVJbi5feCArIHg7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZUluLl95ICsgeTtcblx0XHR9XG5cdFx0aWYgKGhhbmRsZU91dCkge1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3ggKyB4O1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3kgKyB5O1xuXHRcdH1cblx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRtYXRyaXguX3RyYW5zZm9ybUNvb3JkaW5hdGVzKGNvb3JkcywgY29vcmRzLCBpIC8gMik7XG5cdFx0XHR4ID0gY29vcmRzWzBdO1xuXHRcdFx0eSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChjaGFuZ2UpIHtcblx0XHRcdFx0cG9pbnQuX3ggPSB4O1xuXHRcdFx0XHRwb2ludC5feSA9IHk7XG5cdFx0XHRcdGkgID0gMjtcblx0XHRcdFx0aWYgKGhhbmRsZUluKSB7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3ggPSBjb29yZHNbaSsrXSAtIHg7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhbmRsZU91dCkge1xuXHRcdFx0XHRcdGhhbmRsZU91dC5feCA9IGNvb3Jkc1tpKytdIC0geDtcblx0XHRcdFx0XHRoYW5kbGVPdXQuX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghaGFuZGxlSW4pIHtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHg7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaGFuZGxlT3V0KSB7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB4O1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9LFxuXG4gICBzdGF0aWNzOiB7XG5cblx0XHRpc0xpbmVhcjogZnVuY3Rpb24oc2VnMSwgc2VnMikge1xuXHRcdFx0dmFyIGwgPSBzZWcyLl9wb2ludC5zdWJ0cmFjdChzZWcxLl9wb2ludCk7XG5cdFx0XHRyZXR1cm4gbC5pc0NvbGxpbmVhcihzZWcxLl9oYW5kbGVPdXQpXG5cdFx0XHRcdFx0JiYgbC5pc0NvbGxpbmVhcihzZWcyLl9oYW5kbGVJbik7XG5cdFx0fSxcblxuXHRcdGlzQ29sbGluZWFyOiBmdW5jdGlvbihzZWcxLCBzZWcyLCBzZWczLCBzZWc0KSB7XG5cdFx0XHRyZXR1cm4gc2VnMS5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzIuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0JiYgc2VnMy5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzQuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0JiYgc2VnMi5fcG9pbnQuc3VidHJhY3Qoc2VnMS5fcG9pbnQpLmlzQ29sbGluZWFyKFxuXHRcdFx0XHRcdFx0c2VnNC5fcG9pbnQuc3VidHJhY3Qoc2VnMy5fcG9pbnQpKTtcblx0XHR9LFxuXG5cdFx0aXNPcnRob2dvbmFsOiBmdW5jdGlvbihzZWcxLCBzZWcyLCBzZWczKSB7XG5cdFx0XHRyZXR1cm4gc2VnMS5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzIuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdCYmIHNlZzIuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWczLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHQmJiBzZWcyLl9wb2ludC5zdWJ0cmFjdChzZWcxLl9wb2ludCkuaXNPcnRob2dvbmFsKFxuXHRcdFx0XHRcdFx0c2VnMy5fcG9pbnQuc3VidHJhY3Qoc2VnMi5fcG9pbnQpKTtcblx0XHR9LFxuXG5cdFx0aXNPcnRob2dvbmFsQXJjOiBmdW5jdGlvbihzZWcxLCBzZWcyKSB7XG5cdFx0XHR2YXIgaGFuZGxlMSA9IHNlZzEuX2hhbmRsZU91dCxcblx0XHRcdFx0aGFuZGxlMiA9IHNlZzIuX2hhbmRsZUluLFxuXHRcdFx0XHRrYXBwYSA9IDAuNTUyMjg0NzQ5ODMwNzkzNjtcblx0XHRcdGlmIChoYW5kbGUxLmlzT3J0aG9nb25hbChoYW5kbGUyKSkge1xuXHRcdFx0XHR2YXIgcHQxID0gc2VnMS5fcG9pbnQsXG5cdFx0XHRcdFx0cHQyID0gc2VnMi5fcG9pbnQsXG5cdFx0XHRcdFx0Y29ybmVyID0gbmV3IExpbmUocHQxLCBoYW5kbGUxLCB0cnVlKS5pbnRlcnNlY3QoXG5cdFx0XHRcdFx0XHRcdG5ldyBMaW5lKHB0MiwgaGFuZGxlMiwgdHJ1ZSksIHRydWUpO1xuXHRcdFx0XHRyZXR1cm4gY29ybmVyICYmIE51bWVyaWNhbC5pc1plcm8oaGFuZGxlMS5nZXRMZW5ndGgoKSAvXG5cdFx0XHRcdFx0XHRjb3JuZXIuc3VidHJhY3QocHQxKS5nZXRMZW5ndGgoKSAtIGthcHBhKVxuXHRcdFx0XHRcdCYmIE51bWVyaWNhbC5pc1plcm8oaGFuZGxlMi5nZXRMZW5ndGgoKSAvXG5cdFx0XHRcdFx0XHRjb3JuZXIuc3VidHJhY3QocHQyKS5nZXRMZW5ndGgoKSAtIGthcHBhKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHR9XG59KTtcblxudmFyIFNlZ21lbnRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnRQb2ludChwb2ludCwgb3duZXIsIGtleSkge1xuXHRcdHZhciB4LCB5LCBzZWxlY3RlZDtcblx0XHRpZiAoIXBvaW50KSB7XG5cdFx0XHR4ID0geSA9IDA7XG5cdFx0fSBlbHNlIGlmICgoeCA9IHBvaW50WzBdKSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR5ID0gcG9pbnRbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwdCA9IHBvaW50O1xuXHRcdFx0aWYgKCh4ID0gcHQueCkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRwdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0eCA9IHB0Lng7XG5cdFx0XHR9XG5cdFx0XHR5ID0gcHQueTtcblx0XHRcdHNlbGVjdGVkID0gcHQuc2VsZWN0ZWQ7XG5cdFx0fVxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0b3duZXJba2V5XSA9IHRoaXM7XG5cdFx0aWYgKHNlbGVjdGVkKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcixcblx0XHRcdHggPSBmLm51bWJlcih0aGlzLl94KSxcblx0XHRcdHkgPSBmLm51bWJlcih0aGlzLl95KTtcblx0XHRyZXR1cm4gdGhpcy5pc1NlbGVjdGVkKClcblx0XHRcdFx0PyB7IHg6IHgsIHk6IHksIHNlbGVjdGVkOiB0cnVlIH1cblx0XHRcdFx0OiBbeCwgeV07XG5cdH0sXG5cblx0Z2V0WDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHR9LFxuXG5cdGdldFk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl95O1xuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKHRoaXMuX3gpICYmIE51bWVyaWNhbC5pc1plcm8odGhpcy5feSk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5fb3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIHRoaXMpO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9vd25lci5pc1NlbGVjdGVkKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIEN1cnZlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDdXJ2ZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ3VydmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNiwgYXJnNykge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGNvdW50ID09PSAzKSB7XG5cdFx0XHR0aGlzLl9wYXRoID0gYXJnMDtcblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gYXJnMTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gYXJnMjtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAwKSB7XG5cdFx0XHR0aGlzLl9zZWdtZW50MSA9IG5ldyBTZWdtZW50KCk7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KCk7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuXHRcdFx0dGhpcy5fc2VnbWVudDEgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQxKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50Mik7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMikge1xuXHRcdFx0dGhpcy5fc2VnbWVudDEgPSBuZXcgU2VnbWVudChhcmcwKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQoYXJnMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwb2ludDEsIGhhbmRsZTEsIGhhbmRsZTIsIHBvaW50Mjtcblx0XHRcdGlmIChjb3VudCA9PT0gNCkge1xuXHRcdFx0XHRwb2ludDEgPSBhcmcwO1xuXHRcdFx0XHRoYW5kbGUxID0gYXJnMTtcblx0XHRcdFx0aGFuZGxlMiA9IGFyZzI7XG5cdFx0XHRcdHBvaW50MiA9IGFyZzM7XG5cdFx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSA4KSB7XG5cdFx0XHRcdHBvaW50MSA9IFthcmcwLCBhcmcxXTtcblx0XHRcdFx0cG9pbnQyID0gW2FyZzYsIGFyZzddO1xuXHRcdFx0XHRoYW5kbGUxID0gW2FyZzIgLSBhcmcwLCBhcmczIC0gYXJnMV07XG5cdFx0XHRcdGhhbmRsZTIgPSBbYXJnNCAtIGFyZzYsIGFyZzUgLSBhcmc3XTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gbmV3IFNlZ21lbnQocG9pbnQxLCBudWxsLCBoYW5kbGUxKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQocG9pbnQyLCBoYW5kbGUyLCBudWxsKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRnZXRQb2ludDE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQxOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDEuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRQb2ludDI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mi5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDIuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlMjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbjtcblx0fSxcblxuXHRzZXRIYW5kbGUyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRTZWdtZW50MTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDI7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5faW5kZXg7XG5cdH0sXG5cblx0Z2V0TmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fY3VydmVzO1xuXHRcdHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggKyAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgY3VydmVzWzBdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG5cdFx0cmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCAtIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBvaW50MSgpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldEhhbmRsZTIoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRIYW5kbGUyKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0UG9pbnQyKCkuaXNTZWxlY3RlZCgpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHRoaXMuZ2V0UG9pbnQxKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0SGFuZGxlMSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldEhhbmRsZTIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRQb2ludDIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdH0sXG5cblx0Z2V0VmFsdWVzOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0VmFsdWVzKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50MiwgbWF0cml4KTtcblx0fSxcblxuXHRnZXRQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0cG9pbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpXG5cdFx0XHRwb2ludHMucHVzaChuZXcgUG9pbnQoY29vcmRzW2ldLCBjb29yZHNbaSArIDFdKSk7XG5cdFx0cmV0dXJuIHBvaW50cztcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fbGVuZ3RoID0gdGhpcy5pc0xpbmVhcigpXG5cdFx0XHRcdD8gdGhpcy5fc2VnbWVudDIuX3BvaW50LmdldERpc3RhbmNlKHRoaXMuX3NlZ21lbnQxLl9wb2ludClcblx0XHRcdFx0OiBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgMCwgMSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldEFyZWEodGhpcy5nZXRWYWx1ZXMoKSk7XG5cdH0sXG5cblx0Z2V0UGFydDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKEN1cnZlLmdldFBhcnQodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pKTtcblx0fSxcblxuXHRnZXRQYXJ0TGVuZ3RoOiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pO1xuXHR9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKVxuXHRcdFx0XHR8fCAhdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLmlzWmVybygpO1xuXHR9LFxuXG5cdGlzTGluZWFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gU2VnbWVudC5pc0xpbmVhcih0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIpO1xuXHR9LFxuXG5cdGlzQ29sbGluZWFyOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdHJldHVybiBTc2VnbWVudC5pc0NvbGxpbmVhcih0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIsXG5cdFx0XHRcdGN1cnZlLl9zZWdtZW50MSwgY3VydmUuX3NlZ21lbnQyKTtcblx0fSxcblxuXHRpc09ydGhvZ29uYWxBcmM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBTZWdtZW50LmlzT3J0aG9nb25hbEFyYyh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIpO1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmZpbHRlckludGVyc2VjdGlvbnMoQ3VydmUuZ2V0SW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0dGhpcy5nZXRWYWx1ZXMoKSwgY3VydmUuZ2V0VmFsdWVzKCksIHRoaXMsIGN1cnZlLCBbXSkpO1xuXHR9LFxuXG5cdF9nZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRyZXR1cm4gaXNQYXJhbWV0ZXJcblx0XHRcdFx0PyBvZmZzZXRcblx0XHRcdFx0OiBvZmZzZXQgJiYgb2Zmc2V0LmN1cnZlID09PSB0aGlzXG5cdFx0XHRcdFx0PyBvZmZzZXQucGFyYW1ldGVyXG5cdFx0XHRcdFx0OiBvZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBpc1BhcmFtZXRlciA9PT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHQ/IDAuNVxuXHRcdFx0XHRcdFx0OiB0aGlzLmdldFBhcmFtZXRlckF0KG9mZnNldCwgMCk7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyLCBpZ25vcmVMaW5lYXIpIHtcblx0XHR2YXIgcGFyYW1ldGVyID0gdGhpcy5fZ2V0UGFyYW1ldGVyKG9mZnNldCwgaXNQYXJhbWV0ZXIpLFxuXHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMDEsXG5cdFx0XHRyZXMgPSBudWxsO1xuXHRcdGlmIChwYXJhbWV0ZXIgPiB0b2xlcmFuY2UgJiYgcGFyYW1ldGVyIDwgMSAtIHRvbGVyYW5jZSkge1xuXHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHRoaXMuZ2V0VmFsdWVzKCksIHBhcmFtZXRlciksXG5cdFx0XHRcdGlzTGluZWFyID0gaWdub3JlTGluZWFyID8gZmFsc2UgOiB0aGlzLmlzTGluZWFyKCksXG5cdFx0XHRcdGxlZnQgPSBwYXJ0c1swXSxcblx0XHRcdFx0cmlnaHQgPSBwYXJ0c1sxXTtcblxuXHRcdFx0aWYgKCFpc0xpbmVhcikge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChsZWZ0WzJdIC0gbGVmdFswXSxcblx0XHRcdFx0XHRcdGxlZnRbM10gLSBsZWZ0WzFdKTtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldChyaWdodFs0XSAtIHJpZ2h0WzZdLFxuXHRcdFx0XHRcdFx0cmlnaHRbNV0gLSByaWdodFs3XSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB4ID0gbGVmdFs2XSwgeSA9IGxlZnRbN10sXG5cdFx0XHRcdHNlZ21lbnQgPSBuZXcgU2VnbWVudChuZXcgUG9pbnQoeCwgeSksXG5cdFx0XHRcdFx0XHQhaXNMaW5lYXIgJiYgbmV3IFBvaW50KGxlZnRbNF0gLSB4LCBsZWZ0WzVdIC0geSksXG5cdFx0XHRcdFx0XHQhaXNMaW5lYXIgJiYgbmV3IFBvaW50KHJpZ2h0WzJdIC0geCwgcmlnaHRbM10gLSB5KSk7XG5cblx0XHRcdGlmICh0aGlzLl9wYXRoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zZWdtZW50MS5faW5kZXggPiAwICYmIHRoaXMuX3NlZ21lbnQyLl9pbmRleCA9PT0gMCkge1xuXHRcdFx0XHRcdHRoaXMuX3BhdGguYWRkKHNlZ21lbnQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3BhdGguaW5zZXJ0KHRoaXMuX3NlZ21lbnQyLl9pbmRleCwgc2VnbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzID0gdGhpcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBlbmQgPSB0aGlzLl9zZWdtZW50Mjtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDIgPSBzZWdtZW50O1xuXHRcdFx0XHRyZXMgPSBuZXcgQ3VydmUoc2VnbWVudCwgZW5kKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoXG5cdFx0XHQ/IHRoaXMuX3BhdGguc3BsaXQodGhpcy5fc2VnbWVudDEuX2luZGV4LFxuXHRcdFx0XHRcdHRoaXMuX2dldFBhcmFtZXRlcihvZmZzZXQsIGlzUGFyYW1ldGVyKSlcblx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQyLnJldmVyc2UoKSwgdGhpcy5fc2VnbWVudDEucmV2ZXJzZSgpKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZW1vdmVkID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3BhdGgpIHtcblx0XHRcdHZhciBzZWdtZW50MiA9IHRoaXMuX3NlZ21lbnQyLFxuXHRcdFx0XHRoYW5kbGVPdXQgPSBzZWdtZW50Mi5faGFuZGxlT3V0O1xuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnQyLnJlbW92ZSgpO1xuXHRcdFx0aWYgKHJlbW92ZWQpXG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KGhhbmRsZU91dC54LCBoYW5kbGVPdXQueSk7XG5cdFx0fVxuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50Mik7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50MTogJyArIHRoaXMuX3NlZ21lbnQxLl9wb2ludCBdO1xuXHRcdGlmICghdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTE6ICcgKyB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0KTtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTI6ICcgKyB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4pO1xuXHRcdHBhcnRzLnB1c2goJ3BvaW50MjogJyArIHRoaXMuX3NlZ21lbnQyLl9wb2ludCk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuc3RhdGljczoge1xuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KSB7XG5cdFx0dmFyIHAxID0gc2VnbWVudDEuX3BvaW50LFxuXHRcdFx0aDEgPSBzZWdtZW50MS5faGFuZGxlT3V0LFxuXHRcdFx0aDIgPSBzZWdtZW50Mi5faGFuZGxlSW4sXG5cdFx0XHRwMiA9IHNlZ21lbnQyLl9wb2ludCxcblx0XHRcdHZhbHVlcyA9IFtcblx0XHRcdFx0cDEuX3gsIHAxLl95LFxuXHRcdFx0XHRwMS5feCArIGgxLl94LCBwMS5feSArIGgxLl95LFxuXHRcdFx0XHRwMi5feCArIGgyLl94LCBwMi5feSArIGgyLl95LFxuXHRcdFx0XHRwMi5feCwgcDIuX3lcblx0XHRcdF07XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXModmFsdWVzLCB2YWx1ZXMsIDQpO1xuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0c3ViZGl2aWRlOiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN107XG5cdFx0aWYgKHQgPT09IHVuZGVmaW5lZClcblx0XHRcdHQgPSAwLjU7XG5cdFx0dmFyIHUgPSAxIC0gdCxcblx0XHRcdHAzeCA9IHUgKiBwMXggKyB0ICogYzF4LCBwM3kgPSB1ICogcDF5ICsgdCAqIGMxeSxcblx0XHRcdHA0eCA9IHUgKiBjMXggKyB0ICogYzJ4LCBwNHkgPSB1ICogYzF5ICsgdCAqIGMyeSxcblx0XHRcdHA1eCA9IHUgKiBjMnggKyB0ICogcDJ4LCBwNXkgPSB1ICogYzJ5ICsgdCAqIHAyeSxcblx0XHRcdHA2eCA9IHUgKiBwM3ggKyB0ICogcDR4LCBwNnkgPSB1ICogcDN5ICsgdCAqIHA0eSxcblx0XHRcdHA3eCA9IHUgKiBwNHggKyB0ICogcDV4LCBwN3kgPSB1ICogcDR5ICsgdCAqIHA1eSxcblx0XHRcdHA4eCA9IHUgKiBwNnggKyB0ICogcDd4LCBwOHkgPSB1ICogcDZ5ICsgdCAqIHA3eTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0W3AxeCwgcDF5LCBwM3gsIHAzeSwgcDZ4LCBwNnksIHA4eCwgcDh5XSxcblx0XHRcdFtwOHgsIHA4eSwgcDd4LCBwN3ksIHA1eCwgcDV5LCBwMngsIHAyeV1cblx0XHRdO1xuXHR9LFxuXG5cdHNvbHZlQ3ViaWM6IGZ1bmN0aW9uICh2LCBjb29yZCwgdmFsLCByb290cywgbWluLCBtYXgpIHtcblx0XHR2YXIgcDEgPSB2W2Nvb3JkXSxcblx0XHRcdGMxID0gdltjb29yZCArIDJdLFxuXHRcdFx0YzIgPSB2W2Nvb3JkICsgNF0sXG5cdFx0XHRwMiA9IHZbY29vcmQgKyA2XSxcblx0XHRcdGMgPSAzICogKGMxIC0gcDEpLFxuXHRcdFx0YiA9IDMgKiAoYzIgLSBjMSkgLSBjLFxuXHRcdFx0YSA9IHAyIC0gcDEgLSBjIC0gYjtcblx0XHRyZXR1cm4gTnVtZXJpY2FsLnNvbHZlQ3ViaWMoYSwgYiwgYywgcDEgLSB2YWwsIHJvb3RzLCBtaW4sIG1heCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyT2Y6IGZ1bmN0aW9uKHYsIHgsIHkpIHtcblx0XHR2YXIgdG9sZXJhbmNlID0gMC4wMDAwMDE7XG5cdFx0aWYgKE1hdGguYWJzKHZbMF0gLSB4KSA8IHRvbGVyYW5jZSAmJiBNYXRoLmFicyh2WzFdIC0geSkgPCB0b2xlcmFuY2UpXG5cdFx0XHRyZXR1cm4gMDtcblx0XHRpZiAoTWF0aC5hYnModls2XSAtIHgpIDwgdG9sZXJhbmNlICYmIE1hdGguYWJzKHZbN10gLSB5KSA8IHRvbGVyYW5jZSlcblx0XHRcdHJldHVybiAxO1xuXHRcdHZhciB0eHMgPSBbXSxcblx0XHRcdHR5cyA9IFtdLFxuXHRcdFx0c3ggPSBDdXJ2ZS5zb2x2ZUN1YmljKHYsIDAsIHgsIHR4cywgMCwgMSksXG5cdFx0XHRzeSA9IEN1cnZlLnNvbHZlQ3ViaWModiwgMSwgeSwgdHlzLCAwLCAxKSxcblx0XHRcdHR4LCB0eTtcblx0XHRmb3IgKHZhciBjeCA9IDA7ICBzeCA9PT0gLTEgfHwgY3ggPCBzeDspIHtcblx0XHRcdGlmIChzeCA9PT0gLTEgfHwgKHR4ID0gdHhzW2N4KytdKSA+IDAgJiYgdHggPCAxKSB7XG5cdFx0XHRcdGZvciAodmFyIGN5ID0gMDsgc3kgPT09IC0xIHx8IGN5IDwgc3k7KSB7XG5cdFx0XHRcdFx0aWYgKHN5ID09PSAtMSB8fCAodHkgPSB0eXNbY3krK10pID4gMCAmJiB0eSA8IDEpIHtcblx0XHRcdFx0XHRcdGlmIChzeCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0dHggPSB0eTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc3kgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHR5ID0gdHg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnModHggLSB0eSkgPCB0b2xlcmFuY2UpXG5cdFx0XHRcdFx0XHRcdHJldHVybiAodHggKyB0eSkgKiAwLjU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeCA9PT0gLTEpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldFBhcnQ6IGZ1bmN0aW9uKHYsIGZyb20sIHRvKSB7XG5cdFx0aWYgKGZyb20gPiAwKVxuXHRcdFx0diA9IEN1cnZlLnN1YmRpdmlkZSh2LCBmcm9tKVsxXTtcblx0XHRpZiAodG8gPCAxKVxuXHRcdFx0diA9IEN1cnZlLnN1YmRpdmlkZSh2LCAodG8gLSBmcm9tKSAvICgxIC0gZnJvbSkpWzBdO1xuXHRcdHJldHVybiB2O1xuXHR9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gIShpc1plcm8odlswXSAtIHZbMl0pICYmIGlzWmVybyh2WzFdIC0gdlszXSlcblx0XHRcdFx0JiYgaXNaZXJvKHZbNF0gLSB2WzZdKSAmJiBpc1plcm8odls1XSAtIHZbN10pKTtcblx0fSxcblxuXHRpc0xpbmVhcjogZnVuY3Rpb24odikge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblx0XHRcdGwgPSBuZXcgUG9pbnQocDJ4IC0gcDF4LCBwMnkgLSBwMXkpO1xuXHRcdHJldHVybiBsLmlzQ29sbGluZWFyKG5ldyBQb2ludCh2WzJdIC0gcDF4LCB2WzNdIC0gcDF5KSlcblx0XHRcdFx0JiYgbC5pc0NvbGxpbmVhcihuZXcgUG9pbnQodls0XSAtIHAyeCwgdls1XSAtIHAyeSkpO1xuXHR9LFxuXG5cdGlzRmxhdEVub3VnaDogZnVuY3Rpb24odiwgdG9sZXJhbmNlKSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cdFx0XHR1eCA9IDMgKiBjMXggLSAyICogcDF4IC0gcDJ4LFxuXHRcdFx0dXkgPSAzICogYzF5IC0gMiAqIHAxeSAtIHAyeSxcblx0XHRcdHZ4ID0gMyAqIGMyeCAtIDIgKiBwMnggLSBwMXgsXG5cdFx0XHR2eSA9IDMgKiBjMnkgLSAyICogcDJ5IC0gcDF5O1xuXHRcdHJldHVybiBNYXRoLm1heCh1eCAqIHV4LCB2eCAqIHZ4KSArIE1hdGgubWF4KHV5ICogdXksIHZ5ICogdnkpXG5cdFx0XHRcdDwgMTAgKiB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24odikge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddO1xuXHRcdHJldHVybiAoICAzLjAgKiBjMXkgKiBwMXggLSAxLjUgKiBjMXkgKiBjMnhcblx0XHRcdFx0LSAxLjUgKiBjMXkgKiBwMnggLSAzLjAgKiBwMXkgKiBjMXhcblx0XHRcdFx0LSAxLjUgKiBwMXkgKiBjMnggLSAwLjUgKiBwMXkgKiBwMnhcblx0XHRcdFx0KyAxLjUgKiBjMnkgKiBwMXggKyAxLjUgKiBjMnkgKiBjMXhcblx0XHRcdFx0LSAzLjAgKiBjMnkgKiBwMnggKyAwLjUgKiBwMnkgKiBwMXhcblx0XHRcdFx0KyAxLjUgKiBwMnkgKiBjMXggKyAzLjAgKiBwMnkgKiBjMngpIC8gMTA7XG5cdH0sXG5cblx0Z2V0RWRnZVN1bTogZnVuY3Rpb24odikge1xuXHRcdHJldHVyblx0ICAodlswXSAtIHZbMl0pICogKHZbM10gKyB2WzFdKVxuXHRcdFx0XHQrICh2WzJdIC0gdls0XSkgKiAodls1XSArIHZbM10pXG5cdFx0XHRcdCsgKHZbNF0gLSB2WzZdKSAqICh2WzddICsgdls1XSk7XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbih2KSB7XG5cdFx0dmFyIG1pbiA9IHYuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBtaW4uc2xpY2UoKSxcblx0XHRcdHJvb3RzID0gWzAsIDBdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKVxuXHRcdFx0Q3VydmUuX2FkZEJvdW5kcyh2W2ldLCB2W2kgKyAyXSwgdltpICsgNF0sIHZbaSArIDZdLFxuXHRcdFx0XHRcdGksIDAsIG1pbiwgbWF4LCByb290cyk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcblx0fSxcblxuXHRfYWRkQm91bmRzOiBmdW5jdGlvbih2MCwgdjEsIHYyLCB2MywgY29vcmQsIHBhZGRpbmcsIG1pbiwgbWF4LCByb290cykge1xuXHRcdGZ1bmN0aW9uIGFkZCh2YWx1ZSwgcGFkZGluZykge1xuXHRcdFx0dmFyIGxlZnQgPSB2YWx1ZSAtIHBhZGRpbmcsXG5cdFx0XHRcdHJpZ2h0ID0gdmFsdWUgKyBwYWRkaW5nO1xuXHRcdFx0aWYgKGxlZnQgPCBtaW5bY29vcmRdKVxuXHRcdFx0XHRtaW5bY29vcmRdID0gbGVmdDtcblx0XHRcdGlmIChyaWdodCA+IG1heFtjb29yZF0pXG5cdFx0XHRcdG1heFtjb29yZF0gPSByaWdodDtcblx0XHR9XG5cdFx0dmFyIGEgPSAzICogKHYxIC0gdjIpIC0gdjAgKyB2Myxcblx0XHRcdGIgPSAyICogKHYwICsgdjIpIC0gNCAqIHYxLFxuXHRcdFx0YyA9IHYxIC0gdjAsXG5cdFx0XHRjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cyksXG5cdFx0XHR0TWluID0gMC4wMDAwMDEsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0YWRkKHYzLCAwKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdHZhciB0ID0gcm9vdHNbaV0sXG5cdFx0XHRcdHUgPSAxIC0gdDtcblx0XHRcdGlmICh0TWluIDwgdCAmJiB0IDwgdE1heClcblx0XHRcdFx0YWRkKHUgKiB1ICogdSAqIHYwXG5cdFx0XHRcdFx0KyAzICogdSAqIHUgKiB0ICogdjFcblx0XHRcdFx0XHQrIDMgKiB1ICogdCAqIHQgKiB2MlxuXHRcdFx0XHRcdCsgdCAqIHQgKiB0ICogdjMsXG5cdFx0XHRcdFx0cGFkZGluZyk7XG5cdFx0fVxuXHR9XG59fSwgQmFzZS5lYWNoKFxuXHRbJ2dldEJvdW5kcycsICdnZXRTdHJva2VCb3VuZHMnLCAnZ2V0SGFuZGxlQm91bmRzJywgJ2dldFJvdWdoQm91bmRzJ10sXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdFx0dGhpcy5fYm91bmRzID0ge307XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdO1xuXHRcdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdID0gUGF0aFtuYW1lXShbdGhpcy5fc2VnbWVudDEsXG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50Ml0sIGZhbHNlLCB0aGlzLl9wYXRoLmdldFN0eWxlKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJvdW5kcy5jbG9uZSgpO1xuXHRcdH07XG5cdH0sXG57XG5cbn0pLCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24ob2Zmc2V0LCBzdGFydCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRQYXJhbWV0ZXJBdCh0aGlzLmdldFZhbHVlcygpLCBvZmZzZXQsIHN0YXJ0KTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJPZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih0aGlzLmdldFZhbHVlcygpLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0dmFyIHQgPSBpc1BhcmFtZXRlciA/IG9mZnNldCA6IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0KTtcblx0XHRyZXR1cm4gdCAhPSBudWxsICYmIHQgPj0gMCAmJiB0IDw9IDFcblx0XHRcdFx0PyBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCB0KVxuXHRcdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25PZjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb25BdCh0aGlzLmdldFBhcmFtZXRlck9mKFBvaW50LnJlYWQoYXJndW1lbnRzKSksXG5cdFx0XHRcdHRydWUpO1xuXHR9LFxuXG5cdGdldE9mZnNldE9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0Y291bnQgPSAxMDAsXG5cdFx0XHRtaW5EaXN0ID0gSW5maW5pdHksXG5cdFx0XHRtaW5UID0gMDtcblxuXHRcdGZ1bmN0aW9uIHJlZmluZSh0KSB7XG5cdFx0XHRpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuXHRcdFx0XHR2YXIgZGlzdCA9IHBvaW50LmdldERpc3RhbmNlKEN1cnZlLmdldFBvaW50KHZhbHVlcywgdCksIHRydWUpO1xuXHRcdFx0XHRpZiAoZGlzdCA8IG1pbkRpc3QpIHtcblx0XHRcdFx0XHRtaW5EaXN0ID0gZGlzdDtcblx0XHRcdFx0XHRtaW5UID0gdDtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspXG5cdFx0XHRyZWZpbmUoaSAvIGNvdW50KTtcblxuXHRcdHZhciBzdGVwID0gMSAvIChjb3VudCAqIDIpO1xuXHRcdHdoaWxlIChzdGVwID4gMC4wMDAwMDEpIHtcblx0XHRcdGlmICghcmVmaW5lKG1pblQgLSBzdGVwKSAmJiAhcmVmaW5lKG1pblQgKyBzdGVwKSlcblx0XHRcdFx0c3RlcCAvPSAyO1xuXHRcdH1cblx0XHR2YXIgcHQgPSBDdXJ2ZS5nZXRQb2ludCh2YWx1ZXMsIG1pblQpO1xuXHRcdHJldHVybiBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCBtaW5ULCBwdCwgbnVsbCwgbnVsbCwgbnVsbCxcblx0XHRcdFx0cG9pbnQuZ2V0RGlzdGFuY2UocHQpKTtcblx0fSxcblxuXHRnZXROZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmdldFBvaW50KCk7XG5cdH1cblxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG1ldGhvZHMgPSBbJ2dldFBvaW50JywgJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldFdlaWdodGVkVGFuZ2VudCcsXG5cdFx0J2dldFdlaWdodGVkTm9ybWFsJywgJ2dldEN1cnZhdHVyZSddO1xuXHRyZXR1cm4gQmFzZS5lYWNoKG1ldGhvZHMsXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpO1xuXHRcdFx0cmV0dXJuIEN1cnZlW25hbWVdKHZhbHVlcywgaXNQYXJhbWV0ZXIgPyBvZmZzZXRcblx0XHRcdFx0XHQ6IEN1cnZlLmdldFBhcmFtZXRlckF0KHZhbHVlcywgb2Zmc2V0LCAwKSk7XG5cdFx0fTtcblx0fSwge1xuXHRcdHN0YXRpY3M6IHtcblx0XHRcdGV2YWx1YXRlTWV0aG9kczogbWV0aG9kc1xuXHRcdH1cblx0fSlcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblxuXHRcdFx0YXggPSA5ICogKGMxeCAtIGMyeCkgKyAzICogKHAyeCAtIHAxeCksXG5cdFx0XHRieCA9IDYgKiAocDF4ICsgYzJ4KSAtIDEyICogYzF4LFxuXHRcdFx0Y3ggPSAzICogKGMxeCAtIHAxeCksXG5cblx0XHRcdGF5ID0gOSAqIChjMXkgLSBjMnkpICsgMyAqIChwMnkgLSBwMXkpLFxuXHRcdFx0YnkgPSA2ICogKHAxeSArIGMyeSkgLSAxMiAqIGMxeSxcblx0XHRcdGN5ID0gMyAqIChjMXkgLSBwMXkpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHZhciBkeCA9IChheCAqIHQgKyBieCkgKiB0ICsgY3gsXG5cdFx0XHRcdGR5ID0gKGF5ICogdCArIGJ5KSAqIHQgKyBjeTtcblx0XHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRJdGVyYXRpb25zKGEsIGIpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgoMiwgTWF0aC5taW4oMTYsIE1hdGguY2VpbChNYXRoLmFicyhiIC0gYSkgKiAzMikpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV2YWx1YXRlKHYsIHQsIHR5cGUsIG5vcm1hbGl6ZWQpIHtcblx0XHRpZiAodCA9PSBudWxsIHx8IHQgPCAwIHx8IHQgPiAxKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAwMSxcblx0XHRcdHgsIHk7XG5cblx0XHRpZiAodHlwZSA9PT0gMCAmJiAodCA8IHRvbGVyYW5jZSB8fCB0ID4gMSAtIHRvbGVyYW5jZSkpIHtcblx0XHRcdHZhciBpc1plcm8gPSB0IDwgdG9sZXJhbmNlO1xuXHRcdFx0eCA9IGlzWmVybyA/IHAxeCA6IHAyeDtcblx0XHRcdHkgPSBpc1plcm8gPyBwMXkgOiBwMnk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjeCA9IDMgKiAoYzF4IC0gcDF4KSxcblx0XHRcdFx0YnggPSAzICogKGMyeCAtIGMxeCkgLSBjeCxcblx0XHRcdFx0YXggPSBwMnggLSBwMXggLSBjeCAtIGJ4LFxuXG5cdFx0XHRcdGN5ID0gMyAqIChjMXkgLSBwMXkpLFxuXHRcdFx0XHRieSA9IDMgKiAoYzJ5IC0gYzF5KSAtIGN5LFxuXHRcdFx0XHRheSA9IHAyeSAtIHAxeSAtIGN5IC0gYnk7XG5cdFx0XHRpZiAodHlwZSA9PT0gMCkge1xuXHRcdFx0XHR4ID0gKChheCAqIHQgKyBieCkgKiB0ICsgY3gpICogdCArIHAxeDtcblx0XHRcdFx0eSA9ICgoYXkgKiB0ICsgYnkpICogdCArIGN5KSAqIHQgKyBwMXk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodCA8IHRvbGVyYW5jZSkge1xuXHRcdFx0XHRcdHggPSBjeDtcblx0XHRcdFx0XHR5ID0gY3k7XG5cdFx0XHRcdH0gZWxzZSBpZiAodCA+IDEgLSB0b2xlcmFuY2UpIHtcblx0XHRcdFx0XHR4ID0gMyAqIChwMnggLSBjMngpO1xuXHRcdFx0XHRcdHkgPSAzICogKHAyeSAtIGMyeSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9ICgzICogYXggKiB0ICsgMiAqIGJ4KSAqIHQgKyBjeDtcblx0XHRcdFx0XHR5ID0gKDMgKiBheSAqIHQgKyAyICogYnkpICogdCArIGN5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub3JtYWxpemVkKSB7XG5cdFx0XHRcdFx0aWYgKHggPT09IDAgJiYgeSA9PT0gMFxuXHRcdFx0XHRcdFx0XHQmJiAodCA8IHRvbGVyYW5jZSB8fCB0ID4gMSAtIHRvbGVyYW5jZSkpIHtcblx0XHRcdFx0XHRcdHggPSBjMnggLSBjMXg7XG5cdFx0XHRcdFx0XHR5ID0gYzJ5IC0gYzF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRcdHggLz0gbGVuO1xuXHRcdFx0XHRcdHkgLz0gbGVuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlID09PSAzKSB7XG5cdFx0XHRcdFx0dmFyIHgyID0gNiAqIGF4ICogdCArIDIgKiBieCxcblx0XHRcdFx0XHRcdHkyID0gNiAqIGF5ICogdCArIDIgKiBieSxcblx0XHRcdFx0XHRcdGQgPSBNYXRoLnBvdyh4ICogeCArIHkgKiB5LCAzIC8gMik7XG5cdFx0XHRcdFx0eCA9IGQgIT09IDAgPyAoeCAqIHkyIC0geSAqIHgyKSAvIGQgOiAwO1xuXHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlID09PSAyID8gbmV3IFBvaW50KHksIC14KSA6IG5ldyBQb2ludCh4LCB5KTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c3RhdGljczogdHJ1ZSxcblxuXHRcdGdldExlbmd0aDogZnVuY3Rpb24odiwgYSwgYikge1xuXHRcdFx0aWYgKGEgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0YSA9IDA7XG5cdFx0XHRpZiAoYiA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRiID0gMTtcblx0XHRcdHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdFx0aWYgKGEgPT09IDAgJiYgYiA9PT0gMVxuXHRcdFx0XHRcdCYmIGlzWmVybyh2WzBdIC0gdlsyXSkgJiYgaXNaZXJvKHZbMV0gLSB2WzNdKVxuXHRcdFx0XHRcdCYmIGlzWmVybyh2WzZdIC0gdls0XSkgJiYgaXNaZXJvKHZbN10gLSB2WzVdKSkge1xuXHRcdFx0XHR2YXIgZHggPSB2WzZdIC0gdlswXSxcblx0XHRcdFx0XHRkeSA9IHZbN10gLSB2WzFdO1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRcdH1cblx0XHRcdHZhciBkcyA9IGdldExlbmd0aEludGVncmFuZCh2KTtcblx0XHRcdHJldHVybiBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBhLCBiLCBnZXRJdGVyYXRpb25zKGEsIGIpKTtcblx0XHR9LFxuXG5cdFx0Z2V0UGFyYW1ldGVyQXQ6IGZ1bmN0aW9uKHYsIG9mZnNldCwgc3RhcnQpIHtcblx0XHRcdGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRzdGFydCA9IG9mZnNldCA8IDAgPyAxIDogMFxuXHRcdFx0aWYgKG9mZnNldCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHN0YXJ0O1xuXHRcdFx0dmFyIHRvbGVyYW5jZSA9IDAuMDAwMDAxLFxuXHRcdFx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRcdFx0Zm9yd2FyZCA9IG9mZnNldCA+IDAsXG5cdFx0XHRcdGEgPSBmb3J3YXJkID8gc3RhcnQgOiAwLFxuXHRcdFx0XHRiID0gZm9yd2FyZCA/IDEgOiBzdGFydCxcblx0XHRcdFx0ZHMgPSBnZXRMZW5ndGhJbnRlZ3JhbmQodiksXG5cdFx0XHRcdHJhbmdlTGVuZ3RoID0gTnVtZXJpY2FsLmludGVncmF0ZShkcywgYSwgYixcblx0XHRcdFx0XHRcdGdldEl0ZXJhdGlvbnMoYSwgYikpO1xuXHRcdFx0aWYgKGFicyhvZmZzZXQgLSByYW5nZUxlbmd0aCkgPCB0b2xlcmFuY2UpIHtcblx0XHRcdFx0cmV0dXJuIGZvcndhcmQgPyBiIDogYTtcblx0XHRcdH0gZWxzZSBpZiAoYWJzKG9mZnNldCkgPiByYW5nZUxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHZhciBndWVzcyA9IG9mZnNldCAvIHJhbmdlTGVuZ3RoLFxuXHRcdFx0XHRsZW5ndGggPSAwO1xuXHRcdFx0ZnVuY3Rpb24gZih0KSB7XG5cdFx0XHRcdGxlbmd0aCArPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBzdGFydCwgdCxcblx0XHRcdFx0XHRcdGdldEl0ZXJhdGlvbnMoc3RhcnQsIHQpKTtcblx0XHRcdFx0c3RhcnQgPSB0O1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoIC0gb2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWVyaWNhbC5maW5kUm9vdChmLCBkcywgc3RhcnQgKyBndWVzcywgYSwgYiwgMTYsXG5cdFx0XHRcdFx0dG9sZXJhbmNlKTtcblx0XHR9LFxuXG5cdFx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAwLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGdldFRhbmdlbnQ6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAxLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0Z2V0V2VpZ2h0ZWRUYW5nZW50OiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0XHRyZXR1cm4gZXZhbHVhdGUodiwgdCwgMSwgZmFsc2UpO1xuXHRcdH0sXG5cblx0XHRnZXROb3JtYWw6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAyLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0Z2V0V2VpZ2h0ZWROb3JtYWw6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAyLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGdldEN1cnZhdHVyZTogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDMsIGZhbHNlKS54O1xuXHRcdH1cblx0fTtcbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjdXJ2ZTEsIHQxLCBwb2ludDEsIGN1cnZlMiwgdDIsXG5cdFx0XHRwb2ludDIpIHtcblx0XHR2YXIgbG9jID0gbmV3IEN1cnZlTG9jYXRpb24oY3VydmUxLCB0MSwgcG9pbnQxLCBjdXJ2ZTIsIHQyLCBwb2ludDIpO1xuXHRcdGlmICghaW5jbHVkZSB8fCBpbmNsdWRlKGxvYykpXG5cdFx0XHRsb2NhdGlvbnMucHVzaChsb2MpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdHRNaW4sIHRNYXgsIHVNaW4sIHVNYXgsIG9sZFREaWZmLCByZXZlcnNlLCByZWN1cnNpb24pIHtcblx0XHRpZiAocmVjdXJzaW9uID4gMzIpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHEweCA9IHYyWzBdLCBxMHkgPSB2MlsxXSwgcTN4ID0gdjJbNl0sIHEzeSA9IHYyWzddLFxuXHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMDEsXG5cdFx0XHRnZXRTaWduZWREaXN0YW5jZSA9IExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UsXG5cdFx0XHRkMSA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjJbMl0sIHYyWzNdKSB8fCAwLFxuXHRcdFx0ZDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzRdLCB2Mls1XSkgfHwgMCxcblx0XHRcdGZhY3RvciA9IGQxICogZDIgPiAwID8gMyAvIDQgOiA0IC8gOSxcblx0XHRcdGRNaW4gPSBmYWN0b3IgKiBNYXRoLm1pbigwLCBkMSwgZDIpLFxuXHRcdFx0ZE1heCA9IGZhY3RvciAqIE1hdGgubWF4KDAsIGQxLCBkMiksXG5cdFx0XHRkcDAgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzBdLCB2MVsxXSksXG5cdFx0XHRkcDEgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzJdLCB2MVszXSksXG5cdFx0XHRkcDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzRdLCB2MVs1XSksXG5cdFx0XHRkcDMgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzZdLCB2MVs3XSksXG5cdFx0XHR0TWluTmV3LCB0TWF4TmV3LCB0RGlmZjtcblx0XHRpZiAocTB4ID09PSBxM3ggJiYgdU1heCAtIHVNaW4gPCB0b2xlcmFuY2UgJiYgcmVjdXJzaW9uID4gMykge1xuXHRcdFx0dE1heE5ldyA9IHRNaW5OZXcgPSAodE1heCArIHRNaW4pIC8gMjtcblx0XHRcdHREaWZmID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGh1bGwgPSBnZXRDb252ZXhIdWxsKGRwMCwgZHAxLCBkcDIsIGRwMyksXG5cdFx0XHRcdHRvcCA9IGh1bGxbMF0sXG5cdFx0XHRcdGJvdHRvbSA9IGh1bGxbMV0sXG5cdFx0XHRcdHRNaW5DbGlwLCB0TWF4Q2xpcDtcblx0XHRcdHRNaW5DbGlwID0gY2xpcENvbnZleEh1bGwodG9wLCBib3R0b20sIGRNaW4sIGRNYXgpO1xuXHRcdFx0dG9wLnJldmVyc2UoKTtcblx0XHRcdGJvdHRvbS5yZXZlcnNlKCk7XG5cdFx0XHR0TWF4Q2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcCwgYm90dG9tLCBkTWluLCBkTWF4KTtcblx0XHRcdGlmICh0TWluQ2xpcCA9PSBudWxsIHx8IHRNYXhDbGlwID09IG51bGwpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHYxID0gQ3VydmUuZ2V0UGFydCh2MSwgdE1pbkNsaXAsIHRNYXhDbGlwKTtcblx0XHRcdHREaWZmID0gdE1heENsaXAgLSB0TWluQ2xpcDtcblx0XHRcdHRNaW5OZXcgPSB0TWF4ICogdE1pbkNsaXAgKyB0TWluICogKDEgLSB0TWluQ2xpcCk7XG5cdFx0XHR0TWF4TmV3ID0gdE1heCAqIHRNYXhDbGlwICsgdE1pbiAqICgxIC0gdE1heENsaXApO1xuXHRcdH1cblx0XHRpZiAob2xkVERpZmYgPiAwLjUgJiYgdERpZmYgPiAwLjUpIHtcblx0XHRcdGlmICh0TWF4TmV3IC0gdE1pbk5ldyA+IHVNYXggLSB1TWluKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MSwgMC41KSxcblx0XHRcdFx0XHR0ID0gdE1pbk5ldyArICh0TWF4TmV3IC0gdE1pbk5ldykgLyAyO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0djIsIHBhcnRzWzBdLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHRNaW5OZXcsIHQsIHREaWZmLCAhcmV2ZXJzZSwgKytyZWN1cnNpb24pO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0djIsIHBhcnRzWzFdLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHQsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MiwgMC41KSxcblx0XHRcdFx0XHR0ID0gdU1pbiArICh1TWF4IC0gdU1pbikgLyAyO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0cGFydHNbMF0sIHYxLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHQsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgKytyZWN1cnNpb24pO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0cGFydHNbMV0sIHYxLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHQsIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKE1hdGgubWF4KHVNYXggLSB1TWluLCB0TWF4TmV3IC0gdE1pbk5ldykgPCB0b2xlcmFuY2UpIHtcblx0XHRcdHZhciB0MSA9IHRNaW5OZXcgKyAodE1heE5ldyAtIHRNaW5OZXcpIC8gMixcblx0XHRcdFx0dDIgPSB1TWluICsgKHVNYXggLSB1TWluKSAvIDI7XG5cdFx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRjdXJ2ZTIsIHQyLCBDdXJ2ZS5nZXRQb2ludCh2MiwgdDIpLFxuXHRcdFx0XHRcdFx0Y3VydmUxLCB0MSwgQ3VydmUuZ2V0UG9pbnQodjEsIHQxKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRjdXJ2ZTEsIHQxLCBDdXJ2ZS5nZXRQb2ludCh2MSwgdDEpLFxuXHRcdFx0XHRcdFx0Y3VydmUyLCB0MiwgQ3VydmUuZ2V0UG9pbnQodjIsIHQyKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0RGlmZiA+IDApIHtcblx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyh2MiwgdjEsIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0dU1pbiwgdU1heCwgdE1pbk5ldywgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCArK3JlY3Vyc2lvbik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29udmV4SHVsbChkcTAsIGRxMSwgZHEyLCBkcTMpIHtcblx0XHR2YXIgcDAgPSBbIDAsIGRxMCBdLFxuXHRcdFx0cDEgPSBbIDEgLyAzLCBkcTEgXSxcblx0XHRcdHAyID0gWyAyIC8gMywgZHEyIF0sXG5cdFx0XHRwMyA9IFsgMSwgZHEzIF0sXG5cdFx0XHRnZXRTaWduZWREaXN0YW5jZSA9IExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UsXG5cdFx0XHRkaXN0MSA9IGdldFNpZ25lZERpc3RhbmNlKDAsIGRxMCwgMSwgZHEzLCAxIC8gMywgZHExKSxcblx0XHRcdGRpc3QyID0gZ2V0U2lnbmVkRGlzdGFuY2UoMCwgZHEwLCAxLCBkcTMsIDIgLyAzLCBkcTIpLFxuXHRcdFx0ZmxpcCA9IGZhbHNlLFxuXHRcdFx0aHVsbDtcblx0XHRpZiAoZGlzdDEgKiBkaXN0MiA8IDApIHtcblx0XHRcdGh1bGwgPSBbW3AwLCBwMSwgcDNdLCBbcDAsIHAyLCBwM11dO1xuXHRcdFx0ZmxpcCA9IGRpc3QxIDwgMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBtYXgsIGNyb3NzID0gMCxcblx0XHRcdFx0ZGlzdFplcm8gPSBkaXN0MSA9PT0gMCB8fCBkaXN0MiA9PT0gMDtcblx0XHRcdGlmIChNYXRoLmFicyhkaXN0MSkgPiBNYXRoLmFicyhkaXN0MikpIHtcblx0XHRcdFx0cG1heCA9IHAxO1xuXHRcdFx0XHRjcm9zcyA9IChkcTMgLSBkcTIgLSAoZHEzIC0gZHEwKSAvIDMpXG5cdFx0XHRcdFx0XHQqICgyICogKGRxMyAtIGRxMikgLSBkcTMgKyBkcTEpIC8gMztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBtYXggPSBwMjtcblx0XHRcdFx0Y3Jvc3MgPSAoZHExIC0gZHEwICsgKGRxMCAtIGRxMykgLyAzKVxuXHRcdFx0XHRcdFx0KiAoLTIgKiAoZHEwIC0gZHExKSArIGRxMCAtIGRxMikgLyAzO1xuXHRcdFx0fVxuXHRcdFx0aHVsbCA9IGNyb3NzIDwgMCB8fCBkaXN0WmVyb1xuXHRcdFx0XHRcdD8gW1twMCwgcG1heCwgcDNdLCBbcDAsIHAzXV1cblx0XHRcdFx0XHQ6IFtbcDAsIHAxLCBwMiwgcDNdLCBbcDAsIHAzXV07XG5cdFx0XHRmbGlwID0gZGlzdDEgPyBkaXN0MSA8IDAgOiBkaXN0MiA8IDA7XG5cdFx0fVxuXHRcdHJldHVybiBmbGlwID8gaHVsbC5yZXZlcnNlKCkgOiBodWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xpcENvbnZleEh1bGwoaHVsbFRvcCwgaHVsbEJvdHRvbSwgZE1pbiwgZE1heCkge1xuXHRcdGlmIChodWxsVG9wWzBdWzFdIDwgZE1pbikge1xuXHRcdFx0cmV0dXJuIGNsaXBDb252ZXhIdWxsUGFydChodWxsVG9wLCB0cnVlLCBkTWluKTtcblx0XHR9IGVsc2UgaWYgKGh1bGxCb3R0b21bMF1bMV0gPiBkTWF4KSB7XG5cdFx0XHRyZXR1cm4gY2xpcENvbnZleEh1bGxQYXJ0KGh1bGxCb3R0b20sIGZhbHNlLCBkTWF4KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGh1bGxUb3BbMF1bMF07XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY2xpcENvbnZleEh1bGxQYXJ0KHBhcnQsIHRvcCwgdGhyZXNob2xkKSB7XG5cdFx0dmFyIHB4ID0gcGFydFswXVswXSxcblx0XHRcdHB5ID0gcGFydFswXVsxXTtcblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHBhcnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcXggPSBwYXJ0W2ldWzBdLFxuXHRcdFx0XHRxeSA9IHBhcnRbaV1bMV07XG5cdFx0XHRpZiAodG9wID8gcXkgPj0gdGhyZXNob2xkIDogcXkgPD0gdGhyZXNob2xkKVxuXHRcdFx0XHRyZXR1cm4gcHggKyAodGhyZXNob2xkIC0gcHkpICogKHF4IC0gcHgpIC8gKHF5IC0gcHkpO1xuXHRcdFx0cHggPSBxeDtcblx0XHRcdHB5ID0gcXk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQ3VydmVMaW5lSW50ZXJzZWN0aW9ucyh2MSwgdjIsIGN1cnZlMSwgY3VydmUyLCBsb2NhdGlvbnMsXG5cdFx0XHRpbmNsdWRlKSB7XG5cdFx0dmFyIGZsaXAgPSBDdXJ2ZS5pc0xpbmVhcih2MSksXG5cdFx0XHR2YyA9IGZsaXAgPyB2MiA6IHYxLFxuXHRcdFx0dmwgPSBmbGlwID8gdjEgOiB2Mixcblx0XHRcdGx4MSA9IHZsWzBdLCBseTEgPSB2bFsxXSxcblx0XHRcdGx4MiA9IHZsWzZdLCBseTIgPSB2bFs3XSxcblx0XHRcdGxkeCA9IGx4MiAtIGx4MSxcblx0XHRcdGxkeSA9IGx5MiAtIGx5MSxcblx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMigtbGR5LCBsZHgpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0cmx4MiA9IGxkeCAqIGNvcyAtIGxkeSAqIHNpbixcblx0XHRcdHJ2bCA9IFswLCAwLCAwLCAwLCBybHgyLCAwLCBybHgyLCAwXSxcblx0XHRcdHJ2YyA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpIHtcblx0XHRcdHZhciB4ID0gdmNbaV0gLSBseDEsXG5cdFx0XHRcdHkgPSB2Y1tpICsgMV0gLSBseTE7XG5cdFx0XHRydmMucHVzaChcblx0XHRcdFx0eCAqIGNvcyAtIHkgKiBzaW4sXG5cdFx0XHRcdHkgKiBjb3MgKyB4ICogc2luKTtcblx0XHR9XG5cdFx0dmFyIHJvb3RzID0gW10sXG5cdFx0XHRjb3VudCA9IEN1cnZlLnNvbHZlQ3ViaWMocnZjLCAxLCAwLCByb290cywgMCwgMSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgdGMgPSByb290c1tpXSxcblx0XHRcdFx0eCA9IEN1cnZlLmdldFBvaW50KHJ2YywgdGMpLng7XG5cdFx0XHRpZiAoeCA+PSAwICYmIHggPD0gcmx4Mikge1xuXHRcdFx0XHR2YXIgdGwgPSBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZihydmwsIHgsIDApLFxuXHRcdFx0XHRcdHQxID0gZmxpcCA/IHRsIDogdGMsXG5cdFx0XHRcdFx0dDIgPSBmbGlwID8gdGMgOiB0bDtcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdFx0Y3VydmUxLCB0MSwgQ3VydmUuZ2V0UG9pbnQodjEsIHQxKSxcblx0XHRcdFx0XHRcdGN1cnZlMiwgdDIsIEN1cnZlLmdldFBvaW50KHYyLCB0MikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZExpbmVJbnRlcnNlY3Rpb24odjEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG5cdFx0dmFyIHBvaW50ID0gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHYxWzBdLCB2MVsxXSwgdjFbNl0sIHYxWzddLFxuXHRcdFx0XHR2MlswXSwgdjJbMV0sIHYyWzZdLCB2Mls3XSk7XG5cdFx0aWYgKHBvaW50KSB7XG5cdFx0XHR2YXIgeCA9IHBvaW50LngsXG5cdFx0XHRcdHkgPSBwb2ludC55O1xuXHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdGN1cnZlMSwgQ3VydmUuZ2V0UGFyYW1ldGVyT2YodjEsIHgsIHkpLCBwb2ludCxcblx0XHRcdFx0XHRjdXJ2ZTIsIEN1cnZlLmdldFBhcmFtZXRlck9mKHYyLCB4LCB5KSwgcG9pbnQpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRpY3M6IHtcblx0XHRnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbih2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG5cdFx0XHR2YXIgbGluZWFyMSA9IEN1cnZlLmlzTGluZWFyKHYxKSxcblx0XHRcdFx0bGluZWFyMiA9IEN1cnZlLmlzTGluZWFyKHYyKSxcblx0XHRcdFx0YzFwMSA9IGMxLmdldFBvaW50MSgpLFxuXHRcdFx0XHRjMXAyID0gYzEuZ2V0UG9pbnQyKCksXG5cdFx0XHRcdGMycDEgPSBjMi5nZXRQb2ludDEoKSxcblx0XHRcdFx0YzJwMiA9IGMyLmdldFBvaW50MigpLFxuXHRcdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAwMTtcblx0XHRcdGlmIChjMXAxLmlzQ2xvc2UoYzJwMSwgdG9sZXJhbmNlKSlcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgMCwgYzFwMSwgYzIsIDAsIGMxcDEpO1xuXHRcdFx0aWYgKGMxcDEuaXNDbG9zZShjMnAyLCB0b2xlcmFuY2UpKVxuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsIGMxLCAwLCBjMXAxLCBjMiwgMSwgYzFwMSk7XG5cdFx0XHQobGluZWFyMSAmJiBsaW5lYXIyXG5cdFx0XHRcdD8gYWRkTGluZUludGVyc2VjdGlvblxuXHRcdFx0XHQ6IGxpbmVhcjEgfHwgbGluZWFyMlxuXHRcdFx0XHRcdD8gYWRkQ3VydmVMaW5lSW50ZXJzZWN0aW9uc1xuXHRcdFx0XHRcdDogYWRkQ3VydmVJbnRlcnNlY3Rpb25zKShcblx0XHRcdFx0XHRcdHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHQwLCAxLCAwLCAxLCAwLCBmYWxzZSwgMCk7XG5cdFx0XHRpZiAoYzFwMi5pc0Nsb3NlKGMycDEsIHRvbGVyYW5jZSkpXG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSwgYzEsIDEsIGMxcDIsIGMyLCAwLCBjMXAyKTtcblx0XHRcdGlmIChjMXAyLmlzQ2xvc2UoYzJwMiwgdG9sZXJhbmNlKSlcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgMSwgYzFwMiwgYzIsIDEsIGMxcDIpO1xuXHRcdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0XHR9LFxuXG5cdFx0ZmlsdGVySW50ZXJzZWN0aW9uczogZnVuY3Rpb24obG9jYXRpb25zLCBfZXhwYW5kKSB7XG5cdFx0XHR2YXIgbGFzdCA9IGxvY2F0aW9ucy5sZW5ndGggLSAxLFxuXHRcdFx0XHR0TWF4ID0gMSAtIDAuMDAwMDAxO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGxhc3Q7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHZhciBsb2MgPSBsb2NhdGlvbnNbaV0sXG5cdFx0XHRcdFx0bmV4dCA9IGxvYy5fY3VydmUuZ2V0TmV4dCgpLFxuXHRcdFx0XHRcdG5leHQyID0gbG9jLl9jdXJ2ZTIuZ2V0TmV4dCgpO1xuXHRcdFx0XHRpZiAobmV4dCAmJiBsb2MuX3BhcmFtZXRlciA+PSB0TWF4KSB7XG5cdFx0XHRcdFx0bG9jLl9wYXJhbWV0ZXIgPSAwO1xuXHRcdFx0XHRcdGxvYy5fY3VydmUgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuZXh0MiAmJiBsb2MuX3BhcmFtZXRlcjIgPj0gdE1heCkge1xuXHRcdFx0XHRcdGxvYy5fcGFyYW1ldGVyMiA9IDA7XG5cdFx0XHRcdFx0bG9jLl9jdXJ2ZTIgPSBuZXh0Mjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjb21wYXJlKGxvYzEsIGxvYzIpIHtcblx0XHRcdFx0dmFyIHBhdGgxID0gbG9jMS5nZXRQYXRoKCksXG5cdFx0XHRcdFx0cGF0aDIgPSBsb2MyLmdldFBhdGgoKTtcblx0XHRcdFx0cmV0dXJuIHBhdGgxID09PSBwYXRoMlxuXHRcdFx0XHRcdFx0PyAobG9jMS5nZXRJbmRleCgpICsgbG9jMS5nZXRQYXJhbWV0ZXIoKSlcblx0XHRcdFx0XHRcdFx0XHQtIChsb2MyLmdldEluZGV4KCkgKyBsb2MyLmdldFBhcmFtZXRlcigpKVxuXHRcdFx0XHRcdFx0OiBwYXRoMS5faWQgLSBwYXRoMi5faWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsYXN0ID4gMCkge1xuXHRcdFx0XHRsb2NhdGlvbnMuc29ydChjb21wYXJlKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IGxhc3Q7IGkgPiAwOyBpLS0pIHtcblx0XHRcdFx0XHRpZiAobG9jYXRpb25zW2ldLmVxdWFscyhsb2NhdGlvbnNbaSAtIDFdKSkge1xuXHRcdFx0XHRcdFx0bG9jYXRpb25zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdGxhc3QtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChfZXhwYW5kKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSBsYXN0OyBpID49IDA7IGktLSlcblx0XHRcdFx0XHRsb2NhdGlvbnMucHVzaChsb2NhdGlvbnNbaV0uZ2V0SW50ZXJzZWN0aW9uKCkpO1xuXHRcdFx0XHRsb2NhdGlvbnMuc29ydChjb21wYXJlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdFx0fVxuXHR9fTtcbn0pO1xuXG52YXIgQ3VydmVMb2NhdGlvbiA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ3VydmVMb2NhdGlvbicsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlTG9jYXRpb24oY3VydmUsIHBhcmFtZXRlciwgcG9pbnQsIF9jdXJ2ZTIsXG5cdFx0XHRfcGFyYW1ldGVyMiwgX3BvaW50MiwgX2Rpc3RhbmNlKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KEN1cnZlTG9jYXRpb24pO1xuXHRcdHZhciBwYXRoID0gY3VydmUuX3BhdGg7XG5cdFx0dGhpcy5fdmVyc2lvbiA9IHBhdGggPyBwYXRoLl92ZXJzaW9uIDogMDtcblx0XHR0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xuXHRcdHRoaXMuX3BhcmFtZXRlciA9IHBhcmFtZXRlcjtcblx0XHR0aGlzLl9wb2ludCA9IHBvaW50IHx8IGN1cnZlLmdldFBvaW50QXQocGFyYW1ldGVyLCB0cnVlKTtcblx0XHR0aGlzLl9jdXJ2ZTIgPSBfY3VydmUyO1xuXHRcdHRoaXMuX3BhcmFtZXRlcjIgPSBfcGFyYW1ldGVyMjtcblx0XHR0aGlzLl9wb2ludDIgPSBfcG9pbnQyO1xuXHRcdHRoaXMuX2Rpc3RhbmNlID0gX2Rpc3RhbmNlO1xuXHRcdHRoaXMuX3NlZ21lbnQxID0gY3VydmUuX3NlZ21lbnQxO1xuXHRcdHRoaXMuX3NlZ21lbnQyID0gY3VydmUuX3NlZ21lbnQyO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQ6IGZ1bmN0aW9uKF9wcmVmZXJGaXJzdCkge1xuXHRcdGlmICghdGhpcy5fc2VnbWVudCkge1xuXHRcdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpO1xuXHRcdFx0aWYgKHBhcmFtZXRlciA9PT0gMSkge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50ID0gY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fSBlbHNlIGlmIChwYXJhbWV0ZXIgPT09IDAgfHwgX3ByZWZlckZpcnN0KSB7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHR9IGVsc2UgaWYgKHBhcmFtZXRlciA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudCA9IGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgcGFyYW1ldGVyKVxuXHRcdFx0XHRcdDwgY3VydmUuZ2V0UGFydExlbmd0aChwYXJhbWV0ZXIsIDEpXG5cdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHRcdFx0OiBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50O1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLl9jdXJ2ZSxcblx0XHRcdHBhdGggPSBjdXJ2ZSAmJiBjdXJ2ZS5fcGF0aDtcblx0XHRpZiAocGF0aCAmJiBwYXRoLl92ZXJzaW9uICE9PSB0aGlzLl92ZXJzaW9uKSB7XG5cdFx0XHRjdXJ2ZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9wYXJhbWV0ZXIgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAoIWN1cnZlKSB7XG5cdFx0XHRjdXJ2ZSA9IHRoaXMuX3NlZ21lbnQxLmdldEN1cnZlKCk7XG5cdFx0XHRpZiAoY3VydmUuZ2V0UGFyYW1ldGVyT2YodGhpcy5fcG9pbnQpID09IG51bGwpXG5cdFx0XHRcdGN1cnZlID0gdGhpcy5fc2VnbWVudDIuZ2V0UHJldmlvdXMoKS5nZXRDdXJ2ZSgpO1xuXHRcdFx0dGhpcy5fY3VydmUgPSBjdXJ2ZTtcblx0XHRcdHBhdGggPSBjdXJ2ZS5fcGF0aDtcblx0XHRcdHRoaXMuX3ZlcnNpb24gPSBwYXRoID8gcGF0aC5fdmVyc2lvbiA6IDA7XG5cdFx0fVxuXHRcdHJldHVybiBjdXJ2ZTtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIGN1cnZlICYmIGN1cnZlLl9wYXRoO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIGN1cnZlICYmIGN1cnZlLmdldEluZGV4KCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRwYXJhbWV0ZXIgPSB0aGlzLl9wYXJhbWV0ZXI7XG5cdFx0cmV0dXJuIGN1cnZlICYmIHBhcmFtZXRlciA9PSBudWxsXG5cdFx0XHQ/IHRoaXMuX3BhcmFtZXRlciA9IGN1cnZlLmdldFBhcmFtZXRlck9mKHRoaXMuX3BvaW50KVxuXHRcdFx0OiBwYXJhbWV0ZXI7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKCk7XG5cdFx0cmV0dXJuIHBhdGggPyBwYXRoLl9nZXRPZmZzZXQodGhpcykgOiB0aGlzLmdldEN1cnZlT2Zmc2V0KCk7XG5cdH0sXG5cblx0Z2V0Q3VydmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0cmV0dXJuIHBhcmFtZXRlciAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgcGFyYW1ldGVyKTtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdFx0aWYgKCFpbnRlcnNlY3Rpb24gJiYgdGhpcy5fY3VydmUyKSB7XG5cdFx0XHR0aGlzLl9pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24gPSBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLl9jdXJ2ZTIsXG5cdFx0XHRcdFx0dGhpcy5fcGFyYW1ldGVyMiwgdGhpcy5fcG9pbnQyIHx8IHRoaXMuX3BvaW50LCB0aGlzKTtcblx0XHRcdGludGVyc2VjdGlvbi5faW50ZXJzZWN0aW9uID0gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Rpc3RhbmNlO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5kaXZpZGUodGhpcy5nZXRQYXJhbWV0ZXIoKSwgdHJ1ZSk7XG5cdH0sXG5cblx0c3BsaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuc3BsaXQodGhpcy5nZXRQYXJhbWV0ZXIoKSwgdHJ1ZSk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihsb2MpIHtcblx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAwMTtcblx0XHRyZXR1cm4gdGhpcyA9PT0gbG9jXG5cdFx0XHRcdHx8IGxvYyBpbnN0YW5jZW9mIEN1cnZlTG9jYXRpb25cblx0XHRcdFx0XHQmJiB0aGlzLmdldEN1cnZlKCkgPT09IGxvYy5nZXRDdXJ2ZSgpXG5cdFx0XHRcdFx0JiYgYWJzKHRoaXMuZ2V0UGFyYW1ldGVyKCkgLSBsb2MuZ2V0UGFyYW1ldGVyKCkpIDwgdG9sZXJhbmNlXG5cdFx0XHRcdFx0JiYgdGhpcy5fY3VydmUyID09PSBsb2MuX2N1cnZlMlxuXHRcdFx0XHRcdCYmIGFicyh0aGlzLl9wYXJhbWV0ZXIyIC0gbG9jLl9wYXJhbWV0ZXIyKSA8IHRvbGVyYW5jZVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcnRzID0gW10sXG5cdFx0XHRwb2ludCA9IHRoaXMuZ2V0UG9pbnQoKSxcblx0XHRcdGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0aWYgKHBvaW50KVxuXHRcdFx0cGFydHMucHVzaCgncG9pbnQ6ICcgKyBwb2ludCk7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXHRcdGlmIChpbmRleCAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgnaW5kZXg6ICcgKyBpbmRleCk7XG5cdFx0dmFyIHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0aWYgKHBhcmFtZXRlciAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgncGFyYW1ldGVyOiAnICsgZi5udW1iZXIocGFyYW1ldGVyKSk7XG5cdFx0aWYgKHRoaXMuX2Rpc3RhbmNlICE9IG51bGwpXG5cdFx0XHRwYXJ0cy5wdXNoKCdkaXN0YW5jZTogJyArIGYubnVtYmVyKHRoaXMuX2Rpc3RhbmNlKSk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fVxufSwgQmFzZS5lYWNoKEN1cnZlLmV2YWx1YXRlTWV0aG9kcywgZnVuY3Rpb24obmFtZSkge1xuXHRpZiAobmFtZSAhPT0gJ2dldFBvaW50Jykge1xuXHRcdHZhciBnZXQgPSBuYW1lICsgJ0F0Jztcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKSxcblx0XHRcdFx0Y3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0XHRyZXR1cm4gcGFyYW1ldGVyICE9IG51bGwgJiYgY3VydmUgJiYgY3VydmVbZ2V0XShwYXJhbWV0ZXIsIHRydWUpO1xuXHRcdH07XG5cdH1cbn0sIHt9KSk7XG5cbnZhciBQYXRoSXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aEl0ZW0nLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGhJdGVtKCkge1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKHBhdGgsIF9tYXRyaXgsIF9leHBhbmQpIHtcblx0XHRpZiAodGhpcyA9PT0gcGF0aClcblx0XHRcdHBhdGggPSBudWxsO1xuXHRcdHZhciBsb2NhdGlvbnMgPSBbXSxcblx0XHRcdGN1cnZlczEgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0Y3VydmVzMiA9IHBhdGggPyBwYXRoLmdldEN1cnZlcygpIDogY3VydmVzMSxcblx0XHRcdG1hdHJpeDEgPSB0aGlzLl9tYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpLFxuXHRcdFx0bWF0cml4MiA9IHBhdGggPyAoX21hdHJpeCB8fCBwYXRoLl9tYXRyaXgpLm9yTnVsbElmSWRlbnRpdHkoKVxuXHRcdFx0XHQ6IG1hdHJpeDEsXG5cdFx0XHRsZW5ndGgxID0gY3VydmVzMS5sZW5ndGgsXG5cdFx0XHRsZW5ndGgyID0gcGF0aCA/IGN1cnZlczIubGVuZ3RoIDogbGVuZ3RoMSxcblx0XHRcdHZhbHVlczIgPSBbXSxcblx0XHRcdHRNaW4gPSAwLjAwMDAwMSxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRpZiAocGF0aCAmJiAhdGhpcy5nZXRCb3VuZHMobWF0cml4MSkudG91Y2hlcyhwYXRoLmdldEJvdW5kcyhtYXRyaXgyKSkpXG5cdFx0XHRyZXR1cm4gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspXG5cdFx0XHR2YWx1ZXMyW2ldID0gY3VydmVzMltpXS5nZXRWYWx1ZXMobWF0cml4Mik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZTEgPSBjdXJ2ZXMxW2ldLFxuXHRcdFx0XHR2YWx1ZXMxID0gcGF0aCA/IGN1cnZlMS5nZXRWYWx1ZXMobWF0cml4MSkgOiB2YWx1ZXMyW2ldO1xuXHRcdFx0aWYgKCFwYXRoKSB7XG5cdFx0XHRcdHZhciBzZWcxID0gY3VydmUxLmdldFNlZ21lbnQxKCksXG5cdFx0XHRcdFx0c2VnMiA9IGN1cnZlMS5nZXRTZWdtZW50MigpLFxuXHRcdFx0XHRcdGgxID0gc2VnMS5faGFuZGxlT3V0LFxuXHRcdFx0XHRcdGgyID0gc2VnMi5faGFuZGxlSW47XG5cdFx0XHRcdGlmIChuZXcgTGluZShzZWcxLl9wb2ludC5zdWJ0cmFjdChoMSksIGgxLm11bHRpcGx5KDIpLCB0cnVlKVxuXHRcdFx0XHRcdFx0LmludGVyc2VjdChuZXcgTGluZShzZWcyLl9wb2ludC5zdWJ0cmFjdChoMiksXG5cdFx0XHRcdFx0XHRoMi5tdWx0aXBseSgyKSwgdHJ1ZSksIGZhbHNlKSkge1xuXHRcdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2YWx1ZXMxKTtcblx0XHRcdFx0XHRDdXJ2ZS5nZXRJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0cGFydHNbMF0sIHBhcnRzWzFdLCBjdXJ2ZTEsIGN1cnZlMSwgbG9jYXRpb25zLFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24obG9jKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChsb2MuX3BhcmFtZXRlciA8PSB0TWF4KSB7XG5cdFx0XHRcdFx0XHRcdFx0bG9jLl9wYXJhbWV0ZXIgLz0gMjtcblx0XHRcdFx0XHRcdFx0XHRsb2MuX3BhcmFtZXRlcjIgPSAwLjUgKyBsb2MuX3BhcmFtZXRlcjIgLyAyO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaiA9IHBhdGggPyAwIDogaSArIDE7IGogPCBsZW5ndGgyOyBqKyspIHtcblx0XHRcdFx0Q3VydmUuZ2V0SW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHR2YWx1ZXMxLCB2YWx1ZXMyW2pdLCBjdXJ2ZTEsIGN1cnZlczJbal0sIGxvY2F0aW9ucyxcblx0XHRcdFx0XHQhcGF0aCAmJiAoaiA9PT0gaSArIDEgfHwgaiA9PT0gbGVuZ3RoMiAtIDEgJiYgaSA9PT0gMClcblx0XHRcdFx0XHRcdCYmIGZ1bmN0aW9uKGxvYykge1xuXHRcdFx0XHRcdFx0XHR2YXIgdCA9IGxvYy5fcGFyYW1ldGVyO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdCA+PSB0TWluICYmIHQgPD0gdE1heDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIEN1cnZlLmZpbHRlckludGVyc2VjdGlvbnMobG9jYXRpb25zLCBfZXhwYW5kKTtcblx0fSxcblxuXHRfYXNQYXRoSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2V0UGF0aERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblxuXHRcdHZhciBwYXJ0cyA9IGRhdGEubWF0Y2goL1ttbGh2Y3NxdGF6XVtebWxodmNzcXRhel0qL2lnKSxcblx0XHRcdGNvb3Jkcyxcblx0XHRcdHJlbGF0aXZlID0gZmFsc2UsXG5cdFx0XHRwcmV2aW91cyxcblx0XHRcdGNvbnRyb2wsXG5cdFx0XHRjdXJyZW50ID0gbmV3IFBvaW50KCksXG5cdFx0XHRzdGFydCA9IG5ldyBQb2ludCgpO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29vcmQoaW5kZXgsIGNvb3JkKSB7XG5cdFx0XHR2YXIgdmFsID0gK2Nvb3Jkc1tpbmRleF07XG5cdFx0XHRpZiAocmVsYXRpdmUpXG5cdFx0XHRcdHZhbCArPSBjdXJyZW50W2Nvb3JkXTtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UG9pbnQoaW5kZXgpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdGdldENvb3JkKGluZGV4LCAneCcpLFxuXHRcdFx0XHRnZXRDb29yZChpbmRleCArIDEsICd5Jylcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jbGVhcigpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gcGFydHNbaV0sXG5cdFx0XHRcdGNvbW1hbmQgPSBwYXJ0WzBdLFxuXHRcdFx0XHRsb3dlciA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvb3JkcyA9IHBhcnQubWF0Y2goL1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoO1xuXHRcdFx0cmVsYXRpdmUgPSBjb21tYW5kID09PSBsb3dlcjtcblx0XHRcdGlmIChwcmV2aW91cyA9PT0gJ3onICYmICEvW216XS8udGVzdChsb3dlcikpXG5cdFx0XHRcdHRoaXMubW92ZVRvKGN1cnJlbnQgPSBzdGFydCk7XG5cdFx0XHRzd2l0Y2ggKGxvd2VyKSB7XG5cdFx0XHRjYXNlICdtJzpcblx0XHRcdGNhc2UgJ2wnOlxuXHRcdFx0XHR2YXIgbW92ZSA9IGxvd2VyID09PSAnbSc7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDIpXG5cdFx0XHRcdFx0dGhpc1tqID09PSAwICYmIG1vdmUgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGlmIChtb3ZlKVxuXHRcdFx0XHRcdHN0YXJ0ID0gY3VycmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdoJzpcblx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHR2YXIgY29vcmQgPSBsb3dlciA9PT0gJ2gnID8gJ3gnIDogJ3knO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0Y3VycmVudFtjb29yZF0gPSBnZXRDb29yZChqLCBjb29yZCk7XG5cdFx0XHRcdFx0dGhpcy5saW5lVG8oY3VycmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDYpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Z2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqICsgMiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgNCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0L1tjc10vLnRlc3QocHJldmlvdXMpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbClcblx0XHRcdFx0XHRcdFx0XHRcdDogY3VycmVudCxcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0Jzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMikge1xuXHRcdFx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9ICgvW3F0XS8udGVzdChwcmV2aW91cylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBjdXJyZW50KSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDcpIHtcblx0XHRcdFx0XHR0aGlzLmFyY1RvKGN1cnJlbnQgPSBnZXRQb2ludChqICsgNSksXG5cdFx0XHRcdFx0XHRcdG5ldyBTaXplKCtjb29yZHNbal0sICtjb29yZHNbaiArIDFdKSxcblx0XHRcdFx0XHRcdFx0K2Nvb3Jkc1tqICsgMl0sICtjb29yZHNbaiArIDRdLCArY29vcmRzW2ogKyAzXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd6Jzpcblx0XHRcdFx0dGhpcy5jbG9zZVBhdGgodHJ1ZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciB3aW5kaW5nID0gdGhpcy5fZ2V0V2luZGluZyhwb2ludCwgZmFsc2UsIHRydWUpO1xuXHRcdHJldHVybiAhISh0aGlzLmdldFdpbmRpbmdSdWxlKCkgPT09ICdldmVub2RkJyA/IHdpbmRpbmcgJiAxIDogd2luZGluZyk7XG5cdH1cblxufSk7XG5cbnZhciBQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aCcsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzZWdtZW50czogW10sXG5cdFx0Y2xvc2VkOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGgoYXJnKSB7XG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fc2VnbWVudHMgPSBbXTtcblx0XHR0aGlzLl92ZXJzaW9uID0gMDtcblx0XHR2YXIgc2VnbWVudHMgPSBBcnJheS5pc0FycmF5KGFyZylcblx0XHRcdD8gdHlwZW9mIGFyZ1swXSA9PT0gJ29iamVjdCdcblx0XHRcdFx0PyBhcmdcblx0XHRcdFx0OiBhcmd1bWVudHNcblx0XHRcdDogYXJnICYmIChhcmcuc2l6ZSA9PT0gdW5kZWZpbmVkICYmIChhcmcueCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0fHwgYXJnLnBvaW50ICE9PSB1bmRlZmluZWQpKVxuXHRcdFx0XHQ/IGFyZ3VtZW50c1xuXHRcdFx0XHQ6IG51bGw7XG5cdFx0aWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA9IDA7XG5cdFx0XHRpZiAoIXNlZ21lbnRzICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdFx0YXJnID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5faW5pdGlhbGl6ZSghc2VnbWVudHMgJiYgYXJnKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZCA9PT0gaXRlbS5fY2xvc2VkXG5cdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3NlZ21lbnRzLCBpdGVtLl9zZWdtZW50cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0U2VnbWVudHModGhpcy5fc2VnbWVudHMpO1xuXHRcdGNvcHkuX2Nsb3NlZCA9IHRoaXMuX2Nsb3NlZDtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRjb3B5Ll9jbG9ja3dpc2UgPSB0aGlzLl9jbG9ja3dpc2U7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdFx0aWYgKHBhcmVudClcblx0XHRcdFx0cGFyZW50Ll9jdXJyZW50UGF0aCA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2Nsb2Nrd2lzZSA9IHVuZGVmaW5lZDtcblx0XHRcdGlmIChmbGFncyAmIDE2KSB7XG5cdFx0XHRcdHRoaXMuX3ZlcnNpb24rKztcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fY3VydmVzKSB7XG5cdFx0XHQgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2N1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2ldLl9jaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9tb25vQ3VydmVzID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoZmxhZ3MgJiAzMikge1xuXHRcdFx0dGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRyZXR1cm4gKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCA/IHBhcmVudCA6IHRoaXMpLl9zdHlsZTtcblx0fSxcblxuXHRnZXRTZWdtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzO1xuXHR9LFxuXG5cdHNldFNlZ21lbnRzOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHZhciBmdWxseVNlbGVjdGVkID0gdGhpcy5pc0Z1bGx5U2VsZWN0ZWQoKTtcblx0XHR0aGlzLl9zZWdtZW50cy5sZW5ndGggPSAwO1xuXHRcdHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlID0gMDtcblx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApXG5cdFx0XHR0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSk7XG5cdFx0aWYgKGZ1bGx5U2VsZWN0ZWQpXG5cdFx0XHR0aGlzLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNbMF07XG5cdH0sXG5cblx0Z2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50c1t0aGlzLl9zZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGlmICghY3VydmVzKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY291bnRDdXJ2ZXMoKTtcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdFx0Y3VydmVzW2ldID0gbmV3IEN1cnZlKHRoaXMsIHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRcdHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXSk7XG5cdFx0fVxuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q3VydmVzKClbMF07XG5cdH0sXG5cblx0Z2V0TGFzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRyZXR1cm4gY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRpc0Nsb3NlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZDtcblx0fSxcblxuXHRzZXRDbG9zZWQ6IGZ1bmN0aW9uKGNsb3NlZCkge1xuXHRcdGlmICh0aGlzLl9jbG9zZWQgIT0gKGNsb3NlZCA9ICEhY2xvc2VkKSkge1xuXHRcdFx0dGhpcy5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdFx0aWYgKHRoaXMuX2N1cnZlcykge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY3VydmVzLmxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cdFx0XHRcdGlmIChjbG9zZWQpXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2xlbmd0aCAtIDFdID0gbmV3IEN1cnZlKHRoaXMsXG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50c1tsZW5ndGggLSAxXSwgdGhpcy5fc2VnbWVudHNbMF0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0fVxuXHR9XG59LCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldFBhdGhEYXRhOiBmdW5jdGlvbihfbWF0cml4LCBfcHJlY2lzaW9uKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRmID0gbmV3IEZvcm1hdHRlcihfcHJlY2lzaW9uKSxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdGZpcnN0ID0gdHJ1ZSxcblx0XHRcdGN1clgsIGN1clksXG5cdFx0XHRwcmV2WCwgcHJldlksXG5cdFx0XHRpblgsIGluWSxcblx0XHRcdG91dFgsIG91dFksXG5cdFx0XHRwYXJ0cyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkU2VnbWVudChzZWdtZW50LCBza2lwTGluZSkge1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoX21hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0Y3VyWSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKCdNJyArIGYucGFpcihjdXJYLCBjdXJZKSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0aWYgKCFza2lwTGluZSlcblx0XHRcdFx0XHRcdHBhcnRzLnB1c2goJ2wnICsgZi5wYWlyKGN1clggLSBwcmV2WCwgY3VyWSAtIHByZXZZKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFydHMucHVzaCgnYycgKyBmLnBhaXIob3V0WCAtIHByZXZYLCBvdXRZIC0gcHJldlkpXG5cdFx0XHRcdFx0XHRcdCsgJyAnICsgZi5wYWlyKGluWCAtIHByZXZYLCBpblkgLSBwcmV2WSlcblx0XHRcdFx0XHRcdFx0KyAnICcgKyBmLnBhaXIoY3VyWCAtIHByZXZYLCBjdXJZIC0gcHJldlkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHJldlggPSBjdXJYO1xuXHRcdFx0cHJldlkgPSBjdXJZO1xuXHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdG91dFkgPSBjb29yZHNbNV07XG5cdFx0fVxuXG5cdFx0aWYgKGxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiAnJztcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRhZGRTZWdtZW50KHNlZ21lbnRzW2ldKTtcblx0XHRpZiAodGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDApIHtcblx0XHRcdGFkZFNlZ21lbnQoc2VnbWVudHNbMF0sIHRydWUpO1xuXHRcdFx0cGFydHMucHVzaCgneicpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFydHMuam9pbignJyk7XG5cdH1cbn0sIHtcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHMubGVuZ3RoID09PSAwO1xuXHR9LFxuXG5cdGlzTGluZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKCFzZWdtZW50c1tpXS5pc0xpbmVhcigpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoc2VnbWVudHNbaV0uaGFzSGFuZGxlcygpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db250ZW50OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0dGhpcy5fc2VnbWVudHNbaV0uX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCB0cnVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfYWRkOiBmdW5jdGlvbihzZWdzLCBpbmRleCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0YW1vdW50ID0gc2Vncy5sZW5ndGgsXG5cdFx0XHRhcHBlbmQgPSBpbmRleCA9PSBudWxsLFxuXHRcdFx0aW5kZXggPSBhcHBlbmQgPyBzZWdtZW50cy5sZW5ndGggOiBpbmRleDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ3NbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fcGF0aClcblx0XHRcdFx0c2VnbWVudCA9IHNlZ3NbaV0gPSBzZWdtZW50LmNsb25lKCk7XG5cdFx0XHRzZWdtZW50Ll9wYXRoID0gdGhpcztcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gaW5kZXggKyBpO1xuXHRcdFx0aWYgKHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlKVxuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgMCwgc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUpO1xuXHRcdH1cblx0XHRpZiAoYXBwZW5kKSB7XG5cdFx0XHRzZWdtZW50cy5wdXNoLmFwcGx5KHNlZ21lbnRzLCBzZWdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2VnbWVudHMuc3BsaWNlLmFwcGx5KHNlZ21lbnRzLCBbaW5kZXgsIDBdLmNvbmNhdChzZWdzKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZXMgfHwgc2Vncy5fY3VydmVzKSB7XG5cdFx0XHRpZiAoIWN1cnZlcylcblx0XHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzID0gW107XG5cdFx0XHR2YXIgZnJvbSA9IGluZGV4ID4gMCA/IGluZGV4IC0gMSA6IGluZGV4LFxuXHRcdFx0XHRzdGFydCA9IGZyb20sXG5cdFx0XHRcdHRvID0gTWF0aC5taW4oZnJvbSArIGFtb3VudCwgdGhpcy5fY291bnRDdXJ2ZXMoKSk7XG5cdFx0XHRpZiAoc2Vncy5fY3VydmVzKSB7XG5cdFx0XHRcdGN1cnZlcy5zcGxpY2UuYXBwbHkoY3VydmVzLCBbZnJvbSwgMF0uY29uY2F0KHNlZ3MuX2N1cnZlcykpO1xuXHRcdFx0XHRzdGFydCArPSBzZWdzLl9jdXJ2ZXMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgdG87IGkrKylcblx0XHRcdFx0Y3VydmVzLnNwbGljZShpLCAwLCBuZXcgQ3VydmUodGhpcywgbnVsbCwgbnVsbCkpO1xuXHRcdFx0dGhpcy5fYWRqdXN0Q3VydmVzKGZyb20sIHRvKTtcblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblx0X2FkanVzdEN1cnZlczogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGN1cnZlO1xuXHRcdGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuXHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRjdXJ2ZS5fcGF0aCA9IHRoaXM7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1tpXTtcblx0XHRcdGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZSA9IGN1cnZlc1t0aGlzLl9jbG9zZWQgJiYgZnJvbSA9PT0gMCA/IHNlZ21lbnRzLmxlbmd0aCAtIDFcblx0XHRcdFx0OiBmcm9tIC0gMV0pIHtcblx0XHRcdGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW2Zyb21dIHx8IHNlZ21lbnRzWzBdO1xuXHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0aWYgKGN1cnZlID0gY3VydmVzW3RvXSkge1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQxID0gc2VnbWVudHNbdG9dO1xuXHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NvdW50Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHJldHVybiAhdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDAgPyBsZW5ndGggLSAxIDogbGVuZ3RoO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oc2VnbWVudDEgKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcidcblx0XHRcdD8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChhcmd1bWVudHMpKVxuXHRcdFx0OiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzKSBdKVswXTtcblx0fSxcblxuXHRpbnNlcnQ6IGZ1bmN0aW9uKGluZGV4LCBzZWdtZW50MSApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdHlwZW9mIHNlZ21lbnQxICE9PSAnbnVtYmVyJ1xuXHRcdFx0PyB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKGFyZ3VtZW50cywgMSksIGluZGV4KVxuXHRcdFx0OiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzLCAxKSBdLCBpbmRleClbMF07XG5cdH0sXG5cblx0YWRkU2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMpIF0pWzBdO1xuXHR9LFxuXG5cdGluc2VydFNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4ICkge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzLCAxKSBdLCBpbmRleClbMF07XG5cdH0sXG5cblx0YWRkU2VnbWVudHM6IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoc2VnbWVudHMpKTtcblx0fSxcblxuXHRpbnNlcnRTZWdtZW50czogZnVuY3Rpb24oaW5kZXgsIHNlZ21lbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoc2VnbWVudHMpLCBpbmRleCk7XG5cdH0sXG5cblx0cmVtb3ZlU2VnbWVudDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVTZWdtZW50cyhpbmRleCwgaW5kZXggKyAxKVswXSB8fCBudWxsO1xuXHR9LFxuXG5cdHJlbW92ZVNlZ21lbnRzOiBmdW5jdGlvbihmcm9tLCB0bywgX2luY2x1ZGVDdXJ2ZXMpIHtcblx0XHRmcm9tID0gZnJvbSB8fCAwO1xuXHRcdHRvID0gQmFzZS5waWNrKHRvLCB0aGlzLl9zZWdtZW50cy5sZW5ndGgpO1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0Y291bnQgPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRyZW1vdmVkID0gc2VnbWVudHMuc3BsaWNlKGZyb20sIHRvIC0gZnJvbSksXG5cdFx0XHRhbW91bnQgPSByZW1vdmVkLmxlbmd0aDtcblx0XHRpZiAoIWFtb3VudClcblx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gcmVtb3ZlZFtpXTtcblx0XHRcdGlmIChzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSlcblx0XHRcdFx0dGhpcy5fdXBkYXRlU2VsZWN0aW9uKHNlZ21lbnQsIHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlLCAwKTtcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gc2VnbWVudC5fcGF0aCA9IG51bGw7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSBmcm9tLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c2VnbWVudHNbaV0uX2luZGV4ID0gaTtcblx0XHRpZiAoY3VydmVzKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBmcm9tID4gMCAmJiB0byA9PT0gY291bnQgKyAodGhpcy5fY2xvc2VkID8gMSA6IDApXG5cdFx0XHRcdFx0PyBmcm9tIC0gMVxuXHRcdFx0XHRcdDogZnJvbSxcblx0XHRcdFx0Y3VydmVzID0gY3VydmVzLnNwbGljZShpbmRleCwgYW1vdW50KTtcblx0XHRcdGlmIChfaW5jbHVkZUN1cnZlcylcblx0XHRcdFx0cmVtb3ZlZC5fY3VydmVzID0gY3VydmVzLnNsaWNlKDEpO1xuXHRcdFx0dGhpcy5fYWRqdXN0Q3VydmVzKGluZGV4LCBpbmRleCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoMjUpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZVNlZ21lbnRzJyxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbCkge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0XHR0aGlzLl9sZW5ndGggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLl9sZW5ndGggKz0gY3VydmVzW2ldLmdldExlbmd0aCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbGVuZ3RoO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdHZhciBhcmVhID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRhcmVhICs9IGN1cnZlc1tpXS5nZXRBcmVhKCk7XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH0sXG5cblx0aXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZCAmJiBsZW5ndGggPiAwICYmIHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlXG5cdFx0XHRcdD09PSBsZW5ndGggKiA3O1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0aWYgKHNlbGVjdGVkKVxuXHRcdFx0dGhpcy5fc2VsZWN0U2VnbWVudHModHJ1ZSk7XG5cdFx0dGhpcy5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIHNldFNlbGVjdGVkKHNlbGVjdGVkKSB7XG5cdFx0aWYgKCFzZWxlY3RlZClcblx0XHRcdHRoaXMuX3NlbGVjdFNlZ21lbnRzKGZhbHNlKTtcblx0XHRzZXRTZWxlY3RlZC5iYXNlLmNhbGwodGhpcywgc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdF9zZWxlY3RTZWdtZW50czogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlID0gc2VsZWN0ZWRcblx0XHRcdFx0PyBsZW5ndGggKiA3IDogMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0dGhpcy5fc2VnbWVudHNbaV0uX3NlbGVjdGlvblN0YXRlID0gc2VsZWN0ZWRcblx0XHRcdFx0XHQ/IDcgOiAwO1xuXHR9LFxuXG5cdF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uKHNlZ21lbnQsIG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuXHRcdHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlID0gbmV3U3RhdGU7XG5cdFx0dmFyIHRvdGFsID0gdGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgKz0gbmV3U3RhdGUgLSBvbGRTdGF0ZTtcblx0XHRpZiAodG90YWwgPiAwKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRmbGF0dGVuOiBmdW5jdGlvbihtYXhEaXN0YW5jZSkge1xuXHRcdHZhciBpdGVyYXRvciA9IG5ldyBQYXRoSXRlcmF0b3IodGhpcywgNjQsIDAuMSksXG5cdFx0XHRwb3MgPSAwLFxuXHRcdFx0c3RlcCA9IGl0ZXJhdG9yLmxlbmd0aCAvIE1hdGguY2VpbChpdGVyYXRvci5sZW5ndGggLyBtYXhEaXN0YW5jZSksXG5cdFx0XHRlbmQgPSBpdGVyYXRvci5sZW5ndGggKyAodGhpcy5fY2xvc2VkID8gLXN0ZXAgOiBzdGVwKSAvIDI7XG5cdFx0dmFyIHNlZ21lbnRzID0gW107XG5cdFx0d2hpbGUgKHBvcyA8PSBlbmQpIHtcblx0XHRcdHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQoaXRlcmF0b3IuZ2V0UG9pbnRBdChwb3MpKSk7XG5cdFx0XHRwb3MgKz0gc3RlcDtcblx0XHR9XG5cdFx0dGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG5cdH0sXG5cblx0cmVkdWNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRpZiAoY3VydmUuaXNMaW5lYXIoKSAmJiBjdXJ2ZS5nZXRMZW5ndGgoKSA9PT0gMClcblx0XHRcdFx0Y3VydmUucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNpbXBsaWZ5OiBmdW5jdGlvbih0b2xlcmFuY2UpIHtcblx0XHRpZiAodGhpcy5fc2VnbWVudHMubGVuZ3RoID4gMikge1xuXHRcdFx0dmFyIGZpdHRlciA9IG5ldyBQYXRoRml0dGVyKHRoaXMsIHRvbGVyYW5jZSB8fCAyLjUpO1xuXHRcdFx0dGhpcy5zZXRTZWdtZW50cyhmaXR0ZXIuZml0KCkpO1xuXHRcdH1cblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oaW5kZXgsIHBhcmFtZXRlcikge1xuXHRcdGlmIChwYXJhbWV0ZXIgPT09IG51bGwpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dmFyIGFyZyA9IGluZGV4O1xuXHRcdFx0aWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKVxuXHRcdFx0XHRhcmcgPSB0aGlzLmdldExvY2F0aW9uQXQoYXJnKTtcblx0XHRcdGlmICghYXJnKVxuXHRcdFx0XHRyZXR1cm4gbnVsbFxuXHRcdFx0aW5kZXggPSBhcmcuaW5kZXg7XG5cdFx0XHRwYXJhbWV0ZXIgPSBhcmcucGFyYW1ldGVyO1xuXHRcdH1cblx0XHR2YXIgdG9sZXJhbmNlID0gMC4wMDAwMDE7XG5cdFx0aWYgKHBhcmFtZXRlciA+PSAxIC0gdG9sZXJhbmNlKSB7XG5cdFx0XHRpbmRleCsrO1xuXHRcdFx0cGFyYW1ldGVyLS07XG5cdFx0fVxuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgY3VydmVzLmxlbmd0aCkge1xuXHRcdFx0aWYgKHBhcmFtZXRlciA+IHRvbGVyYW5jZSkge1xuXHRcdFx0XHRjdXJ2ZXNbaW5kZXgrK10uZGl2aWRlKHBhcmFtZXRlciwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc2VncyA9IHRoaXMucmVtb3ZlU2VnbWVudHMoaW5kZXgsIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCwgdHJ1ZSksXG5cdFx0XHRcdHBhdGg7XG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q2xvc2VkKGZhbHNlKTtcblx0XHRcdFx0cGF0aCA9IHRoaXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoID0gdGhpcy5fY2xvbmUobmV3IFBhdGgoKS5pbnNlcnRBYm92ZSh0aGlzLCB0cnVlKSk7XG5cdFx0XHR9XG5cdFx0XHRwYXRoLl9hZGQoc2VncywgMCk7XG5cdFx0XHR0aGlzLmFkZFNlZ21lbnQoc2Vnc1swXSk7XG5cdFx0XHRyZXR1cm4gcGF0aDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0aXNDbG9ja3dpc2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jbG9ja3dpc2UgIT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiB0aGlzLl9jbG9ja3dpc2U7XG5cdFx0cmV0dXJuIFBhdGguaXNDbG9ja3dpc2UodGhpcy5fc2VnbWVudHMpO1xuXHR9LFxuXG5cdHNldENsb2Nrd2lzZTogZnVuY3Rpb24oY2xvY2t3aXNlKSB7XG5cdFx0aWYgKHRoaXMuaXNDbG9ja3dpc2UoKSAhPSAoY2xvY2t3aXNlID0gISFjbG9ja3dpc2UpKVxuXHRcdFx0dGhpcy5yZXZlcnNlKCk7XG5cdFx0dGhpcy5fY2xvY2t3aXNlID0gY2xvY2t3aXNlO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnRzLnJldmVyc2UoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdHZhciBoYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZUluO1xuXHRcdFx0c2VnbWVudC5faGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRzZWdtZW50Ll9oYW5kbGVPdXQgPSBoYW5kbGVJbjtcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gaTtcblx0XHR9XG5cdFx0dGhpcy5fY3VydmVzID0gbnVsbDtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHR0aGlzLl9jbG9ja3dpc2UgPSAhdGhpcy5fY2xvY2t3aXNlO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0am9pbjogZnVuY3Rpb24ocGF0aCkge1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdFx0bGFzdDEgPSB0aGlzLmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKCFsYXN0Milcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRpZiAobGFzdDEgJiYgbGFzdDEuX3BvaW50LmVxdWFscyhsYXN0Mi5fcG9pbnQpKVxuXHRcdFx0XHRwYXRoLnJldmVyc2UoKTtcblx0XHRcdHZhciBmaXJzdDIgPSBwYXRoLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKGxhc3QxICYmIGxhc3QxLl9wb2ludC5lcXVhbHMoZmlyc3QyLl9wb2ludCkpIHtcblx0XHRcdFx0bGFzdDEuc2V0SGFuZGxlT3V0KGZpcnN0Mi5faGFuZGxlT3V0KTtcblx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDEpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBmaXJzdDEgPSB0aGlzLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0XHRpZiAoZmlyc3QxICYmIGZpcnN0MS5fcG9pbnQuZXF1YWxzKGZpcnN0Mi5fcG9pbnQpKVxuXHRcdFx0XHRcdHBhdGgucmV2ZXJzZSgpO1xuXHRcdFx0XHRsYXN0MiA9IHBhdGguZ2V0TGFzdFNlZ21lbnQoKTtcblx0XHRcdFx0aWYgKGZpcnN0MSAmJiBmaXJzdDEuX3BvaW50LmVxdWFscyhsYXN0Mi5fcG9pbnQpKSB7XG5cdFx0XHRcdFx0Zmlyc3QxLnNldEhhbmRsZUluKGxhc3QyLl9oYW5kbGVJbik7XG5cdFx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDAsIHNlZ21lbnRzLmxlbmd0aCAtIDEpLCAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwYXRoLmNsb3NlZClcblx0XHRcdFx0dGhpcy5fYWRkKFtzZWdtZW50c1swXV0pO1xuXHRcdFx0cGF0aC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKSxcblx0XHRcdGxhc3QgPSB0aGlzLmdldExhc3RTZWdtZW50KCk7XG5cdFx0aWYgKGZpcnN0ICE9PSBsYXN0ICYmIGZpcnN0Ll9wb2ludC5lcXVhbHMobGFzdC5fcG9pbnQpKSB7XG5cdFx0XHRmaXJzdC5zZXRIYW5kbGVJbihsYXN0Ll9oYW5kbGVJbik7XG5cdFx0XHRsYXN0LnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvU2hhcGU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdGlmICghdGhpcy5fY2xvc2VkKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdHR5cGUsXG5cdFx0XHRzaXplLFxuXHRcdFx0cmFkaXVzLFxuXHRcdFx0dG9wQ2VudGVyO1xuXG5cdFx0ZnVuY3Rpb24gaXNDb2xsaW5lYXIoaSwgaikge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLmlzQ29sbGluZWFyKHNlZ21lbnRzW2pdKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc09ydGhvZ29uYWwoaSkge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLmlzT3J0aG9nb25hbCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQXJjKGkpIHtcblx0XHRcdHJldHVybiBzZWdtZW50c1tpXS5pc09ydGhvZ29uYWxBcmMoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXREaXN0YW5jZShpLCBqKSB7XG5cdFx0XHRyZXR1cm4gc2VnbWVudHNbaV0uX3BvaW50LmdldERpc3RhbmNlKHNlZ21lbnRzW2pdLl9wb2ludCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmhhc0hhbmRsZXMoKSAmJiBzZWdtZW50cy5sZW5ndGggPT09IDRcblx0XHRcdFx0JiYgaXNDb2xsaW5lYXIoMCwgMikgJiYgaXNDb2xsaW5lYXIoMSwgMykgJiYgaXNPcnRob2dvbmFsKDEpKSB7XG5cdFx0XHR0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDMpLCBnZXREaXN0YW5jZSgwLCAxKSk7XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQuYWRkKHNlZ21lbnRzWzJdLl9wb2ludCkuZGl2aWRlKDIpO1xuXHRcdH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA4ICYmIGlzQXJjKDApICYmIGlzQXJjKDIpICYmIGlzQXJjKDQpXG5cdFx0XHRcdCYmIGlzQXJjKDYpICYmIGlzQ29sbGluZWFyKDEsIDUpICYmIGlzQ29sbGluZWFyKDMsIDcpKSB7XG5cdFx0XHR0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDEsIDYpLCBnZXREaXN0YW5jZSgwLCAzKSk7XG5cdFx0XHRyYWRpdXMgPSBzaXplLnN1YnRyYWN0KG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDcpLFxuXHRcdFx0XHRcdGdldERpc3RhbmNlKDEsIDIpKSkuZGl2aWRlKDIpO1xuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbM10uX3BvaW50LmFkZChzZWdtZW50c1s0XS5fcG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gNFxuXHRcdFx0XHQmJiBpc0FyYygwKSAmJiBpc0FyYygxKSAmJiBpc0FyYygyKSAmJiBpc0FyYygzKSkge1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oZ2V0RGlzdGFuY2UoMCwgMikgLSBnZXREaXN0YW5jZSgxLCAzKSkpIHtcblx0XHRcdFx0dHlwZSA9IFNoYXBlLkNpcmNsZTtcblx0XHRcdFx0cmFkaXVzID0gZ2V0RGlzdGFuY2UoMCwgMikgLyAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZSA9IFNoYXBlLkVsbGlwc2U7XG5cdFx0XHRcdHJhZGl1cyA9IG5ldyBTaXplKGdldERpc3RhbmNlKDIsIDApIC8gMiwgZ2V0RGlzdGFuY2UoMywgMSkgLyAyKTtcblx0XHRcdH1cblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludDtcblx0XHR9XG5cblx0XHRpZiAodHlwZSkge1xuXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksXG5cdFx0XHRcdHNoYXBlID0gdGhpcy5fY2xvbmUobmV3IHR5cGUoe1xuXHRcdFx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdFx0aW5zZXJ0OiBmYWxzZVxuXHRcdFx0XHR9KSwgaW5zZXJ0LCBmYWxzZSk7XG5cdFx0XHRzaGFwZS5yb3RhdGUodG9wQ2VudGVyLnN1YnRyYWN0KGNlbnRlcikuZ2V0QW5nbGUoKSArIDkwKTtcblx0XHRcdHJldHVybiBzaGFwZTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0Y2xvc2VkID0gdGhpcy5fY2xvc2VkLFxuXHRcdFx0dG9sZXJhbmNlUGFkZGluZyA9IG9wdGlvbnMuX3RvbGVyYW5jZVBhZGRpbmcsXG5cdFx0XHRzdHJva2VQYWRkaW5nID0gdG9sZXJhbmNlUGFkZGluZyxcblx0XHRcdGpvaW4sIGNhcCwgbWl0ZXJMaW1pdCxcblx0XHRcdGFyZWEsIGxvYywgcmVzLFxuXHRcdFx0aGl0U3Ryb2tlID0gb3B0aW9ucy5zdHJva2UgJiYgc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRoaXRGaWxsID0gb3B0aW9ucy5maWxsICYmIHN0eWxlLmhhc0ZpbGwoKSxcblx0XHRcdGhpdEN1cnZlcyA9IG9wdGlvbnMuY3VydmVzLFxuXHRcdFx0cmFkaXVzID0gaGl0U3Ryb2tlXG5cdFx0XHRcdFx0PyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMlxuXHRcdFx0XHRcdDogaGl0RmlsbCAmJiBvcHRpb25zLnRvbGVyYW5jZSA+IDAgfHwgaGl0Q3VydmVzXG5cdFx0XHRcdFx0XHQ/IDAgOiBudWxsO1xuXHRcdGlmIChyYWRpdXMgIT09IG51bGwpIHtcblx0XHRcdGlmIChyYWRpdXMgPiAwKSB7XG5cdFx0XHRcdGpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCk7XG5cdFx0XHRcdGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpO1xuXHRcdFx0XHRtaXRlckxpbWl0ID0gcmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0XHRzdHJva2VQYWRkaW5nID0gdG9sZXJhbmNlUGFkZGluZy5hZGQobmV3IFBvaW50KHJhZGl1cywgcmFkaXVzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqb2luID0gY2FwID0gJ3JvdW5kJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0Nsb3NlRW5vdWdoKHB0LCBwYWRkaW5nKSB7XG5cdFx0XHRyZXR1cm4gcG9pbnQuc3VidHJhY3QocHQpLmRpdmlkZShwYWRkaW5nKS5sZW5ndGggPD0gMTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRQb2ludChzZWcsIHB0LCBuYW1lKSB7XG5cdFx0XHRpZiAoIW9wdGlvbnMuc2VsZWN0ZWQgfHwgcHQuaXNTZWxlY3RlZCgpKSB7XG5cdFx0XHRcdHZhciBhbmNob3IgPSBzZWcuX3BvaW50O1xuXHRcdFx0XHRpZiAocHQgIT09IGFuY2hvcilcblx0XHRcdFx0XHRwdCA9IHB0LmFkZChhbmNob3IpO1xuXHRcdFx0XHRpZiAoaXNDbG9zZUVub3VnaChwdCwgc3Ryb2tlUGFkZGluZykpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdChuYW1lLCB0aGF0LCB7XG5cdFx0XHRcdFx0XHRzZWdtZW50OiBzZWcsXG5cdFx0XHRcdFx0XHRwb2ludDogcHRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFBvaW50cyhzZWcsIGVuZHMpIHtcblx0XHRcdHJldHVybiAoZW5kcyB8fCBvcHRpb25zLnNlZ21lbnRzKVxuXHRcdFx0XHQmJiBjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5fcG9pbnQsICdzZWdtZW50Jylcblx0XHRcdFx0fHwgKCFlbmRzICYmIG9wdGlvbnMuaGFuZGxlcykgJiYgKFxuXHRcdFx0XHRcdGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9oYW5kbGVJbiwgJ2hhbmRsZS1pbicpIHx8XG5cdFx0XHRcdFx0Y2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX2hhbmRsZU91dCwgJ2hhbmRsZS1vdXQnKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkVG9BcmVhKHBvaW50KSB7XG5cdFx0XHRhcmVhLmFkZChwb2ludCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50U3Ryb2tlKHNlZ21lbnQpIHtcblx0XHRcdGlmIChqb2luICE9PSAncm91bmQnIHx8IGNhcCAhPT0gJ3JvdW5kJykge1xuXHRcdFx0XHRhcmVhID0gbmV3IFBhdGgoeyBpbnRlcm5hbDogdHJ1ZSwgY2xvc2VkOiB0cnVlIH0pO1xuXHRcdFx0XHRpZiAoY2xvc2VkIHx8IHNlZ21lbnQuX2luZGV4ID4gMFxuXHRcdFx0XHRcdFx0JiYgc2VnbWVudC5faW5kZXggPCBudW1TZWdtZW50cyAtIDEpIHtcblx0XHRcdFx0XHRpZiAoam9pbiAhPT0gJ3JvdW5kJyAmJiAoc2VnbWVudC5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHRcdFx0fHwgc2VnbWVudC5faGFuZGxlT3V0LmlzWmVybygpKSlcblx0XHRcdFx0XHRcdFBhdGguX2FkZEJldmVsSm9pbihzZWdtZW50LCBqb2luLCByYWRpdXMsIG1pdGVyTGltaXQsXG5cdFx0XHRcdFx0XHRcdFx0YWRkVG9BcmVhLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjYXAgIT09ICdyb3VuZCcpIHtcblx0XHRcdFx0XHRQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCByYWRpdXMsIGFkZFRvQXJlYSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFhcmVhLmlzRW1wdHkoKSkge1xuXHRcdFx0XHRcdHZhciBsb2M7XG5cdFx0XHRcdFx0cmV0dXJuIGFyZWEuY29udGFpbnMocG9pbnQpXG5cdFx0XHRcdFx0XHR8fCAobG9jID0gYXJlYS5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpKVxuXHRcdFx0XHRcdFx0XHQmJiBpc0Nsb3NlRW5vdWdoKGxvYy5nZXRQb2ludCgpLCB0b2xlcmFuY2VQYWRkaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGlzQ2xvc2VFbm91Z2goc2VnbWVudC5fcG9pbnQsIHN0cm9rZVBhZGRpbmcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmVuZHMgJiYgIW9wdGlvbnMuc2VnbWVudHMgJiYgIWNsb3NlZCkge1xuXHRcdFx0aWYgKHJlcyA9IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1swXSwgdHJ1ZSlcblx0XHRcdFx0XHR8fCBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbbnVtU2VnbWVudHMgLSAxXSwgdHJ1ZSkpXG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLnNlZ21lbnRzIHx8IG9wdGlvbnMuaGFuZGxlcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKVxuXHRcdFx0XHRpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzW2ldKSlcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH1cblx0XHRpZiAocmFkaXVzICE9PSBudWxsKSB7XG5cdFx0XHRsb2MgPSB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCk7XG5cdFx0XHRpZiAobG9jKSB7XG5cdFx0XHRcdHZhciBwYXJhbWV0ZXIgPSBsb2MuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0XHRcdGlmIChwYXJhbWV0ZXIgPT09IDAgfHwgcGFyYW1ldGVyID09PSAxICYmIG51bVNlZ21lbnRzID4gMSkge1xuXHRcdFx0XHRcdGlmICghY2hlY2tTZWdtZW50U3Ryb2tlKGxvYy5nZXRTZWdtZW50KCkpKVxuXHRcdFx0XHRcdFx0bG9jID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIGlmICghaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgc3Ryb2tlUGFkZGluZykpIHtcblx0XHRcdFx0XHRsb2MgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWxvYyAmJiBqb2luID09PSAnbWl0ZXInICYmIG51bVNlZ21lbnRzID4gMSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdGlmIChwb2ludC5nZXREaXN0YW5jZShzZWdtZW50Ll9wb2ludCkgPD0gbWl0ZXJMaW1pdFxuXHRcdFx0XHRcdFx0XHQmJiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkpIHtcblx0XHRcdFx0XHRcdGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gIWxvYyAmJiBoaXRGaWxsICYmIHRoaXMuX2NvbnRhaW5zKHBvaW50KVxuXHRcdFx0XHR8fCBsb2MgJiYgIWhpdFN0cm9rZSAmJiAhaGl0Q3VydmVzXG5cdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KCdmaWxsJywgdGhpcylcblx0XHRcdFx0XHQ6IGxvY1xuXHRcdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KGhpdFN0cm9rZSA/ICdzdHJva2UnIDogJ2N1cnZlJywgdGhpcywge1xuXHRcdFx0XHRcdFx0XHRsb2NhdGlvbjogbG9jLFxuXHRcdFx0XHRcdFx0XHRwb2ludDogbG9jLmdldFBvaW50KClcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQ6IG51bGw7XG5cdH1cblxufSwgQmFzZS5lYWNoKEN1cnZlLmV2YWx1YXRlTWV0aG9kcyxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChvZmZzZXQsIGlzUGFyYW1ldGVyKTtcblx0XHRcdHJldHVybiBsb2MgJiYgbG9jW25hbWVdKCk7XG5cdFx0fTtcblx0fSxcbntcblx0YmVhbnM6IGZhbHNlLFxuXG5cdF9nZXRPZmZzZXQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cdFx0dmFyIGluZGV4ID0gbG9jYXRpb24gJiYgbG9jYXRpb24uZ2V0SW5kZXgoKTtcblx0XHRpZiAoaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdG9mZnNldCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyBpKyspXG5cdFx0XHRcdG9mZnNldCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaW5kZXhdLFxuXHRcdFx0XHRwYXJhbWV0ZXIgPSBsb2NhdGlvbi5nZXRQYXJhbWV0ZXIoKTtcblx0XHRcdGlmIChwYXJhbWV0ZXIgPiAwKVxuXHRcdFx0XHRvZmZzZXQgKz0gY3VydmUuZ2V0UGFydExlbmd0aCgwLCBwYXJhbWV0ZXIpO1xuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25PZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TG9jYXRpb25PZihwb2ludCk7XG5cdFx0XHRpZiAobG9jKVxuXHRcdFx0XHRyZXR1cm4gbG9jO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRPZmZzZXRPZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25PZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0aWYgKGlzUGFyYW1ldGVyKSB7XG5cdFx0XHR2YXIgaW5kZXggPSB+fm9mZnNldCxcblx0XHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaW5kZXhdO1xuXHRcdFx0cmV0dXJuIGN1cnZlID8gY3VydmUuZ2V0TG9jYXRpb25BdChvZmZzZXQgLSBpbmRleCwgdHJ1ZSkgOiBudWxsO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzdGFydCA9IGxlbmd0aCxcblx0XHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRsZW5ndGggKz0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAobGVuZ3RoID4gb2Zmc2V0KSB7XG5cdFx0XHRcdHJldHVybiBjdXJ2ZS5nZXRMb2NhdGlvbkF0KG9mZnNldCAtIHN0YXJ0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9mZnNldCA8PSB0aGlzLmdldExlbmd0aCgpKVxuXHRcdFx0cmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0sIDEpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdG1pbkRpc3QgPSBJbmZpbml0eSxcblx0XHRcdG1pbkxvYyA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9jID0gY3VydmVzW2ldLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCk7XG5cdFx0XHRpZiAobG9jLl9kaXN0YW5jZSA8IG1pbkRpc3QpIHtcblx0XHRcdFx0bWluRGlzdCA9IGxvYy5fZGlzdGFuY2U7XG5cdFx0XHRcdG1pbkxvYyA9IGxvYztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1pbkxvYztcblx0fSxcblxuXHRnZXROZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmdldFBvaW50KCk7XG5cdH1cbn0pLCBuZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZHJhd0hhbmRsZXMoY3R4LCBzZWdtZW50cywgbWF0cml4LCBzaXplKSB7XG5cdFx0dmFyIGhhbGYgPSBzaXplIC8gMjtcblxuXHRcdGZ1bmN0aW9uIGRyYXdIYW5kbGUoaW5kZXgpIHtcblx0XHRcdHZhciBoWCA9IGNvb3Jkc1tpbmRleF0sXG5cdFx0XHRcdGhZID0gY29vcmRzW2luZGV4ICsgMV07XG5cdFx0XHRpZiAocFggIT0gaFggfHwgcFkgIT0gaFkpIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHBYLCBwWSk7XG5cdFx0XHRcdGN0eC5saW5lVG8oaFgsIGhZKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5hcmMoaFgsIGhZLCBoYWxmLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHR2YXIgc3RhdGUgPSBzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSxcblx0XHRcdFx0cFggPSBjb29yZHNbMF0sXG5cdFx0XHRcdHBZID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKHN0YXRlICYgMSlcblx0XHRcdFx0ZHJhd0hhbmRsZSgyKTtcblx0XHRcdGlmIChzdGF0ZSAmIDIpXG5cdFx0XHRcdGRyYXdIYW5kbGUoNCk7XG5cdFx0XHRjdHguZmlsbFJlY3QocFggLSBoYWxmLCBwWSAtIGhhbGYsIHNpemUsIHNpemUpO1xuXHRcdFx0aWYgKCEoc3RhdGUgJiA0KSkge1xuXHRcdFx0XHR2YXIgZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KHBYIC0gaGFsZiArIDEsIHBZIC0gaGFsZiArIDEsIHNpemUgLSAyLCBzaXplIC0gMik7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd1NlZ21lbnRzKGN0eCwgcGF0aCwgbWF0cml4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd1NlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0XHRjdXJZID0gY29vcmRzWzFdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHBvaW50ID0gc2VnbWVudC5fcG9pbnQ7XG5cdFx0XHRcdGN1clggPSBwb2ludC5feDtcblx0XHRcdFx0Y3VyWSA9IHBvaW50Ll95O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRcdGN0eC5tb3ZlVG8oY3VyWCwgY3VyWSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdFx0aW5YID0gY29vcmRzWzJdO1xuXHRcdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlSW47XG5cdFx0XHRcdFx0aW5YID0gY3VyWCArIGhhbmRsZS5feDtcblx0XHRcdFx0XHRpblkgPSBjdXJZICsgaGFuZGxlLl95O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpblggPT09IGN1clggJiYgaW5ZID09PSBjdXJZXG5cdFx0XHRcdFx0XHQmJiBvdXRYID09PSBwcmV2WCAmJiBvdXRZID09PSBwcmV2WSkge1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oY3VyWCwgY3VyWSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8ob3V0WCwgb3V0WSwgaW5YLCBpblksIGN1clgsIGN1clkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwcmV2WCA9IGN1clg7XG5cdFx0XHRwcmV2WSA9IGN1clk7XG5cdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdG91dFggPSBjb29yZHNbNF07XG5cdFx0XHRcdG91dFkgPSBjb29yZHNbNV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlT3V0O1xuXHRcdFx0XHRvdXRYID0gcHJldlggKyBoYW5kbGUuX3g7XG5cdFx0XHRcdG91dFkgPSBwcmV2WSArIGhhbmRsZS5feTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0ZHJhd1NlZ21lbnQoc2VnbWVudHNbaV0pO1xuXHRcdGlmIChwYXRoLl9jbG9zZWQgJiYgbGVuZ3RoID4gMClcblx0XHRcdGRyYXdTZWdtZW50KHNlZ21lbnRzWzBdKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCkge1xuXHRcdFx0dmFyIGRvbnRTdGFydCA9IHBhcmFtLmRvbnRTdGFydCxcblx0XHRcdFx0ZG9udFBhaW50ID0gcGFyYW0uZG9udEZpbmlzaCB8fCBwYXJhbS5jbGlwLFxuXHRcdFx0XHRzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdFx0aGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKSxcblx0XHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRcdGRhc2hBcnJheSA9IHN0eWxlLmdldERhc2hBcnJheSgpLFxuXHRcdFx0XHRkYXNoTGVuZ3RoID0gIXBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCAmJiBoYXNTdHJva2Vcblx0XHRcdFx0XHRcdCYmIGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0XHRpZiAoIWRvbnRTdGFydCAmJiB0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHRcdH0gZWxzZSBpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgJiYgIWRhc2hMZW5ndGggfHwgZG9udFBhaW50KSB7XG5cdFx0XHRcdGRyYXdTZWdtZW50cyhjdHgsIHRoaXMsIHN0cm9rZU1hdHJpeCk7XG5cdFx0XHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0XHR0aGlzLl9jdXJyZW50UGF0aCA9IGN0eC5jdXJyZW50UGF0aDtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0T2Zmc2V0KGkpIHtcblx0XHRcdFx0cmV0dXJuIGRhc2hBcnJheVsoKGkgJSBkYXNoTGVuZ3RoKSArIGRhc2hMZW5ndGgpICUgZGFzaExlbmd0aF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcblx0XHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHRcdGlmIChoYXNGaWxsKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoYXNTdHJva2UpIHtcblx0XHRcdFx0XHRpZiAoZGFzaExlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKCFkb250U3RhcnQpXG5cdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdHZhciBpdGVyYXRvciA9IG5ldyBQYXRoSXRlcmF0b3IodGhpcywgMzIsIDAuMjUsXG5cdFx0XHRcdFx0XHRcdFx0c3Ryb2tlTWF0cml4KSxcblx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gaXRlcmF0b3IubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRmcm9tID0gLXN0eWxlLmdldERhc2hPZmZzZXQoKSwgdG8sXG5cdFx0XHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdFx0ZnJvbSA9IGZyb20gJSBsZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZnJvbSAtPSBnZXRPZmZzZXQoaS0tKSArIGdldE9mZnNldChpLS0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dG8gPSBmcm9tICsgZ2V0T2Zmc2V0KGkrKyk7XG5cdFx0XHRcdFx0XHRcdGlmIChmcm9tID4gMCB8fCB0byA+IDApXG5cdFx0XHRcdFx0XHRcdFx0aXRlcmF0b3IuZHJhd1BhcnQoY3R4LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRNYXRoLm1heChmcm9tLCAwKSwgTWF0aC5tYXgodG8sIDApKTtcblx0XHRcdFx0XHRcdFx0ZnJvbSA9IHRvICsgZ2V0T2Zmc2V0KGkrKyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCkge1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0ZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgbWF0cml4KTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdGRyYXdIYW5kbGVzKGN0eCwgdGhpcy5fc2VnbWVudHMsIG1hdHJpeCwgcGFwZXIuc2V0dGluZ3MuaGFuZGxlU2l6ZSk7XG5cdFx0fVxuXHR9O1xufSwgbmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpIHtcblx0XHR2YXIgbiA9IHJocy5sZW5ndGgsXG5cdFx0XHR4ID0gW10sXG5cdFx0XHR0bXAgPSBbXSxcblx0XHRcdGIgPSAyO1xuXHRcdHhbMF0gPSByaHNbMF0gLyBiO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHR0bXBbaV0gPSAxIC8gYjtcblx0XHRcdGIgPSAoaSA8IG4gLSAxID8gNCA6IDIpIC0gdG1wW2ldO1xuXHRcdFx0eFtpXSA9IChyaHNbaV0gLSB4W2kgLSAxXSkgLyBiO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuXHRcdFx0eFtuIC0gaSAtIDFdIC09IHRtcFtuIC0gaV0gKiB4W24gLSBpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHg7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHNtb290aDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdFx0c2l6ZSA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdFx0Y2xvc2VkID0gdGhpcy5fY2xvc2VkLFxuXHRcdFx0XHRuID0gc2l6ZSxcblx0XHRcdFx0b3ZlcmxhcCA9IDA7XG5cdFx0XHRpZiAoc2l6ZSA8PSAyKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdG92ZXJsYXAgPSBNYXRoLm1pbihzaXplLCA0KTtcblx0XHRcdFx0biArPSBNYXRoLm1pbihzaXplLCBvdmVybGFwKSAqIDI7XG5cdFx0XHR9XG5cdFx0XHR2YXIga25vdHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuXHRcdFx0XHRrbm90c1tpICsgb3ZlcmxhcF0gPSBzZWdtZW50c1tpXS5fcG9pbnQ7XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb3ZlcmxhcDsgaSsrKSB7XG5cdFx0XHRcdFx0a25vdHNbaV0gPSBzZWdtZW50c1tpICsgc2l6ZSAtIG92ZXJsYXBdLl9wb2ludDtcblx0XHRcdFx0XHRrbm90c1tpICsgc2l6ZSArIG92ZXJsYXBdID0gc2VnbWVudHNbaV0uX3BvaW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuLS07XG5cdFx0XHR9XG5cdFx0XHR2YXIgcmhzID0gW107XG5cblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbiAtIDE7IGkrKylcblx0XHRcdFx0cmhzW2ldID0gNCAqIGtub3RzW2ldLl94ICsgMiAqIGtub3RzW2kgKyAxXS5feDtcblx0XHRcdHJoc1swXSA9IGtub3RzWzBdLl94ICsgMiAqIGtub3RzWzFdLl94O1xuXHRcdFx0cmhzW24gLSAxXSA9IDMgKiBrbm90c1tuIC0gMV0uX3g7XG5cdFx0XHR2YXIgeCA9IGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG4gLSAxOyBpKyspXG5cdFx0XHRcdHJoc1tpXSA9IDQgKiBrbm90c1tpXS5feSArIDIgKiBrbm90c1tpICsgMV0uX3k7XG5cdFx0XHRyaHNbMF0gPSBrbm90c1swXS5feSArIDIgKiBrbm90c1sxXS5feTtcblx0XHRcdHJoc1tuIC0gMV0gPSAzICoga25vdHNbbiAtIDFdLl95O1xuXHRcdFx0dmFyIHkgPSBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKTtcblxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgaiA9IHNpemU7IGkgPCBvdmVybGFwOyBpKyssIGorKykge1xuXHRcdFx0XHRcdHZhciBmMSA9IGkgLyBvdmVybGFwLFxuXHRcdFx0XHRcdFx0ZjIgPSAxIC0gZjEsXG5cdFx0XHRcdFx0XHRpZSA9IGkgKyBvdmVybGFwLFxuXHRcdFx0XHRcdFx0amUgPSBqICsgb3ZlcmxhcDtcblx0XHRcdFx0XHR4W2pdID0geFtpXSAqIGYxICsgeFtqXSAqIGYyO1xuXHRcdFx0XHRcdHlbal0gPSB5W2ldICogZjEgKyB5W2pdICogZjI7XG5cdFx0XHRcdFx0eFtqZV0gPSB4W2llXSAqIGYyICsgeFtqZV0gKiBmMTtcblx0XHRcdFx0XHR5W2plXSA9IHlbaWVdICogZjIgKyB5W2plXSAqIGYxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG4tLTtcblx0XHRcdH1cblx0XHRcdHZhciBoYW5kbGVJbiA9IG51bGw7XG5cdFx0XHRmb3IgKHZhciBpID0gb3ZlcmxhcDsgaSA8PSBuIC0gb3ZlcmxhcDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaSAtIG92ZXJsYXBdO1xuXHRcdFx0XHRpZiAoaGFuZGxlSW4pXG5cdFx0XHRcdFx0c2VnbWVudC5zZXRIYW5kbGVJbihoYW5kbGVJbi5zdWJ0cmFjdChzZWdtZW50Ll9wb2ludCkpO1xuXHRcdFx0XHRpZiAoaSA8IG4pIHtcblx0XHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZU91dChcblx0XHRcdFx0XHRcdFx0bmV3IFBvaW50KHhbaV0sIHlbaV0pLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHRcdFx0aGFuZGxlSW4gPSBpIDwgbiAtIDFcblx0XHRcdFx0XHRcdFx0PyBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdFx0MiAqIGtub3RzW2kgKyAxXS5feCAtIHhbaSArIDFdLFxuXHRcdFx0XHRcdFx0XHRcdDIgKiBrbm90c1tpICsgMV0uX3kgLSB5W2kgKyAxXSlcblx0XHRcdFx0XHRcdFx0OiBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdFx0KGtub3RzW25dLl94ICsgeFtuIC0gMV0pIC8gMixcblx0XHRcdFx0XHRcdFx0XHQoa25vdHNbbl0uX3kgKyB5W24gLSAxXSkgLyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCAmJiBoYW5kbGVJbikge1xuXHRcdFx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzWzBdO1xuXHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZUluKGhhbmRsZUluLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSwgbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBnZXRDdXJyZW50U2VnbWVudCh0aGF0KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhhdC5fc2VnbWVudHM7XG5cdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMSlcblx0XHRcdFx0dGhpcy5yZW1vdmVTZWdtZW50KDApO1xuXHRcdFx0aWYgKCFzZWdtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgXSk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21vdmVCeSgpIGlzIHVuc3VwcG9ydGVkIG9uIFBhdGggaXRlbXMuJyk7XG5cdFx0fSxcblxuXHRcdGxpbmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpIF0pO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyk7XG5cdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChoYW5kbGUxLnN1YnRyYWN0KGN1cnJlbnQuX3BvaW50KSk7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudCh0bywgaGFuZGxlMi5zdWJ0cmFjdCh0bykpIF0pO1xuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdGhhbmRsZS5hZGQoY3VycmVudC5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksXG5cdFx0XHRcdGhhbmRsZS5hZGQodG8uc3VidHJhY3QoaGFuZGxlKS5tdWx0aXBseSgxIC8gMykpLFxuXHRcdFx0XHR0b1xuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Y3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHQgPSBCYXNlLnBpY2soQmFzZS5yZWFkKGFyZ3VtZW50cyksIDAuNSksXG5cdFx0XHRcdHQxID0gMSAtIHQsXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdGhhbmRsZSA9IHRocm91Z2guc3VidHJhY3QoY3VycmVudC5tdWx0aXBseSh0MSAqIHQxKSlcblx0XHRcdFx0XHQuc3VidHJhY3QodG8ubXVsdGlwbHkodCAqIHQpKS5kaXZpZGUoMiAqIHQgKiB0MSk7XG5cdFx0XHRpZiAoaGFuZGxlLmlzTmFOKCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnQ2Fubm90IHB1dCBhIGN1cnZlIHRocm91Z2ggcG9pbnRzIHdpdGggcGFyYW1ldGVyID0gJyArIHQpO1xuXHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZSwgdG8pO1xuXHRcdH0sXG5cblx0XHRhcmNUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLFxuXHRcdFx0XHRmcm9tID0gY3VycmVudC5fcG9pbnQsXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0aHJvdWdoLFxuXHRcdFx0XHRwZWVrID0gQmFzZS5wZWVrKGFyZ3VtZW50cyksXG5cdFx0XHRcdGNsb2Nrd2lzZSA9IEJhc2UucGljayhwZWVrLCB0cnVlKSxcblx0XHRcdFx0Y2VudGVyLCBleHRlbnQsIHZlY3RvciwgbWF0cml4O1xuXHRcdFx0aWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR2YXIgbWlkZGxlID0gZnJvbS5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0dGhyb3VnaCA9IG1pZGRsZS5hZGQobWlkZGxlLnN1YnRyYWN0KGZyb20pLnJvdGF0ZShcblx0XHRcdFx0XHRcdGNsb2Nrd2lzZSA/IC05MCA6IDkwKSk7XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UucmVtYWluKGFyZ3VtZW50cykgPD0gMikge1xuXHRcdFx0XHR0aHJvdWdoID0gdG87XG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHRpZiAocmFkaXVzLmlzWmVybygpKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG5cdFx0XHRcdHZhciByb3RhdGlvbiA9IEJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdGNsb2Nrd2lzZSA9ICEhQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0bGFyZ2UgPSAhIUJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0cHQgPSBmcm9tLnN1YnRyYWN0KG1pZGRsZSkucm90YXRlKC1yb3RhdGlvbiksXG5cdFx0XHRcdFx0eCA9IHB0LngsXG5cdFx0XHRcdFx0eSA9IHB0LnksXG5cdFx0XHRcdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdFx0ZXBzaWxvbiA9IDFlLTEyLFxuXHRcdFx0XHRcdHJ4ID0gYWJzKHJhZGl1cy53aWR0aCksXG5cdFx0XHRcdFx0cnkgPSBhYnMocmFkaXVzLmhlaWdodCksXG5cdFx0XHRcdFx0cnhTcSA9IHJ4ICogcngsXG5cdFx0XHRcdFx0cnlTcSA9IHJ5ICogcnksXG5cdFx0XHRcdFx0eFNxID0gIHggKiB4LFxuXHRcdFx0XHRcdHlTcSA9ICB5ICogeTtcblx0XHRcdFx0dmFyIGZhY3RvciA9IE1hdGguc3FydCh4U3EgLyByeFNxICsgeVNxIC8gcnlTcSk7XG5cdFx0XHRcdGlmIChmYWN0b3IgPiAxKSB7XG5cdFx0XHRcdFx0cnggKj0gZmFjdG9yO1xuXHRcdFx0XHRcdHJ5ICo9IGZhY3Rvcjtcblx0XHRcdFx0XHRyeFNxID0gcnggKiByeDtcblx0XHRcdFx0XHRyeVNxID0gcnkgKiByeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmYWN0b3IgPSAocnhTcSAqIHJ5U3EgLSByeFNxICogeVNxIC0gcnlTcSAqIHhTcSkgL1xuXHRcdFx0XHRcdFx0KHJ4U3EgKiB5U3EgKyByeVNxICogeFNxKTtcblx0XHRcdFx0aWYgKGFicyhmYWN0b3IpIDwgZXBzaWxvbilcblx0XHRcdFx0XHRmYWN0b3IgPSAwO1xuXHRcdFx0XHRpZiAoZmFjdG9yIDwgMClcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIGFuIGFyYyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMnKTtcblx0XHRcdFx0Y2VudGVyID0gbmV3IFBvaW50KHJ4ICogeSAvIHJ5LCAtcnkgKiB4IC8gcngpXG5cdFx0XHRcdFx0XHQubXVsdGlwbHkoKGxhcmdlID09PSBjbG9ja3dpc2UgPyAtMSA6IDEpXG5cdFx0XHRcdFx0XHRcdCogTWF0aC5zcXJ0KGZhY3RvcikpXG5cdFx0XHRcdFx0XHQucm90YXRlKHJvdGF0aW9uKS5hZGQobWlkZGxlKTtcblx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShjZW50ZXIpLnJvdGF0ZShyb3RhdGlvbilcblx0XHRcdFx0XHRcdC5zY2FsZShyeCwgcnkpO1xuXHRcdFx0XHR2ZWN0b3IgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oZnJvbSk7XG5cdFx0XHRcdGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0bykpO1xuXHRcdFx0XHRpZiAoIWNsb2Nrd2lzZSAmJiBleHRlbnQgPiAwKVxuXHRcdFx0XHRcdGV4dGVudCAtPSAzNjA7XG5cdFx0XHRcdGVsc2UgaWYgKGNsb2Nrd2lzZSAmJiBleHRlbnQgPCAwKVxuXHRcdFx0XHRcdGV4dGVudCArPSAzNjA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhyb3VnaCkge1xuXHRcdFx0XHR2YXIgbDEgPSBuZXcgTGluZShmcm9tLmFkZCh0aHJvdWdoKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0XHRcdHRocm91Z2guc3VidHJhY3QoZnJvbSkucm90YXRlKDkwKSwgdHJ1ZSksXG5cdFx0XHRcdFx0bDIgPSBuZXcgTGluZSh0aHJvdWdoLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdFx0XHR0by5zdWJ0cmFjdCh0aHJvdWdoKS5yb3RhdGUoOTApLCB0cnVlKSxcblx0XHRcdFx0XHRsaW5lID0gbmV3IExpbmUoZnJvbSwgdG8pLFxuXHRcdFx0XHRcdHRocm91Z2hTaWRlID0gbGluZS5nZXRTaWRlKHRocm91Z2gpO1xuXHRcdFx0XHRjZW50ZXIgPSBsMS5pbnRlcnNlY3QobDIsIHRydWUpO1xuXHRcdFx0XHRpZiAoIWNlbnRlcikge1xuXHRcdFx0XHRcdGlmICghdGhyb3VnaFNpZGUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZlY3RvciA9IGZyb20uc3VidHJhY3QoY2VudGVyKTtcblx0XHRcdFx0ZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUodG8uc3VidHJhY3QoY2VudGVyKSk7XG5cdFx0XHRcdHZhciBjZW50ZXJTaWRlID0gbGluZS5nZXRTaWRlKGNlbnRlcik7XG5cdFx0XHRcdGlmIChjZW50ZXJTaWRlID09PSAwKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ID0gdGhyb3VnaFNpZGUgKiBNYXRoLmFicyhleHRlbnQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRocm91Z2hTaWRlID09PSBjZW50ZXJTaWRlKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ICs9IGV4dGVudCA8IDAgPyAzNjAgOiAtMzYwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgZXh0ID0gTWF0aC5hYnMoZXh0ZW50KSxcblx0XHRcdFx0Y291bnQgPSBleHQgPj0gMzYwID8gNCA6IE1hdGguY2VpbChleHQgLyA5MCksXG5cdFx0XHRcdGluYyA9IGV4dGVudCAvIGNvdW50LFxuXHRcdFx0XHRoYWxmID0gaW5jICogTWF0aC5QSSAvIDM2MCxcblx0XHRcdFx0eiA9IDQgLyAzICogTWF0aC5zaW4oaGFsZikgLyAoMSArIE1hdGguY29zKGhhbGYpKSxcblx0XHRcdFx0c2VnbWVudHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspIHtcblx0XHRcdFx0dmFyIHB0ID0gdG8sXG5cdFx0XHRcdFx0b3V0ID0gbnVsbDtcblx0XHRcdFx0aWYgKGkgPCBjb3VudCkge1xuXHRcdFx0XHRcdG91dCA9IHZlY3Rvci5yb3RhdGUoOTApLm11bHRpcGx5KHopO1xuXHRcdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRcdHB0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IpO1xuXHRcdFx0XHRcdFx0b3V0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKG91dCkpXG5cdFx0XHRcdFx0XHRcdFx0LnN1YnRyYWN0KHB0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQgPSBjZW50ZXIuYWRkKHZlY3Rvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0Y3VycmVudC5zZXRIYW5kbGVPdXQob3V0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgX2luID0gdmVjdG9yLnJvdGF0ZSgtOTApLm11bHRpcGx5KHopO1xuXHRcdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRcdF9pbiA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yLmFkZChfaW4pKVxuXHRcdFx0XHRcdFx0XHRcdC5zdWJ0cmFjdChwdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQocHQsIF9pbiwgb3V0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmVjdG9yID0gdmVjdG9yLnJvdGF0ZShpbmMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzKTtcblx0XHR9LFxuXG5cdFx0bGluZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMubGluZVRvKGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdGN1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRocm91Z2ggPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwYXJhbWV0ZXIgPSBCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMuY3VydmVUbyhjdXJyZW50LmFkZCh0aHJvdWdoKSwgY3VycmVudC5hZGQodG8pLCBwYXJhbWV0ZXIpO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oY3VycmVudC5hZGQoaGFuZGxlMSksIGN1cnJlbnQuYWRkKGhhbmRsZTIpLFxuXHRcdFx0XHRcdGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdHF1YWRyYXRpY0N1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oY3VycmVudC5hZGQoaGFuZGxlKSwgY3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0YXJjQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdHBvaW50ID0gY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmd1bWVudHMpKSxcblx0XHRcdFx0Y2xvY2t3aXNlID0gQmFzZS5waWNrKEJhc2UucGVlayhhcmd1bWVudHMpLCB0cnVlKTtcblx0XHRcdGlmICh0eXBlb2YgY2xvY2t3aXNlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dGhpcy5hcmNUbyhwb2ludCwgY2xvY2t3aXNlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYXJjVG8ocG9pbnQsIGN1cnJlbnQuYWRkKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjbG9zZVBhdGg6IGZ1bmN0aW9uKGpvaW4pIHtcblx0XHRcdHRoaXMuc2V0Q2xvc2VkKHRydWUpO1xuXHRcdFx0aWYgKGpvaW4pXG5cdFx0XHRcdHRoaXMuam9pbigpO1xuXHRcdH1cblx0fTtcbn0sIHtcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHJldHVybiBQYXRoW2dldHRlcl0odGhpcy5fc2VnbWVudHMsIHRoaXMuX2Nsb3NlZCwgdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0XHRtYXRyaXgpO1xuXHR9LFxuXG5zdGF0aWNzOiB7XG5cdGlzQ2xvY2t3aXNlOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHZhciBzdW0gPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c3VtICs9IEN1cnZlLmdldEVkZ2VTdW0oQ3VydmUuZ2V0VmFsdWVzKFxuXHRcdFx0XHRcdHNlZ21lbnRzW2ldLCBzZWdtZW50c1tpICsgMSA8IGwgPyBpICsgMSA6IDBdKSk7XG5cdFx0cmV0dXJuIHN1bSA+IDA7XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LCBzdHJva2VQYWRkaW5nKSB7XG5cdFx0dmFyIGZpcnN0ID0gc2VnbWVudHNbMF07XG5cdFx0aWYgKCFmaXJzdClcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdHByZXZDb29yZHMgPSBmaXJzdC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBuZXcgQXJyYXkoNiksIGZhbHNlKSxcblx0XHRcdG1pbiA9IHByZXZDb29yZHMuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBtaW4uc2xpY2UoKSxcblx0XHRcdHJvb3RzID0gbmV3IEFycmF5KDIpO1xuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc1NlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG5cdFx0XHRcdEN1cnZlLl9hZGRCb3VuZHMoXG5cdFx0XHRcdFx0cHJldkNvb3Jkc1tpXSxcblx0XHRcdFx0XHRwcmV2Q29vcmRzW2kgKyA0XSxcblx0XHRcdFx0XHRjb29yZHNbaSArIDJdLFxuXHRcdFx0XHRcdGNvb3Jkc1tpXSxcblx0XHRcdFx0XHRpLCBzdHJva2VQYWRkaW5nID8gc3Ryb2tlUGFkZGluZ1tpXSA6IDAsIG1pbiwgbWF4LCByb290cyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG1wID0gcHJldkNvb3Jkcztcblx0XHRcdHByZXZDb29yZHMgPSBjb29yZHM7XG5cdFx0XHRjb29yZHMgPSB0bXA7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRwcm9jZXNzU2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKGNsb3NlZClcblx0XHRcdHByb2Nlc3NTZWdtZW50KGZpcnN0KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZShtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuXHR9LFxuXG5cdGdldFN0cm9rZUJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCkge1xuXHRcdGlmICghc3R5bGUuaGFzU3Ryb2tlKCkpXG5cdFx0XHRyZXR1cm4gUGF0aC5nZXRCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCk7XG5cdFx0dmFyIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCAtIChjbG9zZWQgPyAwIDogMSksXG5cdFx0XHRyYWRpdXMgPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMixcblx0XHRcdHBhZGRpbmcgPSBQYXRoLl9nZXRQZW5QYWRkaW5nKHJhZGl1cywgbWF0cml4KSxcblx0XHRcdGJvdW5kcyA9IFBhdGguZ2V0Qm91bmRzKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsIHBhZGRpbmcpLFxuXHRcdFx0am9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcblx0XHRcdGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuXHRcdFx0bWl0ZXJMaW1pdCA9IHJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHR2YXIgam9pbkJvdW5kcyA9IG5ldyBSZWN0YW5nbGUobmV3IFNpemUocGFkZGluZykubXVsdGlwbHkoMikpO1xuXG5cdFx0ZnVuY3Rpb24gYWRkKHBvaW50KSB7XG5cdFx0XHRib3VuZHMgPSBib3VuZHMuaW5jbHVkZShtYXRyaXhcblx0XHRcdFx0PyBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvaW50LCBwb2ludCkgOiBwb2ludCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkUm91bmQoc2VnbWVudCkge1xuXHRcdFx0Ym91bmRzID0gYm91bmRzLnVuaXRlKGpvaW5Cb3VuZHMuc2V0Q2VudGVyKG1hdHJpeFxuXHRcdFx0XHQ/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQoc2VnbWVudC5fcG9pbnQpIDogc2VnbWVudC5fcG9pbnQpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRKb2luKHNlZ21lbnQsIGpvaW4pIHtcblx0XHRcdHZhciBoYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZUluLFxuXHRcdFx0XHRoYW5kbGVPdXQgPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRpZiAoam9pbiA9PT0gJ3JvdW5kJyB8fCAhaGFuZGxlSW4uaXNaZXJvKCkgJiYgIWhhbmRsZU91dC5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIGhhbmRsZUluLmlzQ29sbGluZWFyKGhhbmRsZU91dCkpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LCBhZGQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZENhcChzZWdtZW50LCBjYXApIHtcblx0XHRcdGlmIChjYXAgPT09ICdyb3VuZCcpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCByYWRpdXMsIGFkZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdGFkZEpvaW4oc2VnbWVudHNbaV0sIGpvaW4pO1xuXHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdGFkZEpvaW4oc2VnbWVudHNbMF0sIGpvaW4pO1xuXHRcdH0gZWxzZSBpZiAobGVuZ3RoID4gMCkge1xuXHRcdFx0YWRkQ2FwKHNlZ21lbnRzWzBdLCBjYXApO1xuXHRcdFx0YWRkQ2FwKHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLCBjYXApO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXG5cdF9nZXRQZW5QYWRkaW5nOiBmdW5jdGlvbihyYWRpdXMsIG1hdHJpeCkge1xuXHRcdGlmICghbWF0cml4KVxuXHRcdFx0cmV0dXJuIFtyYWRpdXMsIHJhZGl1c107XG5cdFx0dmFyIG14ID0gbWF0cml4LnNoaWZ0bGVzcygpLFxuXHRcdFx0aG9yID0gbXgudHJhbnNmb3JtKG5ldyBQb2ludChyYWRpdXMsIDApKSxcblx0XHRcdHZlciA9IG14LnRyYW5zZm9ybShuZXcgUG9pbnQoMCwgcmFkaXVzKSksXG5cdFx0XHRwaGkgPSBob3IuZ2V0QW5nbGVJblJhZGlhbnMoKSxcblx0XHRcdGEgPSBob3IuZ2V0TGVuZ3RoKCksXG5cdFx0XHRiID0gdmVyLmdldExlbmd0aCgpO1xuXHRcdHZhciBzaW4gPSBNYXRoLnNpbihwaGkpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MocGhpKSxcblx0XHRcdHRhbiA9IE1hdGgudGFuKHBoaSksXG5cdFx0XHR0eCA9IC1NYXRoLmF0YW4oYiAqIHRhbiAvIGEpLFxuXHRcdFx0dHkgPSBNYXRoLmF0YW4oYiAvICh0YW4gKiBhKSk7XG5cdFx0cmV0dXJuIFtNYXRoLmFicyhhICogTWF0aC5jb3ModHgpICogY29zIC0gYiAqIE1hdGguc2luKHR4KSAqIHNpbiksXG5cdFx0XHRcdE1hdGguYWJzKGIgKiBNYXRoLnNpbih0eSkgKiBjb3MgKyBhICogTWF0aC5jb3ModHkpICogc2luKV07XG5cdH0sXG5cblx0X2FkZEJldmVsSm9pbjogZnVuY3Rpb24oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LCBhZGRQb2ludCwgYXJlYSkge1xuXHRcdHZhciBjdXJ2ZTIgPSBzZWdtZW50LmdldEN1cnZlKCksXG5cdFx0XHRjdXJ2ZTEgPSBjdXJ2ZTIuZ2V0UHJldmlvdXMoKSxcblx0XHRcdHBvaW50ID0gY3VydmUyLmdldFBvaW50QXQoMCwgdHJ1ZSksXG5cdFx0XHRub3JtYWwxID0gY3VydmUxLmdldE5vcm1hbEF0KDEsIHRydWUpLFxuXHRcdFx0bm9ybWFsMiA9IGN1cnZlMi5nZXROb3JtYWxBdCgwLCB0cnVlKSxcblx0XHRcdHN0ZXAgPSBub3JtYWwxLmdldERpcmVjdGVkQW5nbGUobm9ybWFsMikgPCAwID8gLXJhZGl1cyA6IHJhZGl1cztcblx0XHRub3JtYWwxLnNldExlbmd0aChzdGVwKTtcblx0XHRub3JtYWwyLnNldExlbmd0aChzdGVwKTtcblx0XHRpZiAoYXJlYSkge1xuXHRcdFx0YWRkUG9pbnQocG9pbnQpO1xuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblx0XHR9XG5cdFx0aWYgKGpvaW4gPT09ICdtaXRlcicpIHtcblx0XHRcdHZhciBjb3JuZXIgPSBuZXcgTGluZShcblx0XHRcdFx0XHRwb2ludC5hZGQobm9ybWFsMSksXG5cdFx0XHRcdFx0bmV3IFBvaW50KC1ub3JtYWwxLnksIG5vcm1hbDEueCksIHRydWVcblx0XHRcdFx0KS5pbnRlcnNlY3QobmV3IExpbmUoXG5cdFx0XHRcdFx0cG9pbnQuYWRkKG5vcm1hbDIpLFxuXHRcdFx0XHRcdG5ldyBQb2ludCgtbm9ybWFsMi55LCBub3JtYWwyLngpLCB0cnVlXG5cdFx0XHRcdCksIHRydWUpO1xuXHRcdFx0aWYgKGNvcm5lciAmJiBwb2ludC5nZXREaXN0YW5jZShjb3JuZXIpIDw9IG1pdGVyTGltaXQpIHtcblx0XHRcdFx0YWRkUG9pbnQoY29ybmVyKTtcblx0XHRcdFx0aWYgKCFhcmVhKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFhcmVhKVxuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMikpO1xuXHR9LFxuXG5cdF9hZGRTcXVhcmVDYXA6IGZ1bmN0aW9uKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGRQb2ludCwgYXJlYSkge1xuXHRcdHZhciBwb2ludCA9IHNlZ21lbnQuX3BvaW50LFxuXHRcdFx0bG9jID0gc2VnbWVudC5nZXRMb2NhdGlvbigpLFxuXHRcdFx0bm9ybWFsID0gbG9jLmdldE5vcm1hbCgpLm11bHRpcGx5KHJhZGl1cyk7XG5cdFx0aWYgKGFyZWEpIHtcblx0XHRcdGFkZFBvaW50KHBvaW50LnN1YnRyYWN0KG5vcm1hbCkpO1xuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbCkpO1xuXHRcdH1cblx0XHRpZiAoY2FwID09PSAnc3F1YXJlJylcblx0XHRcdHBvaW50ID0gcG9pbnQuYWRkKG5vcm1hbC5yb3RhdGUobG9jLmdldFBhcmFtZXRlcigpID09PSAwID8gLTkwIDogOTApKTtcblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG5cdFx0YWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LCBzdHJva2VQYWRkaW5nLFxuXHRcdFx0am9pblBhZGRpbmcpIHtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0eDEgPSBJbmZpbml0eSxcblx0XHRcdHgyID0gLXgxLFxuXHRcdFx0eTEgPSB4MSxcblx0XHRcdHkyID0geDI7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA2OyBqICs9IDIpIHtcblx0XHRcdFx0dmFyIHBhZGRpbmcgPSBqID09PSAwID8gam9pblBhZGRpbmcgOiBzdHJva2VQYWRkaW5nLFxuXHRcdFx0XHRcdHBhZGRpbmdYID0gcGFkZGluZyA/IHBhZGRpbmdbMF0gOiAwLFxuXHRcdFx0XHRcdHBhZGRpbmdZID0gcGFkZGluZyA/IHBhZGRpbmdbMV0gOiAwLFxuXHRcdFx0XHRcdHggPSBjb29yZHNbal0sXG5cdFx0XHRcdFx0eSA9IGNvb3Jkc1tqICsgMV0sXG5cdFx0XHRcdFx0eG4gPSB4IC0gcGFkZGluZ1gsXG5cdFx0XHRcdFx0eHggPSB4ICsgcGFkZGluZ1gsXG5cdFx0XHRcdFx0eW4gPSB5IC0gcGFkZGluZ1ksXG5cdFx0XHRcdFx0eXggPSB5ICsgcGFkZGluZ1k7XG5cdFx0XHRcdGlmICh4biA8IHgxKSB4MSA9IHhuO1xuXHRcdFx0XHRpZiAoeHggPiB4MikgeDIgPSB4eDtcblx0XHRcdFx0aWYgKHluIDwgeTEpIHkxID0geW47XG5cdFx0XHRcdGlmICh5eCA+IHkyKSB5MiA9IHl4O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGdldFJvdWdoQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KSB7XG5cdFx0dmFyIHN0cm9rZVJhZGl1cyA9IHN0eWxlLmhhc1N0cm9rZSgpID8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIgOiAwLFxuXHRcdFx0am9pblJhZGl1cyA9IHN0cm9rZVJhZGl1cztcblx0XHRpZiAoc3Ryb2tlUmFkaXVzID4gMCkge1xuXHRcdFx0aWYgKHN0eWxlLmdldFN0cm9rZUpvaW4oKSA9PT0gJ21pdGVyJylcblx0XHRcdFx0am9pblJhZGl1cyA9IHN0cm9rZVJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdGlmIChzdHlsZS5nZXRTdHJva2VDYXAoKSA9PT0gJ3NxdWFyZScpXG5cdFx0XHRcdGpvaW5SYWRpdXMgPSBNYXRoLm1heChqb2luUmFkaXVzLCBzdHJva2VSYWRpdXMgKiBNYXRoLnNxcnQoMikpO1xuXHRcdH1cblx0XHRyZXR1cm4gUGF0aC5nZXRIYW5kbGVCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCxcblx0XHRcdFx0UGF0aC5fZ2V0UGVuUGFkZGluZyhzdHJva2VSYWRpdXMsIG1hdHJpeCksXG5cdFx0XHRcdFBhdGguX2dldFBlblBhZGRpbmcoam9pblJhZGl1cywgbWF0cml4KSk7XG5cdH1cbn19KTtcblxuUGF0aC5pbmplY3QoeyBzdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGthcHBhID0gMC41NTIyODQ3NDk4MzA3OTM2LFxuXHRcdGVsbGlwc2VTZWdtZW50cyA9IFtcblx0XHRcdG5ldyBTZWdtZW50KFstMSwgMF0sIFswLCBrYXBwYSBdLCBbMCwgLWthcHBhXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMCwgLTFdLCBbLWthcHBhLCAwXSwgW2thcHBhLCAwIF0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzEsIDBdLCBbMCwgLWthcHBhXSwgWzAsIGthcHBhIF0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzAsIDFdLCBba2FwcGEsIDAgXSwgWy1rYXBwYSwgMF0pXG5cdFx0XTtcblxuXHRmdW5jdGlvbiBjcmVhdGVQYXRoKHNlZ21lbnRzLCBjbG9zZWQsIGFyZ3MpIHtcblx0XHR2YXIgcHJvcHMgPSBCYXNlLmdldE5hbWVkKGFyZ3MpLFxuXHRcdFx0cGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PT0gZmFsc2UgJiYgSXRlbS5OT19JTlNFUlQpO1xuXHRcdHBhdGguX2FkZChzZWdtZW50cyk7XG5cdFx0cGF0aC5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdHJldHVybiBwYXRoLnNldChwcm9wcyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFbGxpcHNlKGNlbnRlciwgcmFkaXVzLCBhcmdzKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gbmV3IEFycmF5KDQpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IGVsbGlwc2VTZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoXG5cdFx0XHRcdHNlZ21lbnQuX3BvaW50Lm11bHRpcGx5KHJhZGl1cykuYWRkKGNlbnRlciksXG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZUluLm11bHRpcGx5KHJhZGl1cyksXG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZU91dC5tdWx0aXBseShyYWRpdXMpXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdExpbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoW1xuXHRcdFx0XHRuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnZnJvbScpKSxcblx0XHRcdFx0bmV3IFNlZ21lbnQoUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJykpXG5cdFx0XHRdLCBmYWxzZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Q2lyY2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMpLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSZWN0YW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JlY3RhbmdsZScpLFxuXHRcdFx0XHRyYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnLCAwLFxuXHRcdFx0XHRcdFx0eyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdFx0YmwgPSByZWN0LmdldEJvdHRvbUxlZnQodHJ1ZSksXG5cdFx0XHRcdHRsID0gcmVjdC5nZXRUb3BMZWZ0KHRydWUpLFxuXHRcdFx0XHR0ciA9IHJlY3QuZ2V0VG9wUmlnaHQodHJ1ZSksXG5cdFx0XHRcdGJyID0gcmVjdC5nZXRCb3R0b21SaWdodCh0cnVlKSxcblx0XHRcdFx0c2VnbWVudHM7XG5cdFx0XHRpZiAoIXJhZGl1cyB8fCByYWRpdXMuaXNaZXJvKCkpIHtcblx0XHRcdFx0c2VnbWVudHMgPSBbXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ciksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIpXG5cdFx0XHRcdF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyYWRpdXMgPSBTaXplLm1pbihyYWRpdXMsIHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuXHRcdFx0XHR2YXIgcnggPSByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSByYWRpdXMuaGVpZ2h0LFxuXHRcdFx0XHRcdGh4ID0gcnggKiBrYXBwYSxcblx0XHRcdFx0XHRoeSA9IHJ5ICoga2FwcGE7XG5cdFx0XHRcdHNlZ21lbnRzID0gW1xuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsLmFkZChyeCwgMCksIG51bGwsIFstaHgsIDBdKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibC5zdWJ0cmFjdCgwLCByeSksIFswLCBoeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsLmFkZCgwLCByeSksIG51bGwsIFswLCAtaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0bC5hZGQocngsIDApLCBbLWh4LCAwXSwgbnVsbCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodHIuc3VidHJhY3QocngsIDApLCBudWxsLCBbaHgsIDBdKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ci5hZGQoMCwgcnkpLCBbMCwgLWh5XSwgbnVsbCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIuc3VidHJhY3QoMCwgcnkpLCBudWxsLCBbMCwgaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChici5zdWJ0cmFjdChyeCwgMCksIFtoeCwgMF0pXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Um91bmRSZWN0YW5nbGU6ICcjUmVjdGFuZ2xlJyxcblxuXHRcdEVsbGlwc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBjcmVhdGVFbGxpcHNlKGVsbGlwc2UuY2VudGVyLCBlbGxpcHNlLnJhZGl1cywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0T3ZhbDogJyNFbGxpcHNlJyxcblxuXHRcdEFyYzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZnJvbSA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJyksXG5cdFx0XHRcdHRocm91Z2ggPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndGhyb3VnaCcpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0bycpLFxuXHRcdFx0XHRwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PT0gZmFsc2Vcblx0XHRcdFx0XHRcdCYmIEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdHBhdGgubW92ZVRvKGZyb20pO1xuXHRcdFx0cGF0aC5hcmNUbyh0aHJvdWdoLCB0byk7XG5cdFx0XHRyZXR1cm4gcGF0aC5zZXQocHJvcHMpO1xuXHRcdH0sXG5cblx0XHRSZWd1bGFyUG9seWdvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRzaWRlcyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3NpZGVzJyksXG5cdFx0XHRcdHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpLFxuXHRcdFx0XHRzdGVwID0gMzYwIC8gc2lkZXMsXG5cdFx0XHRcdHRocmVlID0gIShzaWRlcyAlIDMpLFxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgUG9pbnQoMCwgdGhyZWUgPyAtcmFkaXVzIDogcmFkaXVzKSxcblx0XHRcdFx0b2Zmc2V0ID0gdGhyZWUgPyAtMSA6IDAuNSxcblx0XHRcdFx0c2VnbWVudHMgPSBuZXcgQXJyYXkoc2lkZXMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQoXG5cdFx0XHRcdFx0dmVjdG9yLnJvdGF0ZSgoaSArIG9mZnNldCkgKiBzdGVwKSkpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFN0YXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cG9pbnRzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncG9pbnRzJykgKiAyLFxuXHRcdFx0XHRyYWRpdXMxID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzMScpLFxuXHRcdFx0XHRyYWRpdXMyID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzMicpLFxuXHRcdFx0XHRzdGVwID0gMzYwIC8gcG9pbnRzLFxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgUG9pbnQoMCwgLTEpLFxuXHRcdFx0XHRzZWdtZW50cyA9IG5ldyBBcnJheShwb2ludHMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHM7IGkrKylcblx0XHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChjZW50ZXIuYWRkKHZlY3Rvci5yb3RhdGUoc3RlcCAqIGkpXG5cdFx0XHRcdFx0XHQubXVsdGlwbHkoaSAlIDIgPyByYWRpdXMyIDogcmFkaXVzMSkpKTtcblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcbn19KTtcblxudmFyIENvbXBvdW5kUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ0NvbXBvdW5kUGF0aCcsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjaGlsZHJlbjogW11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDb21wb3VuZFBhdGgoYXJnKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpIHtcblx0XHRcdGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFBhdGhEYXRhKGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGluc2VydENoaWxkcmVuOiBmdW5jdGlvbiBpbnNlcnRDaGlsZHJlbihpbmRleCwgaXRlbXMsIF9wcmVzZXJ2ZSkge1xuXHRcdGl0ZW1zID0gaW5zZXJ0Q2hpbGRyZW4uYmFzZS5jYWxsKHRoaXMsIGluZGV4LCBpdGVtcywgX3ByZXNlcnZlLCBQYXRoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9ICFfcHJlc2VydmUgJiYgaXRlbXMgJiYgaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0aWYgKGl0ZW0uX2Nsb2Nrd2lzZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRpdGVtLnNldENsb2Nrd2lzZShpdGVtLl9pbmRleCA9PT0gMCk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGNoaWxkcmVuW2ldLnJldmVyc2UoKTtcblx0fSxcblxuXHRzbW9vdGg6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0dGhpcy5fY2hpbGRyZW5baV0uc21vb3RoKCk7XG5cdH0sXG5cblx0cmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoKSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0dmFyIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdFx0cGF0aC5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiByZWR1Y2UuYmFzZS5jYWxsKHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRpc0Nsb2Nrd2lzZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGNoaWxkICYmIGNoaWxkLmlzQ2xvY2t3aXNlKCk7XG5cdH0sXG5cblx0c2V0Q2xvY2t3aXNlOiBmdW5jdGlvbihjbG9ja3dpc2UpIHtcblx0XHRpZiAodGhpcy5pc0Nsb2Nrd2lzZSgpICE9PSAhIWNsb2Nrd2lzZSlcblx0XHRcdHRoaXMucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0U2VnbWVudCgpO1xuXHR9LFxuXG5cdGdldExhc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRMYXN0U2VnbWVudCgpO1xuXHR9LFxuXG5cdGdldEN1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRjdXJ2ZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGN1cnZlcy5wdXNoLmFwcGx5KGN1cnZlcywgY2hpbGRyZW5baV0uZ2V0Q3VydmVzKCkpO1xuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRMYXN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gbGFzdCAmJiBsYXN0LmdldEZpcnN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGFyZWEgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0YXJlYSArPSBjaGlsZHJlbltpXS5nZXRBcmVhKCk7XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH1cbn0sIHtcblx0YmVhbnM6IHRydWUsXG5cblx0Z2V0UGF0aERhdGE6IGZ1bmN0aW9uKF9tYXRyaXgsIF9wcmVjaXNpb24pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHBhdGhzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRteCA9IGNoaWxkLl9tYXRyaXg7XG5cdFx0XHRwYXRocy5wdXNoKGNoaWxkLmdldFBhdGhEYXRhKF9tYXRyaXggJiYgIW14LmlzSWRlbnRpdHkoKVxuXHRcdFx0XHRcdD8gX21hdHJpeC5jaGFpbihteCkgOiBteCwgX3ByZWNpc2lvbikpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHMuam9pbignICcpO1xuXHR9XG59LCB7XG5cdF9nZXRDaGlsZEhpdFRlc3RPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuY2xhc3MgPT09IFBhdGggfHwgb3B0aW9ucy50eXBlID09PSAncGF0aCdcblx0XHRcdFx0PyBvcHRpb25zXG5cdFx0XHRcdDogbmV3IEJhc2Uob3B0aW9ucywgeyBmaWxsOiBmYWxzZSB9KTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybjtcblxuXHRcdGlmICh0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0Y3R4LmN1cnJlbnRQYXRoID0gdGhpcy5fY3VycmVudFBhdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcmFtID0gcGFyYW0uZXh0ZW5kKHsgZG9udFN0YXJ0OiB0cnVlLCBkb250RmluaXNoOiB0cnVlIH0pO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLmRyYXcoY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KTtcblx0XHRcdHRoaXMuX2N1cnJlbnRQYXRoID0gY3R4LmN1cnJlbnRQYXRoO1xuXHRcdH1cblxuXHRcdGlmICghcGFyYW0uY2xpcCkge1xuXHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblx0XHRcdGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgc2VsZWN0ZWRJdGVtcykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0bXggPSBjaGlsZC5fbWF0cml4O1xuXHRcdFx0aWYgKCFzZWxlY3RlZEl0ZW1zW2NoaWxkLl9pZF0pXG5cdFx0XHRcdGNoaWxkLl9kcmF3U2VsZWN0ZWQoY3R4LCBteC5pc0lkZW50aXR5KCkgPyBtYXRyaXhcblx0XHRcdFx0XHRcdDogbWF0cml4LmNoYWluKG14KSk7XG5cdFx0fVxuXHR9XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRQYXRoKHRoYXQsIGNoZWNrKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhhdC5fY2hpbGRyZW47XG5cdFx0aWYgKGNoZWNrICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHZhciBmaWVsZHMgPSB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcyksXG5cdFx0XHRcdHBhdGggPSBjdXJyZW50ICYmIGN1cnJlbnQuaXNFbXB0eSgpID8gY3VycmVudCA6IG5ldyBQYXRoKCk7XG5cdFx0XHRpZiAocGF0aCAhPT0gY3VycmVudClcblx0XHRcdFx0dGhpcy5hZGRDaGlsZChwYXRoKTtcblx0XHRcdHBhdGgubW92ZVRvLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpLFxuXHRcdFx0XHRsYXN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5tb3ZlVG8obGFzdCA/IHBvaW50LmFkZChsYXN0Ll9wb2ludCkgOiBwb2ludCk7XG5cdFx0fSxcblxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24oam9pbikge1xuXHRcdFx0Z2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSkuY2xvc2VQYXRoKGpvaW4pO1xuXHRcdH1cblx0fTtcblxuXHRCYXNlLmVhY2goWydsaW5lVG8nLCAnY3ViaWNDdXJ2ZVRvJywgJ3F1YWRyYXRpY0N1cnZlVG8nLCAnY3VydmVUbycsICdhcmNUbycsXG5cdFx0XHQnbGluZUJ5JywgJ2N1YmljQ3VydmVCeScsICdxdWFkcmF0aWNDdXJ2ZUJ5JywgJ2N1cnZlQnknLCAnYXJjQnknXSxcblx0XHRcdGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRmaWVsZHNba2V5XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBwYXRoID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSk7XG5cdFx0XHRcdFx0cGF0aFtrZXldLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdCk7XG5cblx0cmV0dXJuIGZpZWxkcztcbn0pO1xuXG5QYXRoSXRlbS5pbmplY3QobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3BlcmF0b3JzID0ge1xuXHRcdHVuaXRlOiBmdW5jdGlvbih3KSB7XG5cdFx0XHRyZXR1cm4gdyA9PT0gMSB8fCB3ID09PSAwO1xuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKHcpIHtcblx0XHRcdHJldHVybiB3ID09PSAyO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24odykge1xuXHRcdFx0cmV0dXJuIHcgPT09IDE7XG5cdFx0fSxcblxuXHRcdGV4Y2x1ZGU6IGZ1bmN0aW9uKHcpIHtcblx0XHRcdHJldHVybiB3ID09PSAxO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBjb21wdXRlQm9vbGVhbihwYXRoMSwgcGF0aDIsIG9wZXJhdGlvbikge1xuXHRcdHZhciBvcGVyYXRvciA9IG9wZXJhdG9yc1tvcGVyYXRpb25dO1xuXHRcdGZ1bmN0aW9uIHByZXBhcmVQYXRoKHBhdGgpIHtcblx0XHRcdHJldHVybiBwYXRoLmNsb25lKGZhbHNlKS5yZWR1Y2UoKS5yZW9yaWVudCgpLnRyYW5zZm9ybShudWxsLCB0cnVlLFxuXHRcdFx0XHRcdHRydWUpO1xuXHRcdH1cblxuXHRcdHZhciBfcGF0aDEgPSBwcmVwYXJlUGF0aChwYXRoMSksXG5cdFx0XHRfcGF0aDIgPSBwYXRoMiAmJiBwYXRoMSAhPT0gcGF0aDIgJiYgcHJlcGFyZVBhdGgocGF0aDIpO1xuXHRcdGlmIChfcGF0aDIgJiYgL14oc3VidHJhY3R8ZXhjbHVkZSkkLy50ZXN0KG9wZXJhdGlvbilcblx0XHRcdFx0XiAoX3BhdGgyLmlzQ2xvY2t3aXNlKCkgIT09IF9wYXRoMS5pc0Nsb2Nrd2lzZSgpKSlcblx0XHRcdF9wYXRoMi5yZXZlcnNlKCk7XG5cdFx0c3BsaXRQYXRoKF9wYXRoMS5nZXRJbnRlcnNlY3Rpb25zKF9wYXRoMiwgbnVsbCwgdHJ1ZSkpO1xuXG5cdFx0dmFyIGNoYWluID0gW10sXG5cdFx0XHRzZWdtZW50cyA9IFtdLFxuXHRcdFx0bW9ub0N1cnZlcyA9IFtdLFxuXHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMDE7XG5cblx0XHRmdW5jdGlvbiBjb2xsZWN0KHBhdGhzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgcGF0aCA9IHBhdGhzW2ldO1xuXHRcdFx0XHRzZWdtZW50cy5wdXNoLmFwcGx5KHNlZ21lbnRzLCBwYXRoLl9zZWdtZW50cyk7XG5cdFx0XHRcdG1vbm9DdXJ2ZXMucHVzaC5hcHBseShtb25vQ3VydmVzLCBwYXRoLl9nZXRNb25vQ3VydmVzKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbGxlY3QoX3BhdGgxLl9jaGlsZHJlbiB8fCBbX3BhdGgxXSk7XG5cdFx0aWYgKF9wYXRoMilcblx0XHRcdGNvbGxlY3QoX3BhdGgyLl9jaGlsZHJlbiB8fCBbX3BhdGgyXSk7XG5cdFx0c2VnbWVudHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIgX2EgPSBhLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdF9iID0gYi5faW50ZXJzZWN0aW9uO1xuXHRcdFx0cmV0dXJuICFfYSAmJiAhX2IgfHwgX2EgJiYgX2IgPyAwIDogX2EgPyAtMSA6IDE7XG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fd2luZGluZyAhPSBudWxsKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGNoYWluLmxlbmd0aCA9IDA7XG5cdFx0XHR2YXIgc3RhcnRTZWcgPSBzZWdtZW50LFxuXHRcdFx0XHR0b3RhbExlbmd0aCA9IDAsXG5cdFx0XHRcdHdpbmRpbmdTdW0gPSAwO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gc2VnbWVudC5nZXRDdXJ2ZSgpLmdldExlbmd0aCgpO1xuXHRcdFx0XHRjaGFpbi5wdXNoKHsgc2VnbWVudDogc2VnbWVudCwgbGVuZ3RoOiBsZW5ndGggfSk7XG5cdFx0XHRcdHRvdGFsTGVuZ3RoICs9IGxlbmd0aDtcblx0XHRcdFx0c2VnbWVudCA9IHNlZ21lbnQuZ2V0TmV4dCgpO1xuXHRcdFx0fSB3aGlsZSAoc2VnbWVudCAmJiAhc2VnbWVudC5faW50ZXJzZWN0aW9uICYmIHNlZ21lbnQgIT09IHN0YXJ0U2VnKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG5cdFx0XHRcdHZhciBsZW5ndGggPSB0b3RhbExlbmd0aCAqIChqICsgMSkgLyA0O1xuXHRcdFx0XHRmb3IgKHZhciBrID0gMCwgbSA9IGNoYWluLmxlbmd0aDsgayA8IG07IGsrKykge1xuXHRcdFx0XHRcdHZhciBub2RlID0gY2hhaW5ba10sXG5cdFx0XHRcdFx0XHRjdXJ2ZUxlbmd0aCA9IG5vZGUubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChsZW5ndGggPD0gY3VydmVMZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmIChsZW5ndGggPCB0b2xlcmFuY2Vcblx0XHRcdFx0XHRcdFx0XHR8fCBjdXJ2ZUxlbmd0aCAtIGxlbmd0aCA8IHRvbGVyYW5jZSlcblx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gY3VydmVMZW5ndGggLyAyO1xuXHRcdFx0XHRcdFx0dmFyIGN1cnZlID0gbm9kZS5zZWdtZW50LmdldEN1cnZlKCksXG5cdFx0XHRcdFx0XHRcdHB0ID0gY3VydmUuZ2V0UG9pbnRBdChsZW5ndGgpLFxuXHRcdFx0XHRcdFx0XHRob3IgPSBjdXJ2ZS5pc0xpbmVhcigpICYmIE1hdGguYWJzKGN1cnZlXG5cdFx0XHRcdFx0XHRcdFx0XHQuZ2V0VGFuZ2VudEF0KDAuNSwgdHJ1ZSkueSkgPCB0b2xlcmFuY2UsXG5cdFx0XHRcdFx0XHRcdHBhdGggPSBjdXJ2ZS5fcGF0aDtcblx0XHRcdFx0XHRcdGlmIChwYXRoLl9wYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpXG5cdFx0XHRcdFx0XHRcdHBhdGggPSBwYXRoLl9wYXJlbnQ7XG5cdFx0XHRcdFx0XHR3aW5kaW5nU3VtICs9IG9wZXJhdGlvbiA9PT0gJ3N1YnRyYWN0JyAmJiBfcGF0aDJcblx0XHRcdFx0XHRcdFx0JiYgKHBhdGggPT09IF9wYXRoMSAmJiBfcGF0aDIuX2dldFdpbmRpbmcocHQsIGhvcilcblx0XHRcdFx0XHRcdFx0fHwgcGF0aCA9PT0gX3BhdGgyICYmICFfcGF0aDEuX2dldFdpbmRpbmcocHQsIGhvcikpXG5cdFx0XHRcdFx0XHRcdD8gMFxuXHRcdFx0XHRcdFx0XHQ6IGdldFdpbmRpbmcocHQsIG1vbm9DdXJ2ZXMsIGhvcik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGVuZ3RoIC09IGN1cnZlTGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgd2luZGluZyA9IE1hdGgucm91bmQod2luZGluZ1N1bSAvIDMpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IGNoYWluLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuXHRcdFx0XHRjaGFpbltqXS5zZWdtZW50Ll93aW5kaW5nID0gd2luZGluZztcblx0XHR9XG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBDb21wb3VuZFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJlc3VsdC5pbnNlcnRBYm92ZShwYXRoMSk7XG5cdFx0cmVzdWx0LmFkZENoaWxkcmVuKHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yKSwgdHJ1ZSk7XG5cdFx0cmVzdWx0ID0gcmVzdWx0LnJlZHVjZSgpO1xuXHRcdHJlc3VsdC5zZXRTdHlsZShwYXRoMS5fc3R5bGUpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzcGxpdFBhdGgoaW50ZXJzZWN0aW9ucykge1xuXHRcdHZhciB0TWluID0gMC4wMDAwMDEsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRsaW5lYXJIYW5kbGVzO1xuXG5cdFx0ZnVuY3Rpb24gcmVzZXRMaW5lYXIoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVhckhhbmRsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRsaW5lYXJIYW5kbGVzW2ldLnNldCgwLCAwKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gaW50ZXJzZWN0aW9ucy5sZW5ndGggLSAxLCBjdXJ2ZSwgcHJldjsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBsb2MgPSBpbnRlcnNlY3Rpb25zW2ldLFxuXHRcdFx0XHR0ID0gbG9jLl9wYXJhbWV0ZXI7XG5cdFx0XHRpZiAocHJldiAmJiBwcmV2Ll9jdXJ2ZSA9PT0gbG9jLl9jdXJ2ZSAmJiBwcmV2Ll9wYXJhbWV0ZXIgPiAwKSB7XG5cdFx0XHRcdHQgLz0gcHJldi5fcGFyYW1ldGVyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VydmUgPSBsb2MuX2N1cnZlO1xuXHRcdFx0XHRpZiAobGluZWFySGFuZGxlcylcblx0XHRcdFx0XHRyZXNldExpbmVhcigpO1xuXHRcdFx0XHRsaW5lYXJIYW5kbGVzID0gY3VydmUuaXNMaW5lYXIoKSA/IFtcblx0XHRcdFx0XHRcdGN1cnZlLl9zZWdtZW50MS5faGFuZGxlT3V0LFxuXHRcdFx0XHRcdFx0Y3VydmUuX3NlZ21lbnQyLl9oYW5kbGVJblxuXHRcdFx0XHRcdF0gOiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG5ld0N1cnZlLFxuXHRcdFx0XHRzZWdtZW50O1xuXHRcdFx0aWYgKG5ld0N1cnZlID0gY3VydmUuZGl2aWRlKHQsIHRydWUsIHRydWUpKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBuZXdDdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHRcdGN1cnZlID0gbmV3Q3VydmUuZ2V0UHJldmlvdXMoKTtcblx0XHRcdFx0aWYgKGxpbmVhckhhbmRsZXMpXG5cdFx0XHRcdFx0bGluZWFySGFuZGxlcy5wdXNoKHNlZ21lbnQuX2hhbmRsZU91dCwgc2VnbWVudC5faGFuZGxlSW4pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VnbWVudCA9IHQgPCB0TWluXG5cdFx0XHRcdFx0PyBjdXJ2ZS5fc2VnbWVudDFcblx0XHRcdFx0XHQ6IHQgPiB0TWF4XG5cdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MlxuXHRcdFx0XHRcdFx0OiBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHQpIDwgY3VydmUuZ2V0UGFydExlbmd0aCh0LCAxKVxuXHRcdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHRcdFx0XHQ6IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH1cblx0XHRcdHNlZ21lbnQuX2ludGVyc2VjdGlvbiA9IGxvYy5nZXRJbnRlcnNlY3Rpb24oKTtcblx0XHRcdGxvYy5fc2VnbWVudCA9IHNlZ21lbnQ7XG5cdFx0XHRwcmV2ID0gbG9jO1xuXHRcdH1cblx0XHRpZiAobGluZWFySGFuZGxlcylcblx0XHRcdHJlc2V0TGluZWFyKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRXaW5kaW5nKHBvaW50LCBjdXJ2ZXMsIGhvcml6b250YWwsIHRlc3RDb250YWlucykge1xuXHRcdHZhciB0b2xlcmFuY2UgPSAwLjAwMDAwMSxcblx0XHRcdHRNaW4gPSB0b2xlcmFuY2UsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRweCA9IHBvaW50LngsXG5cdFx0XHRweSA9IHBvaW50LnksXG5cdFx0XHR3aW5kTGVmdCA9IDAsXG5cdFx0XHR3aW5kUmlnaHQgPSAwLFxuXHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdGFicyA9IE1hdGguYWJzO1xuXHRcdGlmIChob3Jpem9udGFsKSB7XG5cdFx0XHR2YXIgeVRvcCA9IC1JbmZpbml0eSxcblx0XHRcdFx0eUJvdHRvbSA9IEluZmluaXR5LFxuXHRcdFx0XHR5QmVmb3JlID0gcHkgLSB0b2xlcmFuY2UsXG5cdFx0XHRcdHlBZnRlciA9IHB5ICsgdG9sZXJhbmNlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBjdXJ2ZXNbaV0udmFsdWVzO1xuXHRcdFx0XHRpZiAoQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDAsIHB4LCByb290cywgMCwgMSkgPiAwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IHJvb3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IEN1cnZlLmdldFBvaW50KHZhbHVlcywgcm9vdHNbal0pLnk7XG5cdFx0XHRcdFx0XHRpZiAoeSA8IHlCZWZvcmUgJiYgeSA+IHlUb3ApIHtcblx0XHRcdFx0XHRcdFx0eVRvcCA9IHk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHkgPiB5QWZ0ZXIgJiYgeSA8IHlCb3R0b20pIHtcblx0XHRcdFx0XHRcdFx0eUJvdHRvbSA9IHk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR5VG9wID0gKHlUb3AgKyBweSkgLyAyO1xuXHRcdFx0eUJvdHRvbSA9ICh5Qm90dG9tICsgcHkpIC8gMjtcblx0XHRcdGlmICh5VG9wID4gLUluZmluaXR5KVxuXHRcdFx0XHR3aW5kTGVmdCA9IGdldFdpbmRpbmcobmV3IFBvaW50KHB4LCB5VG9wKSwgY3VydmVzKTtcblx0XHRcdGlmICh5Qm90dG9tIDwgSW5maW5pdHkpXG5cdFx0XHRcdHdpbmRSaWdodCA9IGdldFdpbmRpbmcobmV3IFBvaW50KHB4LCB5Qm90dG9tKSwgY3VydmVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHhCZWZvcmUgPSBweCAtIHRvbGVyYW5jZSxcblx0XHRcdFx0eEFmdGVyID0gcHggKyB0b2xlcmFuY2U7XG5cdFx0XHR2YXIgc3RhcnRDb3VudGVkID0gZmFsc2UsXG5cdFx0XHRcdHByZXZDdXJ2ZSxcblx0XHRcdFx0cHJldlQ7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2ldLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGN1cnZlLnZhbHVlcyxcblx0XHRcdFx0XHR3aW5kaW5nID0gY3VydmUud2luZGluZztcblx0XHRcdFx0aWYgKHdpbmRpbmcgJiYgKHdpbmRpbmcgPT09IDFcblx0XHRcdFx0XHRcdCYmIHB5ID49IHZhbHVlc1sxXSAmJiBweSA8PSB2YWx1ZXNbN11cblx0XHRcdFx0XHRcdHx8IHB5ID49IHZhbHVlc1s3XSAmJiBweSA8PSB2YWx1ZXNbMV0pXG5cdFx0XHRcdFx0JiYgQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDEsIHB5LCByb290cywgMCwgMSkgPT09IDEpIHtcblx0XHRcdFx0XHR2YXIgdCA9IHJvb3RzWzBdO1xuXHRcdFx0XHRcdGlmICghKFxuXHRcdFx0XHRcdFx0dCA+IHRNYXggJiYgc3RhcnRDb3VudGVkICYmIGN1cnZlLm5leHQgIT09IGN1cnZlc1tpICsgMV1cblx0XHRcdFx0XHRcdHx8IHQgPCB0TWluICYmIHByZXZUID4gdE1heFxuXHRcdFx0XHRcdFx0XHQmJiBjdXJ2ZS5wcmV2aW91cyA9PT0gcHJldkN1cnZlKSkge1xuXHRcdFx0XHRcdFx0dmFyIHggPSBDdXJ2ZS5nZXRQb2ludCh2YWx1ZXMsIHQpLngsXG5cdFx0XHRcdFx0XHRcdHNsb3BlID0gQ3VydmUuZ2V0VGFuZ2VudCh2YWx1ZXMsIHQpLnksXG5cdFx0XHRcdFx0XHRcdGNvdW50ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKHNsb3BlKSAmJiAhQ3VydmUuaXNMaW5lYXIodmFsdWVzKVxuXHRcdFx0XHRcdFx0XHRcdHx8IHQgPCB0TWluICYmIHNsb3BlICogQ3VydmUuZ2V0VGFuZ2VudChcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnZlLnByZXZpb3VzLnZhbHVlcywgMSkueSA8IDBcblx0XHRcdFx0XHRcdFx0XHR8fCB0ID4gdE1heCAmJiBzbG9wZSAqIEN1cnZlLmdldFRhbmdlbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJ2ZS5uZXh0LnZhbHVlcywgMCkueSA8IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKHRlc3RDb250YWlucyAmJiB4ID49IHhCZWZvcmUgJiYgeCA8PSB4QWZ0ZXIpIHtcblx0XHRcdFx0XHRcdFx0XHQrK3dpbmRMZWZ0O1xuXHRcdFx0XHRcdFx0XHRcdCsrd2luZFJpZ2h0O1xuXHRcdFx0XHRcdFx0XHRcdGNvdW50ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHggPD0geEJlZm9yZSkge1xuXHRcdFx0XHRcdFx0XHR3aW5kTGVmdCArPSB3aW5kaW5nO1xuXHRcdFx0XHRcdFx0XHRjb3VudGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoeCA+PSB4QWZ0ZXIpIHtcblx0XHRcdFx0XHRcdFx0d2luZFJpZ2h0ICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0XHRcdGNvdW50ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGN1cnZlLnByZXZpb3VzICE9PSBjdXJ2ZXNbaSAtIDFdKVxuXHRcdFx0XHRcdFx0XHRzdGFydENvdW50ZWQgPSB0IDwgdE1pbiAmJiBjb3VudGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcmV2Q3VydmUgPSBjdXJ2ZTtcblx0XHRcdFx0XHRwcmV2VCA9IHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIE1hdGgubWF4KGFicyh3aW5kTGVmdCksIGFicyh3aW5kUmlnaHQpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yLCBzZWxmT3ApIHtcblx0XHR2YXIgcGF0aHMgPSBbXSxcblx0XHRcdHRNaW4gPSAwLjAwMDAwMSxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRmb3IgKHZhciBpID0gMCwgc2VnLCBzdGFydFNlZywgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c2VnID0gc3RhcnRTZWcgPSBzZWdtZW50c1tpXTtcblx0XHRcdGlmIChzZWcuX3Zpc2l0ZWQgfHwgIW9wZXJhdG9yKHNlZy5fd2luZGluZykpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0dmFyIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCksXG5cdFx0XHRcdGludGVyID0gc2VnLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdHN0YXJ0SW50ZXJTZWcgPSBpbnRlciAmJiBpbnRlci5fc2VnbWVudCxcblx0XHRcdFx0YWRkZWQgPSBmYWxzZSxcblx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdGRvIHtcblx0XHRcdFx0dmFyIGhhbmRsZUluID0gZGlyID4gMCA/IHNlZy5faGFuZGxlSW4gOiBzZWcuX2hhbmRsZU91dCxcblx0XHRcdFx0XHRoYW5kbGVPdXQgPSBkaXIgPiAwID8gc2VnLl9oYW5kbGVPdXQgOiBzZWcuX2hhbmRsZUluLFxuXHRcdFx0XHRcdGludGVyU2VnO1xuXHRcdFx0XHRpZiAoYWRkZWQgJiYgKCFvcGVyYXRvcihzZWcuX3dpbmRpbmcpIHx8IHNlbGZPcClcblx0XHRcdFx0XHRcdCYmIChpbnRlciA9IHNlZy5faW50ZXJzZWN0aW9uKVxuXHRcdFx0XHRcdFx0JiYgKGludGVyU2VnID0gaW50ZXIuX3NlZ21lbnQpXG5cdFx0XHRcdFx0XHQmJiBpbnRlclNlZyAhPT0gc3RhcnRTZWcpIHtcblx0XHRcdFx0XHRpZiAoc2VsZk9wKSB7XG5cdFx0XHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSBpbnRlclNlZy5fdmlzaXRlZDtcblx0XHRcdFx0XHRcdHNlZyA9IGludGVyU2VnO1xuXHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIGMxID0gc2VnLmdldEN1cnZlKCk7XG5cdFx0XHRcdFx0XHRpZiAoZGlyID4gMClcblx0XHRcdFx0XHRcdFx0YzEgPSBjMS5nZXRQcmV2aW91cygpO1xuXHRcdFx0XHRcdFx0dmFyIHQxID0gYzEuZ2V0VGFuZ2VudEF0KGRpciA8IDEgPyB0TWluIDogdE1heCwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdGM0ID0gaW50ZXJTZWcuZ2V0Q3VydmUoKSxcblx0XHRcdFx0XHRcdFx0YzMgPSBjNC5nZXRQcmV2aW91cygpLFxuXHRcdFx0XHRcdFx0XHR0MyA9IGMzLmdldFRhbmdlbnRBdCh0TWF4LCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0dDQgPSBjNC5nZXRUYW5nZW50QXQodE1pbiwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdHczID0gdDEuY3Jvc3ModDMpLFxuXHRcdFx0XHRcdFx0XHR3NCA9IHQxLmNyb3NzKHQ0KTtcblx0XHRcdFx0XHRcdGlmICh3MyAqIHc0ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjdXJ2ZSA9IHczIDwgdzQgPyBjMyA6IGM0LFxuXHRcdFx0XHRcdFx0XHRcdG5leHRDdXJ2ZSA9IG9wZXJhdG9yKGN1cnZlLl9zZWdtZW50MS5fd2luZGluZylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VydmVcblx0XHRcdFx0XHRcdFx0XHRcdDogdzMgPCB3NCA/IGM0IDogYzMsXG5cdFx0XHRcdFx0XHRcdFx0bmV4dFNlZyA9IG5leHRDdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHRcdFx0XHRcdGRpciA9IG5leHRDdXJ2ZSA9PT0gYzMgPyAtMSA6IDE7XG5cdFx0XHRcdFx0XHRcdGlmIChuZXh0U2VnLl92aXNpdGVkICYmIHNlZy5fcGF0aCAhPT0gbmV4dFNlZy5fcGF0aFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR8fCAhb3BlcmF0b3IobmV4dFNlZy5fd2luZGluZykpIHtcblx0XHRcdFx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNlZy5fdmlzaXRlZCA9IGludGVyU2VnLl92aXNpdGVkO1xuXHRcdFx0XHRcdFx0XHRcdHNlZyA9IGludGVyU2VnO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChuZXh0U2VnLl92aXNpdGVkKVxuXHRcdFx0XHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aGFuZGxlT3V0ID0gZGlyID4gMCA/IHNlZy5faGFuZGxlT3V0IDogc2VnLl9oYW5kbGVJbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXRoLmFkZChuZXcgU2VnbWVudChzZWcuX3BvaW50LCBhZGRlZCAmJiBoYW5kbGVJbiwgaGFuZGxlT3V0KSk7XG5cdFx0XHRcdGFkZGVkID0gdHJ1ZTtcblx0XHRcdFx0c2VnLl92aXNpdGVkID0gdHJ1ZTtcblx0XHRcdFx0c2VnID0gZGlyID4gMCA/IHNlZy5nZXROZXh0KCkgOiBzZWcuIGdldFByZXZpb3VzKCk7XG5cdFx0XHR9IHdoaWxlIChzZWcgJiYgIXNlZy5fdmlzaXRlZFxuXHRcdFx0XHRcdCYmIHNlZyAhPT0gc3RhcnRTZWcgJiYgc2VnICE9PSBzdGFydEludGVyU2VnXG5cdFx0XHRcdFx0JiYgKHNlZy5faW50ZXJzZWN0aW9uIHx8IG9wZXJhdG9yKHNlZy5fd2luZGluZykpKTtcblx0XHRcdGlmIChzZWcgJiYgKHNlZyA9PT0gc3RhcnRTZWcgfHwgc2VnID09PSBzdGFydEludGVyU2VnKSkge1xuXHRcdFx0XHRwYXRoLmZpcnN0U2VnbWVudC5zZXRIYW5kbGVJbigoc2VnID09PSBzdGFydEludGVyU2VnXG5cdFx0XHRcdFx0XHQ/IHN0YXJ0SW50ZXJTZWcgOiBzZWcpLl9oYW5kbGVJbik7XG5cdFx0XHRcdHBhdGguc2V0Q2xvc2VkKHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5sYXN0U2VnbWVudC5faGFuZGxlT3V0LnNldCgwLCAwKTtcblx0XHRcdH1cblx0XHRcdGlmIChwYXRoLl9zZWdtZW50cy5sZW5ndGggPlxuXHRcdFx0XHRcdChwYXRoLl9jbG9zZWQgPyBwYXRoLmlzTGluZWFyKCkgPyAyIDogMCA6IDEpKVxuXHRcdFx0XHRwYXRocy5wdXNoKHBhdGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHM7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9nZXRXaW5kaW5nOiBmdW5jdGlvbihwb2ludCwgaG9yaXpvbnRhbCwgdGVzdENvbnRhaW5zKSB7XG5cdFx0XHRyZXR1cm4gZ2V0V2luZGluZyhwb2ludCwgdGhpcy5fZ2V0TW9ub0N1cnZlcygpLFxuXHRcdFx0XHRcdGhvcml6b250YWwsIHRlc3RDb250YWlucyk7XG5cdFx0fSxcblxuXHRcdHVuaXRlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0ZUJvb2xlYW4odGhpcywgcGF0aCwgJ3VuaXRlJyk7XG5cdFx0fSxcblxuXHRcdGludGVyc2VjdDogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsICdpbnRlcnNlY3QnKTtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCAnc3VidHJhY3QnKTtcblx0XHR9LFxuXG5cdFx0ZXhjbHVkZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsICdleGNsdWRlJyk7XG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIG5ldyBHcm91cChbdGhpcy5zdWJ0cmFjdChwYXRoKSwgdGhpcy5pbnRlcnNlY3QocGF0aCldKTtcblx0XHR9XG5cdH07XG59KTtcblxuUGF0aC5pbmplY3Qoe1xuXHRfZ2V0TW9ub0N1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1vbm9DdXJ2ZXMgPSB0aGlzLl9tb25vQ3VydmVzLFxuXHRcdFx0cHJldkN1cnZlO1xuXG5cdFx0ZnVuY3Rpb24gaW5zZXJ0Q3VydmUodikge1xuXHRcdFx0dmFyIHkwID0gdlsxXSxcblx0XHRcdFx0eTEgPSB2WzddLFxuXHRcdFx0XHRjdXJ2ZSA9IHtcblx0XHRcdFx0XHR2YWx1ZXM6IHYsXG5cdFx0XHRcdFx0d2luZGluZzogeTAgPT09IHkxXG5cdFx0XHRcdFx0XHQ/IDBcblx0XHRcdFx0XHRcdDogeTAgPiB5MVxuXHRcdFx0XHRcdFx0XHQ/IC0xXG5cdFx0XHRcdFx0XHRcdDogMSxcblx0XHRcdFx0XHRwcmV2aW91czogcHJldkN1cnZlLFxuXHRcdFx0XHRcdG5leHQ6IG51bGxcblx0XHRcdFx0fTtcblx0XHRcdGlmIChwcmV2Q3VydmUpXG5cdFx0XHRcdHByZXZDdXJ2ZS5uZXh0ID0gY3VydmU7XG5cdFx0XHRtb25vQ3VydmVzLnB1c2goY3VydmUpO1xuXHRcdFx0cHJldkN1cnZlID0gY3VydmU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlQ3VydmUodikge1xuXHRcdFx0aWYgKEN1cnZlLmdldExlbmd0aCh2KSA9PT0gMClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIHkwID0gdlsxXSxcblx0XHRcdFx0eTEgPSB2WzNdLFxuXHRcdFx0XHR5MiA9IHZbNV0sXG5cdFx0XHRcdHkzID0gdls3XTtcblx0XHRcdGlmIChDdXJ2ZS5pc0xpbmVhcih2KSkge1xuXHRcdFx0XHRpbnNlcnRDdXJ2ZSh2KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhID0gMyAqICh5MSAtIHkyKSAtIHkwICsgeTMsXG5cdFx0XHRcdFx0YiA9IDIgKiAoeTAgKyB5MikgLSA0ICogeTEsXG5cdFx0XHRcdFx0YyA9IHkxIC0geTAsXG5cdFx0XHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMDEsXG5cdFx0XHRcdFx0cm9vdHMgPSBbXTtcblx0XHRcdFx0dmFyIGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzLCB0b2xlcmFuY2UsXG5cdFx0XHRcdFx0XHQxIC0gdG9sZXJhbmNlKTtcblx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB7XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUodik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm9vdHMuc29ydCgpO1xuXHRcdFx0XHRcdHZhciB0ID0gcm9vdHNbMF0sXG5cdFx0XHRcdFx0XHRwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2LCB0KTtcblx0XHRcdFx0XHRpbnNlcnRDdXJ2ZShwYXJ0c1swXSk7XG5cdFx0XHRcdFx0aWYgKGNvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0dCA9IChyb290c1sxXSAtIHQpIC8gKDEgLSB0KTtcblx0XHRcdFx0XHRcdHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHBhcnRzWzFdLCB0KTtcblx0XHRcdFx0XHRcdGluc2VydEN1cnZlKHBhcnRzWzBdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUocGFydHNbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFtb25vQ3VydmVzKSB7XG5cdFx0XHRtb25vQ3VydmVzID0gdGhpcy5fbW9ub0N1cnZlcyA9IFtdO1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGhhbmRsZUN1cnZlKGN1cnZlc1tpXS5nZXRWYWx1ZXMoKSk7XG5cdFx0XHRpZiAoIXRoaXMuX2Nsb3NlZCAmJiBzZWdtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdHZhciBwMSA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLl9wb2ludCxcblx0XHRcdFx0XHRwMiA9IHNlZ21lbnRzWzBdLl9wb2ludCxcblx0XHRcdFx0XHRwMXggPSBwMS5feCwgcDF5ID0gcDEuX3ksXG5cdFx0XHRcdFx0cDJ4ID0gcDIuX3gsIHAyeSA9IHAyLl95O1xuXHRcdFx0XHRoYW5kbGVDdXJ2ZShbcDF4LCBwMXksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDJ4LCBwMnldKTtcblx0XHRcdH1cblx0XHRcdGlmIChtb25vQ3VydmVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIGZpcnN0ID0gbW9ub0N1cnZlc1swXSxcblx0XHRcdFx0XHRsYXN0ID0gbW9ub0N1cnZlc1ttb25vQ3VydmVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRmaXJzdC5wcmV2aW91cyA9IGxhc3Q7XG5cdFx0XHRcdGxhc3QubmV4dCA9IGZpcnN0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbW9ub0N1cnZlcztcblx0fSxcblxuXHRnZXRJbnRlcmlvclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdHBvaW50ID0gYm91bmRzLmdldENlbnRlcih0cnVlKTtcblx0XHRpZiAoIXRoaXMuY29udGFpbnMocG9pbnQpKSB7XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5fZ2V0TW9ub0N1cnZlcygpLFxuXHRcdFx0XHRyb290cyA9IFtdLFxuXHRcdFx0XHR5ID0gcG9pbnQueSxcblx0XHRcdFx0eEludGVyY2VwdHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gY3VydmVzW2ldLnZhbHVlcztcblx0XHRcdFx0aWYgKChjdXJ2ZXNbaV0ud2luZGluZyA9PT0gMVxuXHRcdFx0XHRcdFx0JiYgeSA+PSB2YWx1ZXNbMV0gJiYgeSA8PSB2YWx1ZXNbN11cblx0XHRcdFx0XHRcdHx8IHkgPj0gdmFsdWVzWzddICYmIHkgPD0gdmFsdWVzWzFdKVxuXHRcdFx0XHRcdFx0JiYgQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDEsIHksIHJvb3RzLCAwLCAxKSA+IDApIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gcm9vdHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG5cdFx0XHRcdFx0XHR4SW50ZXJjZXB0cy5wdXNoKEN1cnZlLmdldFBvaW50KHZhbHVlcywgcm9vdHNbal0pLngpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh4SW50ZXJjZXB0cy5sZW5ndGggPiAxKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cG9pbnQueCA9ICh4SW50ZXJjZXB0c1swXSArIHhJbnRlcmNlcHRzWzFdKSAvIDI7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludDtcblx0fSxcblxuXHRyZW9yaWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zZXRDbG9ja3dpc2UodHJ1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5Db21wb3VuZFBhdGguaW5qZWN0KHtcblx0X2dldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0bW9ub0N1cnZlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bW9ub0N1cnZlcy5wdXNoLmFwcGx5KG1vbm9DdXJ2ZXMsIGNoaWxkcmVuW2ldLl9nZXRNb25vQ3VydmVzKCkpO1xuXHRcdHJldHVybiBtb25vQ3VydmVzO1xuXHR9LFxuXG5cdHJlb3JpZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLnJlbW92ZUNoaWxkcmVuKCkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYi5nZXRCb3VuZHMoKS5nZXRBcmVhKCkgLSBhLmdldEJvdW5kcygpLmdldEFyZWEoKTtcblx0XHR9KTtcblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5hZGRDaGlsZHJlbihjaGlsZHJlbik7XG5cdFx0XHR2YXIgY2xvY2t3aXNlID0gY2hpbGRyZW5bMF0uaXNDbG9ja3dpc2UoKTtcblx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwb2ludCA9IGNoaWxkcmVuW2ldLmdldEludGVyaW9yUG9pbnQoKSxcblx0XHRcdFx0XHRjb3VudGVycyA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0XHRpZiAoY2hpbGRyZW5bal0uY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHRcdFx0Y291bnRlcnMrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRDbG9ja3dpc2UoY291bnRlcnMgJSAyID09PSAwICYmIGNsb2Nrd2lzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxudmFyIFBhdGhJdGVyYXRvciA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aEl0ZXJhdG9yJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBtYXhSZWN1cnNpb24sIHRvbGVyYW5jZSwgbWF0cml4KSB7XG5cdFx0dmFyIGN1cnZlcyA9IFtdLFxuXHRcdFx0cGFydHMgPSBbXSxcblx0XHRcdGxlbmd0aCA9IDAsXG5cdFx0XHRtaW5EaWZmZXJlbmNlID0gMSAvIChtYXhSZWN1cnNpb24gfHwgMzIpLFxuXHRcdFx0c2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdHNlZ21lbnQxID0gc2VnbWVudHNbMF0sXG5cdFx0XHRzZWdtZW50MjtcblxuXHRcdGZ1bmN0aW9uIGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mikge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0VmFsdWVzKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KTtcblx0XHRcdGN1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdGNvbXB1dGVQYXJ0cyhjdXJ2ZSwgc2VnbWVudDEuX2luZGV4LCAwLCAxKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb21wdXRlUGFydHMoY3VydmUsIGluZGV4LCBtaW5ULCBtYXhUKSB7XG5cdFx0XHRpZiAoKG1heFQgLSBtaW5UKSA+IG1pbkRpZmZlcmVuY2Vcblx0XHRcdFx0XHQmJiAhQ3VydmUuaXNGbGF0RW5vdWdoKGN1cnZlLCB0b2xlcmFuY2UgfHwgMC4yNSkpIHtcblx0XHRcdFx0dmFyIHNwbGl0ID0gQ3VydmUuc3ViZGl2aWRlKGN1cnZlKSxcblx0XHRcdFx0XHRoYWxmVCA9IChtaW5UICsgbWF4VCkgLyAyO1xuXHRcdFx0XHRjb21wdXRlUGFydHMoc3BsaXRbMF0sIGluZGV4LCBtaW5ULCBoYWxmVCk7XG5cdFx0XHRcdGNvbXB1dGVQYXJ0cyhzcGxpdFsxXSwgaW5kZXgsIGhhbGZULCBtYXhUKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB4ID0gY3VydmVbNl0gLSBjdXJ2ZVswXSxcblx0XHRcdFx0XHR5ID0gY3VydmVbN10gLSBjdXJ2ZVsxXSxcblx0XHRcdFx0XHRkaXN0ID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRpZiAoZGlzdCA+IDAuMDAwMDAxKSB7XG5cdFx0XHRcdFx0bGVuZ3RoICs9IGRpc3Q7XG5cdFx0XHRcdFx0cGFydHMucHVzaCh7XG5cdFx0XHRcdFx0XHRvZmZzZXQ6IGxlbmd0aCxcblx0XHRcdFx0XHRcdHZhbHVlOiBtYXhULFxuXHRcdFx0XHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c2VnbWVudDIgPSBzZWdtZW50c1tpXTtcblx0XHRcdGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mik7XG5cdFx0XHRzZWdtZW50MSA9IHNlZ21lbnQyO1xuXHRcdH1cblx0XHRpZiAocGF0aC5fY2xvc2VkKVxuXHRcdFx0YWRkQ3VydmUoc2VnbWVudDIsIHNlZ21lbnRzWzBdKTtcblxuXHRcdHRoaXMuY3VydmVzID0gY3VydmVzO1xuXHRcdHRoaXMucGFydHMgPSBwYXJ0cztcblx0XHR0aGlzLmxlbmd0aCA9IGxlbmd0aDtcblx0XHR0aGlzLmluZGV4ID0gMDtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0dmFyIGksIGogPSB0aGlzLmluZGV4O1xuXHRcdGZvciAoOzspIHtcblx0XHRcdGkgPSBqO1xuXHRcdFx0aWYgKGogPT0gMCB8fCB0aGlzLnBhcnRzWy0tal0ub2Zmc2V0IDwgb2Zmc2V0KVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Zm9yICh2YXIgbCA9IHRoaXMucGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcGFydCA9IHRoaXMucGFydHNbaV07XG5cdFx0XHRpZiAocGFydC5vZmZzZXQgPj0gb2Zmc2V0KSB7XG5cdFx0XHRcdHRoaXMuaW5kZXggPSBpO1xuXHRcdFx0XHR2YXIgcHJldiA9IHRoaXMucGFydHNbaSAtIDFdO1xuXHRcdFx0XHR2YXIgcHJldlZhbCA9IHByZXYgJiYgcHJldi5pbmRleCA9PSBwYXJ0LmluZGV4ID8gcHJldi52YWx1ZSA6IDAsXG5cdFx0XHRcdFx0cHJldkxlbiA9IHByZXYgPyBwcmV2Lm9mZnNldCA6IDA7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dmFsdWU6IHByZXZWYWwgKyAocGFydC52YWx1ZSAtIHByZXZWYWwpXG5cdFx0XHRcdFx0XHQqIChvZmZzZXQgLSBwcmV2TGVuKSAvIChwYXJ0Lm9mZnNldCAtIHByZXZMZW4pLFxuXHRcdFx0XHRcdGluZGV4OiBwYXJ0LmluZGV4XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBwYXJ0ID0gdGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aCAtIDFdO1xuXHRcdHJldHVybiB7XG5cdFx0XHR2YWx1ZTogMSxcblx0XHRcdGluZGV4OiBwYXJ0LmluZGV4XG5cdFx0fTtcblx0fSxcblxuXHRkcmF3UGFydDogZnVuY3Rpb24oY3R4LCBmcm9tLCB0bykge1xuXHRcdGZyb20gPSB0aGlzLmdldFBhcmFtZXRlckF0KGZyb20pO1xuXHRcdHRvID0gdGhpcy5nZXRQYXJhbWV0ZXJBdCh0byk7XG5cdFx0Zm9yICh2YXIgaSA9IGZyb20uaW5kZXg7IGkgPD0gdG8uaW5kZXg7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0UGFydCh0aGlzLmN1cnZlc1tpXSxcblx0XHRcdFx0XHRpID09IGZyb20uaW5kZXggPyBmcm9tLnZhbHVlIDogMCxcblx0XHRcdFx0XHRpID09IHRvLmluZGV4ID8gdG8udmFsdWUgOiAxKTtcblx0XHRcdGlmIChpID09IGZyb20uaW5kZXgpXG5cdFx0XHRcdGN0eC5tb3ZlVG8oY3VydmVbMF0sIGN1cnZlWzFdKTtcblx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvLmFwcGx5KGN0eCwgY3VydmUuc2xpY2UoMikpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKEN1cnZlLmV2YWx1YXRlTWV0aG9kcyxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0LCB3ZWlnaHRlZCkge1xuXHRcdFx0dmFyIHBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXJBdChvZmZzZXQpO1xuXHRcdFx0cmV0dXJuIEN1cnZlW25hbWVdKHRoaXMuY3VydmVzW3BhcmFtLmluZGV4XSwgcGFyYW0udmFsdWUsIHdlaWdodGVkKTtcblx0XHR9O1xuXHR9LCB7fSlcbik7XG5cbnZhciBQYXRoRml0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBlcnJvcikge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyA9IFtdLFxuXHRcdFx0c2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdHByZXY7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwb2ludCA9IHNlZ21lbnRzW2ldLnBvaW50LmNsb25lKCk7XG5cdFx0XHRpZiAoIXByZXYgfHwgIXByZXYuZXF1YWxzKHBvaW50KSkge1xuXHRcdFx0XHRwb2ludHMucHVzaChwb2ludCk7XG5cdFx0XHRcdHByZXYgPSBwb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocGF0aC5fY2xvc2VkKSB7XG5cdFx0XHR0aGlzLmNsb3NlZCA9IHRydWU7XG5cdFx0XHRwb2ludHMudW5zaGlmdChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcblx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1sxXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5lcnJvciA9IGVycm9yO1xuXHR9LFxuXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuXHRcdFx0bGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cyA9IGxlbmd0aCA+IDBcblx0XHRcdFx0XHQ/IFtuZXcgU2VnbWVudChwb2ludHNbMF0pXSA6IFtdO1xuXHRcdGlmIChsZW5ndGggPiAxKVxuXHRcdFx0dGhpcy5maXRDdWJpYygwLCBsZW5ndGggLSAxLFxuXHRcdFx0XHRwb2ludHNbMV0uc3VidHJhY3QocG9pbnRzWzBdKS5ub3JtYWxpemUoKSxcblx0XHRcdFx0cG9pbnRzW2xlbmd0aCAtIDJdLnN1YnRyYWN0KHBvaW50c1tsZW5ndGggLSAxXSkubm9ybWFsaXplKCkpO1xuXG5cdFx0aWYgKHRoaXMuY2xvc2VkKSB7XG5cdFx0XHRzZWdtZW50cy5zaGlmdCgpO1xuXHRcdFx0c2VnbWVudHMucG9wKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ21lbnRzO1xuXHR9LFxuXG5cdGZpdEN1YmljOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdGFuMSwgdGFuMikge1xuXHRcdGlmIChsYXN0IC0gZmlyc3QgPT0gMSkge1xuXHRcdFx0dmFyIHB0MSA9IHRoaXMucG9pbnRzW2ZpcnN0XSxcblx0XHRcdFx0cHQyID0gdGhpcy5wb2ludHNbbGFzdF0sXG5cdFx0XHRcdGRpc3QgPSBwdDEuZ2V0RGlzdGFuY2UocHQyKSAvIDM7XG5cdFx0XHR0aGlzLmFkZEN1cnZlKFtwdDEsIHB0MS5hZGQodGFuMS5ub3JtYWxpemUoZGlzdCkpLFxuXHRcdFx0XHRcdHB0Mi5hZGQodGFuMi5ub3JtYWxpemUoZGlzdCkpLCBwdDJdKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHVQcmltZSA9IHRoaXMuY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QpLFxuXHRcdFx0bWF4RXJyb3IgPSBNYXRoLm1heCh0aGlzLmVycm9yLCB0aGlzLmVycm9yICogdGhpcy5lcnJvciksXG5cdFx0XHRzcGxpdCxcblx0XHRcdHBhcmFtZXRlcnNJbk9yZGVyID0gdHJ1ZTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSA0OyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2VuZXJhdGVCZXppZXIoZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMik7XG5cdFx0XHR2YXIgbWF4ID0gdGhpcy5maW5kTWF4RXJyb3IoZmlyc3QsIGxhc3QsIGN1cnZlLCB1UHJpbWUpO1xuXHRcdFx0aWYgKG1heC5lcnJvciA8IHRoaXMuZXJyb3IgJiYgcGFyYW1ldGVyc0luT3JkZXIpIHtcblx0XHRcdFx0dGhpcy5hZGRDdXJ2ZShjdXJ2ZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNwbGl0ID0gbWF4LmluZGV4O1xuXHRcdFx0aWYgKG1heC5lcnJvciA+PSBtYXhFcnJvcilcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRwYXJhbWV0ZXJzSW5PcmRlciA9IHRoaXMucmVwYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QsIHVQcmltZSwgY3VydmUpO1xuXHRcdFx0bWF4RXJyb3IgPSBtYXguZXJyb3I7XG5cdFx0fVxuXHRcdHZhciBWMSA9IHRoaXMucG9pbnRzW3NwbGl0IC0gMV0uc3VidHJhY3QodGhpcy5wb2ludHNbc3BsaXRdKSxcblx0XHRcdFYyID0gdGhpcy5wb2ludHNbc3BsaXRdLnN1YnRyYWN0KHRoaXMucG9pbnRzW3NwbGl0ICsgMV0pLFxuXHRcdFx0dGFuQ2VudGVyID0gVjEuYWRkKFYyKS5kaXZpZGUoMikubm9ybWFsaXplKCk7XG5cdFx0dGhpcy5maXRDdWJpYyhmaXJzdCwgc3BsaXQsIHRhbjEsIHRhbkNlbnRlcik7XG5cdFx0dGhpcy5maXRDdWJpYyhzcGxpdCwgbGFzdCwgdGFuQ2VudGVyLm5lZ2F0ZSgpLCB0YW4yKTtcblx0fSxcblxuXHRhZGRDdXJ2ZTogZnVuY3Rpb24oY3VydmUpIHtcblx0XHR2YXIgcHJldiA9IHRoaXMuc2VnbWVudHNbdGhpcy5zZWdtZW50cy5sZW5ndGggLSAxXTtcblx0XHRwcmV2LnNldEhhbmRsZU91dChjdXJ2ZVsxXS5zdWJ0cmFjdChjdXJ2ZVswXSkpO1xuXHRcdHRoaXMuc2VnbWVudHMucHVzaChcblx0XHRcdFx0bmV3IFNlZ21lbnQoY3VydmVbM10sIGN1cnZlWzJdLnN1YnRyYWN0KGN1cnZlWzNdKSkpO1xuXHR9LFxuXG5cdGdlbmVyYXRlQmV6aWVyOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdVByaW1lLCB0YW4xLCB0YW4yKSB7XG5cdFx0dmFyIGVwc2lsb24gPSAxZS0xMixcblx0XHRcdHB0MSA9IHRoaXMucG9pbnRzW2ZpcnN0XSxcblx0XHRcdHB0MiA9IHRoaXMucG9pbnRzW2xhc3RdLFxuXHRcdFx0QyA9IFtbMCwgMF0sIFswLCAwXV0sXG5cdFx0XHRYID0gWzAsIDBdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXN0IC0gZmlyc3QgKyAxOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdSA9IHVQcmltZVtpXSxcblx0XHRcdFx0dCA9IDEgLSB1LFxuXHRcdFx0XHRiID0gMyAqIHUgKiB0LFxuXHRcdFx0XHRiMCA9IHQgKiB0ICogdCxcblx0XHRcdFx0YjEgPSBiICogdCxcblx0XHRcdFx0YjIgPSBiICogdSxcblx0XHRcdFx0YjMgPSB1ICogdSAqIHUsXG5cdFx0XHRcdGExID0gdGFuMS5ub3JtYWxpemUoYjEpLFxuXHRcdFx0XHRhMiA9IHRhbjIubm9ybWFsaXplKGIyKSxcblx0XHRcdFx0dG1wID0gdGhpcy5wb2ludHNbZmlyc3QgKyBpXVxuXHRcdFx0XHRcdC5zdWJ0cmFjdChwdDEubXVsdGlwbHkoYjAgKyBiMSkpXG5cdFx0XHRcdFx0LnN1YnRyYWN0KHB0Mi5tdWx0aXBseShiMiArIGIzKSk7XG5cdFx0XHRDWzBdWzBdICs9IGExLmRvdChhMSk7XG5cdFx0XHRDWzBdWzFdICs9IGExLmRvdChhMik7XG5cdFx0XHRDWzFdWzBdID0gQ1swXVsxXTtcblx0XHRcdENbMV1bMV0gKz0gYTIuZG90KGEyKTtcblx0XHRcdFhbMF0gKz0gYTEuZG90KHRtcCk7XG5cdFx0XHRYWzFdICs9IGEyLmRvdCh0bXApO1xuXHRcdH1cblxuXHRcdHZhciBkZXRDMEMxID0gQ1swXVswXSAqIENbMV1bMV0gLSBDWzFdWzBdICogQ1swXVsxXSxcblx0XHRcdGFscGhhMSwgYWxwaGEyO1xuXHRcdGlmIChNYXRoLmFicyhkZXRDMEMxKSA+IGVwc2lsb24pIHtcblx0XHRcdHZhciBkZXRDMFhcdD0gQ1swXVswXSAqIFhbMV1cdC0gQ1sxXVswXSAqIFhbMF0sXG5cdFx0XHRcdGRldFhDMVx0PSBYWzBdXHQgICogQ1sxXVsxXSAtIFhbMV1cdCAgKiBDWzBdWzFdO1xuXHRcdFx0YWxwaGExID0gZGV0WEMxIC8gZGV0QzBDMTtcblx0XHRcdGFscGhhMiA9IGRldEMwWCAvIGRldEMwQzE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjMCA9IENbMF1bMF0gKyBDWzBdWzFdLFxuXHRcdFx0XHRjMSA9IENbMV1bMF0gKyBDWzFdWzFdO1xuXHRcdFx0aWYgKE1hdGguYWJzKGMwKSA+IGVwc2lsb24pIHtcblx0XHRcdFx0YWxwaGExID0gYWxwaGEyID0gWFswXSAvIGMwO1xuXHRcdFx0fSBlbHNlIGlmIChNYXRoLmFicyhjMSkgPiBlcHNpbG9uKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IFhbMV0gLyBjMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHNlZ0xlbmd0aCA9IHB0Mi5nZXREaXN0YW5jZShwdDEpLFxuXHRcdFx0ZXBzID0gZXBzaWxvbiAqIHNlZ0xlbmd0aCxcblx0XHRcdGhhbmRsZTEsXG5cdFx0XHRoYW5kbGUyO1xuXHRcdGlmIChhbHBoYTEgPCBlcHMgfHwgYWxwaGEyIDwgZXBzKSB7XG5cdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBzZWdMZW5ndGggLyAzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGluZSA9IHB0Mi5zdWJ0cmFjdChwdDEpO1xuXHRcdFx0aGFuZGxlMSA9IHRhbjEubm9ybWFsaXplKGFscGhhMSk7XG5cdFx0XHRoYW5kbGUyID0gdGFuMi5ub3JtYWxpemUoYWxwaGEyKTtcblx0XHRcdGlmIChoYW5kbGUxLmRvdChsaW5lKSAtIGhhbmRsZTIuZG90KGxpbmUpID4gc2VnTGVuZ3RoICogc2VnTGVuZ3RoKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IHNlZ0xlbmd0aCAvIDM7XG5cdFx0XHRcdGhhbmRsZTEgPSBoYW5kbGUyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gW3B0MSwgcHQxLmFkZChoYW5kbGUxIHx8IHRhbjEubm9ybWFsaXplKGFscGhhMSkpLFxuXHRcdFx0XHRwdDIuYWRkKGhhbmRsZTIgfHwgdGFuMi5ub3JtYWxpemUoYWxwaGEyKSksIHB0Ml07XG5cdH0sXG5cblx0cmVwYXJhbWV0ZXJpemU6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB1LCBjdXJ2ZSkge1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdDsgaSA8PSBsYXN0OyBpKyspIHtcblx0XHRcdHVbaSAtIGZpcnN0XSA9IHRoaXMuZmluZFJvb3QoY3VydmUsIHRoaXMucG9pbnRzW2ldLCB1W2kgLSBmaXJzdF0pO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAodVtpXSA8PSB1W2kgLSAxXSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRmaW5kUm9vdDogZnVuY3Rpb24oY3VydmUsIHBvaW50LCB1KSB7XG5cdFx0dmFyIGN1cnZlMSA9IFtdLFxuXHRcdFx0Y3VydmUyID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gMjsgaSsrKSB7XG5cdFx0XHRjdXJ2ZTFbaV0gPSBjdXJ2ZVtpICsgMV0uc3VidHJhY3QoY3VydmVbaV0pLm11bHRpcGx5KDMpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSAxOyBpKyspIHtcblx0XHRcdGN1cnZlMltpXSA9IGN1cnZlMVtpICsgMV0uc3VidHJhY3QoY3VydmUxW2ldKS5tdWx0aXBseSgyKTtcblx0XHR9XG5cdFx0dmFyIHB0ID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdSksXG5cdFx0XHRwdDEgPSB0aGlzLmV2YWx1YXRlKDIsIGN1cnZlMSwgdSksXG5cdFx0XHRwdDIgPSB0aGlzLmV2YWx1YXRlKDEsIGN1cnZlMiwgdSksXG5cdFx0XHRkaWZmID0gcHQuc3VidHJhY3QocG9pbnQpLFxuXHRcdFx0ZGYgPSBwdDEuZG90KHB0MSkgKyBkaWZmLmRvdChwdDIpO1xuXHRcdGlmIChNYXRoLmFicyhkZikgPCAwLjAwMDAwMSlcblx0XHRcdHJldHVybiB1O1xuXHRcdHJldHVybiB1IC0gZGlmZi5kb3QocHQxKSAvIGRmO1xuXHR9LFxuXG5cdGV2YWx1YXRlOiBmdW5jdGlvbihkZWdyZWUsIGN1cnZlLCB0KSB7XG5cdFx0dmFyIHRtcCA9IGN1cnZlLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPD0gZGVncmVlOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDw9IGRlZ3JlZSAtIGk7IGorKykge1xuXHRcdFx0XHR0bXBbal0gPSB0bXBbal0ubXVsdGlwbHkoMSAtIHQpLmFkZCh0bXBbaiArIDFdLm11bHRpcGx5KHQpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRtcFswXTtcblx0fSxcblxuXHRjaG9yZExlbmd0aFBhcmFtZXRlcml6ZTogZnVuY3Rpb24oZmlyc3QsIGxhc3QpIHtcblx0XHR2YXIgdSA9IFswXTtcblx0XHRmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3Q7IGkrKykge1xuXHRcdFx0dVtpIC0gZmlyc3RdID0gdVtpIC0gZmlyc3QgLSAxXVxuXHRcdFx0XHRcdCsgdGhpcy5wb2ludHNbaV0uZ2V0RGlzdGFuY2UodGhpcy5wb2ludHNbaSAtIDFdKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDEsIG0gPSBsYXN0IC0gZmlyc3Q7IGkgPD0gbTsgaSsrKSB7XG5cdFx0XHR1W2ldIC89IHVbbV07XG5cdFx0fVxuXHRcdHJldHVybiB1O1xuXHR9LFxuXG5cdGZpbmRNYXhFcnJvcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIGN1cnZlLCB1KSB7XG5cdFx0dmFyIGluZGV4ID0gTWF0aC5mbG9vcigobGFzdCAtIGZpcnN0ICsgMSkgLyAyKSxcblx0XHRcdG1heERpc3QgPSAwO1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcblx0XHRcdHZhciBQID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdVtpIC0gZmlyc3RdKTtcblx0XHRcdHZhciB2ID0gUC5zdWJ0cmFjdCh0aGlzLnBvaW50c1tpXSk7XG5cdFx0XHR2YXIgZGlzdCA9IHYueCAqIHYueCArIHYueSAqIHYueTtcblx0XHRcdGlmIChkaXN0ID49IG1heERpc3QpIHtcblx0XHRcdFx0bWF4RGlzdCA9IGRpc3Q7XG5cdFx0XHRcdGluZGV4ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGVycm9yOiBtYXhEaXN0LFxuXHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0fTtcblx0fVxufSk7XG5cbnZhciBUZXh0SXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnVGV4dEl0ZW0nLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjb250ZW50OiBudWxsXG5cdH0sXG5cdF9ib3VuZHNHZXR0ZXI6ICdnZXRCb3VuZHMnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRleHRJdGVtKGFyZykge1xuXHRcdHRoaXMuX2NvbnRlbnQgPSAnJztcblx0XHR0aGlzLl9saW5lcyA9IFtdO1xuXHRcdHZhciBoYXNQcm9wcyA9IGFyZyAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKVxuXHRcdFx0XHQmJiBhcmcueCA9PT0gdW5kZWZpbmVkICYmIGFyZy55ID09PSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5faW5pdGlhbGl6ZShoYXNQcm9wcyAmJiBhcmcsICFoYXNQcm9wcyAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudCA9PT0gaXRlbS5fY29udGVudDtcblx0fSxcblxuXHRfY2xvbmU6IGZ1bmN0aW9uIF9jbG9uZShjb3B5LCBpbnNlcnQsIGluY2x1ZGVNYXRyaXgpIHtcblx0XHRjb3B5LnNldENvbnRlbnQodGhpcy5fY29udGVudCk7XG5cdFx0cmV0dXJuIF9jbG9uZS5iYXNlLmNhbGwodGhpcywgY29weSwgaW5zZXJ0LCBpbmNsdWRlTWF0cml4KTtcblx0fSxcblxuXHRnZXRDb250ZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcblx0fSxcblxuXHRzZXRDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG5cdFx0dGhpcy5fY29udGVudCA9ICcnICsgY29udGVudDtcblx0XHR0aGlzLl9saW5lcyA9IHRoaXMuX2NvbnRlbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL21nKTtcblx0XHR0aGlzLl9jaGFuZ2VkKDI2NSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jb250ZW50O1xuXHR9LFxuXG5cdGdldENoYXJhY3RlclN0eWxlOiAnI2dldFN0eWxlJyxcblx0c2V0Q2hhcmFjdGVyU3R5bGU6ICcjc2V0U3R5bGUnLFxuXG5cdGdldFBhcmFncmFwaFN0eWxlOiAnI2dldFN0eWxlJyxcblx0c2V0UGFyYWdyYXBoU3R5bGU6ICcjc2V0U3R5bGUnXG59KTtcblxudmFyIFBvaW50VGV4dCA9IFRleHRJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BvaW50VGV4dCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnRUZXh0KCkge1xuXHRcdFRleHRJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShuZXcgUG9pbnRUZXh0KEl0ZW0uTk9fSU5TRVJUKSwgaW5zZXJ0KTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRQb2ludChwb2ludC54LCBwb2ludC55LCB0aGlzLCAnc2V0UG9pbnQnKTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMudHJhbnNsYXRlKHBvaW50LnN1YnRyYWN0KHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpKSk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICghdGhpcy5fY29udGVudClcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4KTtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGxpbmVzID0gdGhpcy5fbGluZXMsXG5cdFx0XHRsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuXHRcdFx0c2hhZG93Q29sb3IgPSBjdHguc2hhZG93Q29sb3I7XG5cdFx0Y3R4LmZvbnQgPSBzdHlsZS5nZXRGb250U3R5bGUoKTtcblx0XHRjdHgudGV4dEFsaWduID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvcjtcblx0XHRcdHZhciBsaW5lID0gbGluZXNbaV07XG5cdFx0XHRpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCAwLCAwKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0eWxlLmhhc1N0cm9rZSgpKVxuXHRcdFx0XHRjdHguc3Ryb2tlVGV4dChsaW5lLCAwLCAwKTtcblx0XHRcdGN0eC50cmFuc2xhdGUoMCwgbGVhZGluZyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRsaW5lcyA9IHRoaXMuX2xpbmVzLFxuXHRcdFx0bnVtTGluZXMgPSBsaW5lcy5sZW5ndGgsXG5cdFx0XHRqdXN0aWZpY2F0aW9uID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpLFxuXHRcdFx0bGVhZGluZyA9IHN0eWxlLmdldExlYWRpbmcoKSxcblx0XHRcdHdpZHRoID0gdGhpcy5nZXRWaWV3KCkuZ2V0VGV4dFdpZHRoKHN0eWxlLmdldEZvbnRTdHlsZSgpLCBsaW5lcyksXG5cdFx0XHR4ID0gMDtcblx0XHRpZiAoanVzdGlmaWNhdGlvbiAhPT0gJ2xlZnQnKVxuXHRcdFx0eCAtPSB3aWR0aCAvIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJyA/IDI6IDEpO1xuXHRcdHZhciBib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKHgsXG5cdFx0XHRcdFx0bnVtTGluZXMgPyAtIDAuNzUgKiBsZWFkaW5nIDogMCxcblx0XHRcdFx0XHR3aWR0aCwgbnVtTGluZXMgKiBsZWFkaW5nKTtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMoYm91bmRzLCBib3VuZHMpIDogYm91bmRzO1xuXHR9XG59KTtcblxudmFyIENvbG9yID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgdHlwZXMgPSB7XG5cdFx0Z3JheTogWydncmF5J10sXG5cdFx0cmdiOiBbJ3JlZCcsICdncmVlbicsICdibHVlJ10sXG5cdFx0aHNiOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2JyaWdodG5lc3MnXSxcblx0XHRoc2w6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG5cdFx0Z3JhZGllbnQ6IFsnZ3JhZGllbnQnLCAnb3JpZ2luJywgJ2Rlc3RpbmF0aW9uJywgJ2hpZ2hsaWdodCddXG5cdH07XG5cblx0dmFyIGNvbXBvbmVudFBhcnNlcnMgPSB7fSxcblx0XHRjb2xvckNhY2hlID0ge30sXG5cdFx0Y29sb3JDdHg7XG5cblx0ZnVuY3Rpb24gZnJvbUNTUyhzdHJpbmcpIHtcblx0XHR2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goL14jKFxcd3sxLDJ9KShcXHd7MSwyfSkoXFx3ezEsMn0pJC8pLFxuXHRcdFx0Y29tcG9uZW50cztcblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdGNvbXBvbmVudHMgPSBbMCwgMCwgMF07XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBtYXRjaFtpICsgMV07XG5cdFx0XHRcdGNvbXBvbmVudHNbaV0gPSBwYXJzZUludCh2YWx1ZS5sZW5ndGggPT0gMVxuXHRcdFx0XHRcdFx0PyB2YWx1ZSArIHZhbHVlIDogdmFsdWUsIDE2KSAvIDI1NTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKC9ecmdiYT9cXCgoLiopXFwpJC8pKSB7XG5cdFx0XHRjb21wb25lbnRzID0gbWF0Y2hbMV0uc3BsaXQoJywnKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gK2NvbXBvbmVudHNbaV07XG5cdFx0XHRcdGNvbXBvbmVudHNbaV0gPSBpIDwgMyA/IHZhbHVlIC8gMjU1IDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjYWNoZWQgPSBjb2xvckNhY2hlW3N0cmluZ107XG5cdFx0XHRpZiAoIWNhY2hlZCkge1xuXHRcdFx0XHRpZiAoIWNvbG9yQ3R4KSB7XG5cdFx0XHRcdFx0Y29sb3JDdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRcdFx0XHRcdGNvbG9yQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRjb2xvckN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdGNvbG9yQ3R4LmZpbGxTdHlsZSA9IHN0cmluZztcblx0XHRcdFx0Y29sb3JDdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cdFx0XHRcdHZhciBkYXRhID0gY29sb3JDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGE7XG5cdFx0XHRcdGNhY2hlZCA9IGNvbG9yQ2FjaGVbc3RyaW5nXSA9IFtcblx0XHRcdFx0XHRkYXRhWzBdIC8gMjU1LFxuXHRcdFx0XHRcdGRhdGFbMV0gLyAyNTUsXG5cdFx0XHRcdFx0ZGF0YVsyXSAvIDI1NVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdFx0Y29tcG9uZW50cyA9IGNhY2hlZC5zbGljZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0fVxuXG5cdHZhciBoc2JJbmRpY2VzID0gW1xuXHRcdFswLCAzLCAxXSxcblx0XHRbMiwgMCwgMV0sXG5cdFx0WzEsIDAsIDNdLFxuXHRcdFsxLCAyLCAwXSxcblx0XHRbMywgMSwgMF0sXG5cdFx0WzAsIDEsIDJdXG5cdF07XG5cblx0dmFyIGNvbnZlcnRlcnMgPSB7XG5cdFx0J3JnYi1oc2InOiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG5cdFx0XHRcdG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuXHRcdFx0XHRkZWx0YSA9IG1heCAtIG1pbixcblx0XHRcdFx0aCA9IGRlbHRhID09PSAwID8gMFxuXHRcdFx0XHRcdDpcdCggbWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdFx0XHRcdDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyXG5cdFx0XHRcdFx0XHQ6XHRcdFx0IChyIC0gZykgLyBkZWx0YSArIDQpICogNjA7XG5cdFx0XHRyZXR1cm4gW2gsIG1heCA9PT0gMCA/IDAgOiBkZWx0YSAvIG1heCwgbWF4XTtcblx0XHR9LFxuXG5cdFx0J2hzYi1yZ2InOiBmdW5jdGlvbihoLCBzLCBiKSB7XG5cdFx0XHRoID0gKCgoaCAvIDYwKSAlIDYpICsgNikgJSA2O1xuXHRcdFx0dmFyIGkgPSBNYXRoLmZsb29yKGgpLFxuXHRcdFx0XHRmID0gaCAtIGksXG5cdFx0XHRcdGkgPSBoc2JJbmRpY2VzW2ldLFxuXHRcdFx0XHR2ID0gW1xuXHRcdFx0XHRcdGIsXG5cdFx0XHRcdFx0YiAqICgxIC0gcyksXG5cdFx0XHRcdFx0YiAqICgxIC0gcyAqIGYpLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMgKiAoMSAtIGYpKVxuXHRcdFx0XHRdO1xuXHRcdFx0cmV0dXJuIFt2W2lbMF1dLCB2W2lbMV1dLCB2W2lbMl1dXTtcblx0XHR9LFxuXG5cdFx0J3JnYi1oc2wnOiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG5cdFx0XHRcdG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuXHRcdFx0XHRkZWx0YSA9IG1heCAtIG1pbixcblx0XHRcdFx0YWNocm9tYXRpYyA9IGRlbHRhID09PSAwLFxuXHRcdFx0XHRoID0gYWNocm9tYXRpYyA/IDBcblx0XHRcdFx0XHQ6XHQoIG1heCA9PSByID8gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApXG5cdFx0XHRcdFx0XHQ6IG1heCA9PSBnID8gKGIgLSByKSAvIGRlbHRhICsgMlxuXHRcdFx0XHRcdFx0Olx0XHRcdCAociAtIGcpIC8gZGVsdGEgKyA0KSAqIDYwLFxuXHRcdFx0XHRsID0gKG1heCArIG1pbikgLyAyLFxuXHRcdFx0XHRzID0gYWNocm9tYXRpYyA/IDAgOiBsIDwgMC41XG5cdFx0XHRcdFx0XHQ/IGRlbHRhIC8gKG1heCArIG1pbilcblx0XHRcdFx0XHRcdDogZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cdFx0XHRyZXR1cm4gW2gsIHMsIGxdO1xuXHRcdH0sXG5cblx0XHQnaHNsLXJnYic6IGZ1bmN0aW9uKGgsIHMsIGwpIHtcblx0XHRcdGggPSAoKChoIC8gMzYwKSAlIDEpICsgMSkgJSAxO1xuXHRcdFx0aWYgKHMgPT09IDApXG5cdFx0XHRcdHJldHVybiBbbCwgbCwgbF07XG5cdFx0XHR2YXIgdDNzID0gWyBoICsgMSAvIDMsIGgsIGggLSAxIC8gMyBdLFxuXHRcdFx0XHR0MiA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHMsXG5cdFx0XHRcdHQxID0gMiAqIGwgLSB0Mixcblx0XHRcdFx0YyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdFx0dmFyIHQzID0gdDNzW2ldO1xuXHRcdFx0XHRpZiAodDMgPCAwKSB0MyArPSAxO1xuXHRcdFx0XHRpZiAodDMgPiAxKSB0MyAtPSAxO1xuXHRcdFx0XHRjW2ldID0gNiAqIHQzIDwgMVxuXHRcdFx0XHRcdD8gdDEgKyAodDIgLSB0MSkgKiA2ICogdDNcblx0XHRcdFx0XHQ6IDIgKiB0MyA8IDFcblx0XHRcdFx0XHRcdD8gdDJcblx0XHRcdFx0XHRcdDogMyAqIHQzIDwgMlxuXHRcdFx0XHRcdFx0XHQ/IHQxICsgKHQyIC0gdDEpICogKCgyIC8gMykgLSB0MykgKiA2XG5cdFx0XHRcdFx0XHRcdDogdDE7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYztcblx0XHR9LFxuXG5cdFx0J3JnYi1ncmF5JzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0cmV0dXJuIFtyICogMC4yOTg5ICsgZyAqIDAuNTg3ICsgYiAqIDAuMTE0XTtcblx0XHR9LFxuXG5cdFx0J2dyYXktcmdiJzogZnVuY3Rpb24oZykge1xuXHRcdFx0cmV0dXJuIFtnLCBnLCBnXTtcblx0XHR9LFxuXG5cdFx0J2dyYXktaHNiJzogZnVuY3Rpb24oZykge1xuXHRcdFx0cmV0dXJuIFswLCAwLCBnXTtcblx0XHR9LFxuXG5cdFx0J2dyYXktaHNsJzogZnVuY3Rpb24oZykge1xuXHRcdFx0cmV0dXJuIFswLCAwLCBnXTtcblx0XHR9LFxuXG5cdFx0J2dyYWRpZW50LXJnYic6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH0sXG5cblx0XHQncmdiLWdyYWRpZW50JzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdH07XG5cblx0cmV0dXJuIEJhc2UuZWFjaCh0eXBlcywgZnVuY3Rpb24ocHJvcGVydGllcywgdHlwZSkge1xuXHRcdGNvbXBvbmVudFBhcnNlcnNbdHlwZV0gPSBbXTtcblx0XHRCYXNlLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24obmFtZSwgaW5kZXgpIHtcblx0XHRcdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdFx0XHRoYXNPdmVybGFwID0gL14oaHVlfHNhdHVyYXRpb24pJC8udGVzdChuYW1lKSxcblx0XHRcdFx0cGFyc2VyID0gY29tcG9uZW50UGFyc2Vyc1t0eXBlXVtpbmRleF0gPSBuYW1lID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0PyBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGN1cnJlbnQgPSB0aGlzLl9jb21wb25lbnRzWzBdO1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBHcmFkaWVudC5yZWFkKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVcblx0XHRcdFx0XHRcdFx0XHQ6IGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50ICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoY3VycmVudClcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50Ll9yZW1vdmVPd25lcih0aGlzKTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlLl9hZGRPd25lcih0aGlzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0OiB0eXBlID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHQ/IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWROdWxsOiBuYW1lID09PSAnaGlnaGxpZ2h0Jyxcblx0XHRcdFx0XHRcdFx0XHRcdGNsb25lOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBpc05hTih2YWx1ZSkgPyAwIDogdmFsdWU7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGVcblx0XHRcdFx0XHR8fCBoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKVxuXHRcdFx0XHRcdFx0PyB0aGlzLl9jb21wb25lbnRzW2luZGV4XVxuXHRcdFx0XHRcdFx0OiB0aGlzLl9jb252ZXJ0KHR5cGUpW2luZGV4XTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh0aGlzLl90eXBlICE9PSB0eXBlXG5cdFx0XHRcdFx0XHQmJiAhKGhhc092ZXJsYXAgJiYgL15oc1tibF0kLy50ZXN0KHRoaXMuX3R5cGUpKSkge1xuXHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdFx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdFx0fTtcblx0XHR9LCB0aGlzKTtcblx0fSwge1xuXHRcdF9jbGFzczogJ0NvbG9yJyxcblx0XHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29sb3IoYXJnKSB7XG5cdFx0XHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG5cdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdHJlYWQgPSAwLFxuXHRcdFx0XHR0eXBlLFxuXHRcdFx0XHRjb21wb25lbnRzLFxuXHRcdFx0XHRhbHBoYSxcblx0XHRcdFx0dmFsdWVzO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRhcmdzID0gYXJnO1xuXHRcdFx0XHRhcmcgPSBhcmdzWzBdO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGFyZ1R5cGUgPSBhcmcgIT0gbnVsbCAmJiB0eXBlb2YgYXJnO1xuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnICYmIGFyZyBpbiB0eXBlcykge1xuXHRcdFx0XHR0eXBlID0gYXJnO1xuXHRcdFx0XHRhcmcgPSBhcmdzWzFdO1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZztcblx0XHRcdFx0XHRhbHBoYSA9IGFyZ3NbMl07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoYXJncywgMSk7XG5cdFx0XHRcdFx0YXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghY29tcG9uZW50cykge1xuXHRcdFx0XHR2YWx1ZXMgPSBhcmdUeXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0PyBhcmdzXG5cdFx0XHRcdFx0XHQ6IGFyZ1R5cGUgPT09ICdvYmplY3QnICYmIGFyZy5sZW5ndGggIT0gbnVsbFxuXHRcdFx0XHRcdFx0XHQ/IGFyZ1xuXHRcdFx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0XHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdFx0XHRpZiAoIXR5cGUpXG5cdFx0XHRcdFx0XHR0eXBlID0gdmFsdWVzLmxlbmd0aCA+PSAzXG5cdFx0XHRcdFx0XHRcdFx0PyAncmdiJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2dyYXknO1xuXHRcdFx0XHRcdHZhciBsZW5ndGggPSB0eXBlc1t0eXBlXS5sZW5ndGg7XG5cdFx0XHRcdFx0YWxwaGEgPSB2YWx1ZXNbbGVuZ3RoXTtcblx0XHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0XHRyZWFkICs9IHZhbHVlcyA9PT0gYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdD8gbGVuZ3RoICsgKGFscGhhICE9IG51bGwgPyAxIDogMClcblx0XHRcdFx0XHRcdFx0OiAxO1xuXHRcdFx0XHRcdGlmICh2YWx1ZXMubGVuZ3RoID4gbGVuZ3RoKVxuXHRcdFx0XHRcdFx0dmFsdWVzID0gc2xpY2UuY2FsbCh2YWx1ZXMsIDAsIGxlbmd0aCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR0eXBlID0gJ3JnYic7XG5cdFx0XHRcdFx0Y29tcG9uZW50cyA9IGZyb21DU1MoYXJnKTtcblx0XHRcdFx0XHRpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDQpIHtcblx0XHRcdFx0XHRcdGFscGhhID0gY29tcG9uZW50c1szXTtcblx0XHRcdFx0XHRcdGNvbXBvbmVudHMubGVuZ3RoLS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0aWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSBhcmcuX3R5cGU7XG5cdFx0XHRcdFx0XHRjb21wb25lbnRzID0gYXJnLl9jb21wb25lbnRzLnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGFyZy5fYWxwaGE7XG5cdFx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHBvaW50ID0gY29tcG9uZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAocG9pbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gcG9pbnQuY2xvbmUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBHcmFkaWVudCkge1xuXHRcdFx0XHRcdFx0dHlwZSA9ICdncmFkaWVudCc7XG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBhcmdzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gJ2h1ZScgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdD8gJ2xpZ2h0bmVzcycgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0PyAnaHNsJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2hzYidcblx0XHRcdFx0XHRcdFx0OiAnZ3JhZGllbnQnIGluIGFyZyB8fCAnc3RvcHMnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdFx0fHwgJ3JhZGlhbCcgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0PyAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHRcdFx0OiAnZ3JheScgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0XHQ/ICdncmF5J1xuXHRcdFx0XHRcdFx0XHRcdFx0OiAncmdiJztcblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG5cdFx0XHRcdFx0XHRcdHBhcnNlcnMgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdO1xuXHRcdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gYXJnW3Byb3BlcnRpZXNbaV1dO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPT0gbnVsbCAmJiBpID09PSAwICYmIHR5cGUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdFx0XHRcdCYmICdzdG9wcycgaW4gYXJnKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdG9wczogYXJnLnN0b3BzLFxuXHRcdFx0XHRcdFx0XHRcdFx0cmFkaWFsOiBhcmcucmFkaWFsXG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGFscGhhID0gYXJnLmFscGhhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fX3JlYWQgJiYgdHlwZSlcblx0XHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlIHx8ICdyZ2InO1xuXHRcdFx0dGhpcy5faWQgPSBVSUQuZ2V0KENvbG9yKTtcblx0XHRcdGlmICghY29tcG9uZW50cykge1xuXHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cyA9IFtdO1xuXHRcdFx0XHR2YXIgcGFyc2VycyA9IGNvbXBvbmVudFBhcnNlcnNbdGhpcy5fdHlwZV07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFyc2Vycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWVzICYmIHZhbHVlc1tpXSk7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuXHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3RoaXMuX3R5cGVdO1xuXHRcdFx0dGhpcy5fYWxwaGEgPSBhbHBoYTtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHRcdH0sXG5cblx0XHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuZ2V0Q29tcG9uZW50cygpO1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFxuXHRcdFx0XHRcdC9eKGdyYXl8cmdiKSQvLnRlc3QodGhpcy5fdHlwZSlcblx0XHRcdFx0XHRcdD8gY29tcG9uZW50c1xuXHRcdFx0XHRcdFx0OiBbdGhpcy5fdHlwZV0uY29uY2F0KGNvbXBvbmVudHMpLFxuXHRcdFx0XHRcdG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHRcdH0sXG5cblx0XHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9jYW52YXNTdHlsZSA9IG51bGw7XG5cdFx0XHRpZiAodGhpcy5fb3duZXIpXG5cdFx0XHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcblx0XHR9LFxuXG5cdFx0X2NvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBjb252ZXJ0ZXI7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZVxuXHRcdFx0XHRcdD8gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpXG5cdFx0XHRcdFx0OiAoY29udmVydGVyID0gY29udmVydGVyc1t0aGlzLl90eXBlICsgJy0nICsgdHlwZV0pXG5cdFx0XHRcdFx0XHQ/IGNvbnZlcnRlci5hcHBseSh0aGlzLCB0aGlzLl9jb21wb25lbnRzKVxuXHRcdFx0XHRcdFx0OiBjb252ZXJ0ZXJzWydyZ2ItJyArIHR5cGVdLmFwcGx5KHRoaXMsXG5cdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctcmdiJ10uYXBwbHkodGhpcyxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzKSk7XG5cdFx0fSxcblxuXHRcdGNvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodHlwZSwgdGhpcy5fY29udmVydCh0eXBlKSwgdGhpcy5fYWxwaGEpO1xuXHRcdH0sXG5cblx0XHRnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHRcdH0sXG5cblx0XHRzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29udmVydCh0eXBlKTtcblx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHRcdH0sXG5cblx0XHRnZXRDb21wb25lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpO1xuXHRcdFx0aWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG5cdFx0XHRcdGNvbXBvbmVudHMucHVzaCh0aGlzLl9hbHBoYSk7XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0XHR9LFxuXG5cdFx0Z2V0QWxwaGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGwgPyB0aGlzLl9hbHBoYSA6IDE7XG5cdFx0fSxcblxuXHRcdHNldEFscGhhOiBmdW5jdGlvbihhbHBoYSkge1xuXHRcdFx0dGhpcy5fYWxwaGEgPSBhbHBoYSA9PSBudWxsID8gbnVsbCA6IE1hdGgubWluKE1hdGgubWF4KGFscGhhLCAwKSwgMSk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0fSxcblxuXHRcdGhhc0FscGhhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsO1xuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0XHR2YXIgY29sID0gQmFzZS5pc1BsYWluVmFsdWUoY29sb3IsIHRydWUpXG5cdFx0XHRcdFx0PyBDb2xvci5yZWFkKGFyZ3VtZW50cylcblx0XHRcdFx0XHQ6IGNvbG9yO1xuXHRcdFx0cmV0dXJuIGNvbCA9PT0gdGhpcyB8fCBjb2wgJiYgdGhpcy5fY2xhc3MgPT09IGNvbC5fY2xhc3Ncblx0XHRcdFx0XHQmJiB0aGlzLl90eXBlID09PSBjb2wuX3R5cGVcblx0XHRcdFx0XHQmJiB0aGlzLl9hbHBoYSA9PT0gY29sLl9hbHBoYVxuXHRcdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX2NvbXBvbmVudHMsIGNvbC5fY29tcG9uZW50cylcblx0XHRcdFx0XHR8fCBmYWxzZTtcblx0XHR9LFxuXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wcm9wZXJ0aWVzLFxuXHRcdFx0XHRwYXJ0cyA9IFtdLFxuXHRcdFx0XHRpc0dyYWRpZW50ID0gdGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jyxcblx0XHRcdFx0ZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5fY29tcG9uZW50c1tpXTtcblx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0cGFydHMucHVzaChwcm9wZXJ0aWVzW2ldICsgJzogJ1xuXHRcdFx0XHRcdFx0XHQrIChpc0dyYWRpZW50ID8gdmFsdWUgOiBmLm51bWJlcih2YWx1ZSkpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKVxuXHRcdFx0XHRwYXJ0cy5wdXNoKCdhbHBoYTogJyArIGYubnVtYmVyKHRoaXMuX2FscGhhKSk7XG5cdFx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHRcdH0sXG5cblx0XHR0b0NTUzogZnVuY3Rpb24oaGV4KSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQoJ3JnYicpLFxuXHRcdFx0XHRhbHBoYSA9IGhleCB8fCB0aGlzLl9hbHBoYSA9PSBudWxsID8gMSA6IHRoaXMuX2FscGhhO1xuXHRcdFx0ZnVuY3Rpb24gY29udmVydCh2YWwpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgucm91bmQoKHZhbCA8IDAgPyAwIDogdmFsID4gMSA/IDEgOiB2YWwpICogMjU1KTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBbXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1swXSksXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1sxXSksXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1syXSlcblx0XHRcdF07XG5cdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRjb21wb25lbnRzLnB1c2goYWxwaGEgPCAwID8gMCA6IGFscGhhKTtcblx0XHRcdHJldHVybiBoZXhcblx0XHRcdFx0XHQ/ICcjJyArICgoMSA8PCAyNCkgKyAoY29tcG9uZW50c1swXSA8PCAxNilcblx0XHRcdFx0XHRcdCsgKGNvbXBvbmVudHNbMV0gPDwgOClcblx0XHRcdFx0XHRcdCsgY29tcG9uZW50c1syXSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpXG5cdFx0XHRcdFx0OiAoY29tcG9uZW50cy5sZW5ndGggPT0gNCA/ICdyZ2JhKCcgOiAncmdiKCcpXG5cdFx0XHRcdFx0XHQrIGNvbXBvbmVudHMuam9pbignLCcpICsgJyknO1xuXHRcdH0sXG5cblx0XHR0b0NhbnZhc1N0eWxlOiBmdW5jdGlvbihjdHgpIHtcblx0XHRcdGlmICh0aGlzLl9jYW52YXNTdHlsZSlcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlO1xuXHRcdFx0aWYgKHRoaXMuX3R5cGUgIT09ICdncmFkaWVudCcpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYW52YXNTdHlsZSA9IHRoaXMudG9DU1MoKTtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cyxcblx0XHRcdFx0Z3JhZGllbnQgPSBjb21wb25lbnRzWzBdLFxuXHRcdFx0XHRzdG9wcyA9IGdyYWRpZW50Ll9zdG9wcyxcblx0XHRcdFx0b3JpZ2luID0gY29tcG9uZW50c1sxXSxcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBjb21wb25lbnRzWzJdLFxuXHRcdFx0XHRjYW52YXNHcmFkaWVudDtcblx0XHRcdGlmIChncmFkaWVudC5fcmFkaWFsKSB7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBkZXN0aW5hdGlvbi5nZXREaXN0YW5jZShvcmlnaW4pLFxuXHRcdFx0XHRcdGhpZ2hsaWdodCA9IGNvbXBvbmVudHNbM107XG5cdFx0XHRcdGlmIChoaWdobGlnaHQpIHtcblx0XHRcdFx0XHR2YXIgdmVjdG9yID0gaGlnaGxpZ2h0LnN1YnRyYWN0KG9yaWdpbik7XG5cdFx0XHRcdFx0aWYgKHZlY3Rvci5nZXRMZW5ndGgoKSA+IHJhZGl1cylcblx0XHRcdFx0XHRcdGhpZ2hsaWdodCA9IG9yaWdpbi5hZGQodmVjdG9yLm5vcm1hbGl6ZShyYWRpdXMgLSAwLjEpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc3RhcnQgPSBoaWdobGlnaHQgfHwgb3JpZ2luO1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChzdGFydC54LCBzdGFydC55LFxuXHRcdFx0XHRcdFx0MCwgb3JpZ2luLngsIG9yaWdpbi55LCByYWRpdXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQob3JpZ2luLngsIG9yaWdpbi55LFxuXHRcdFx0XHRcdFx0ZGVzdGluYXRpb24ueCwgZGVzdGluYXRpb24ueSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3RvcCA9IHN0b3BzW2ldO1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5fcmFtcFBvaW50LFxuXHRcdFx0XHRcdFx0c3RvcC5fY29sb3IudG9DYW52YXNTdHlsZSgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9jYW52YXNTdHlsZSA9IGNhbnZhc0dyYWRpZW50O1xuXHRcdH0sXG5cblx0XHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdFx0aWYgKHRoaXMuX3R5cGUgPT09ICdncmFkaWVudCcpIHtcblx0XHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHBvaW50ID0gY29tcG9uZW50c1tpXTtcblx0XHRcdFx0XHRtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvaW50LCBwb2ludCwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHRfdHlwZXM6IHR5cGVzLFxuXG5cdFx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmFuZG9tID0gTWF0aC5yYW5kb207XG5cdFx0XHRcdHJldHVybiBuZXcgQ29sb3IocmFuZG9tKCksIHJhbmRvbSgpLCByYW5kb20oKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG9wZXJhdG9ycyA9IHtcblx0XHRhZGQ6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhICsgYjtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhIC0gYjtcblx0XHR9LFxuXG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhICogYjtcblx0XHR9LFxuXG5cdFx0ZGl2aWRlOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAvIGI7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBCYXNlLmVhY2gob3BlcmF0b3JzLCBmdW5jdGlvbihvcGVyYXRvciwgbmFtZSkge1xuXHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbihjb2xvcikge1xuXHRcdFx0Y29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdGNvbXBvbmVudHMxID0gdGhpcy5fY29tcG9uZW50cyxcblx0XHRcdFx0Y29tcG9uZW50czIgPSBjb2xvci5fY29udmVydCh0eXBlKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29tcG9uZW50czEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjb21wb25lbnRzMltpXSA9IG9wZXJhdG9yKGNvbXBvbmVudHMxW2ldLCBjb21wb25lbnRzMltpXSk7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHR5cGUsIGNvbXBvbmVudHMyLFxuXHRcdFx0XHRcdHRoaXMuX2FscGhhICE9IG51bGxcblx0XHRcdFx0XHRcdFx0PyBvcGVyYXRvcih0aGlzLl9hbHBoYSwgY29sb3IuZ2V0QWxwaGEoKSlcblx0XHRcdFx0XHRcdFx0OiBudWxsKTtcblx0XHR9O1xuXHR9LCB7XG5cdH0pO1xufSk7XG5cbkJhc2UuZWFjaChDb2xvci5fdHlwZXMsIGZ1bmN0aW9uKHByb3BlcnRpZXMsIHR5cGUpIHtcblx0dmFyIGN0b3IgPSB0aGlzW0Jhc2UuY2FwaXRhbGl6ZSh0eXBlKSArICdDb2xvciddID0gZnVuY3Rpb24oYXJnKSB7XG5cdFx0XHR2YXIgYXJnVHlwZSA9IGFyZyAhPSBudWxsICYmIHR5cGVvZiBhcmcsXG5cdFx0XHRcdGNvbXBvbmVudHMgPSBhcmdUeXBlID09PSAnb2JqZWN0JyAmJiBhcmcubGVuZ3RoICE9IG51bGxcblx0XHRcdFx0XHQ/IGFyZ1xuXHRcdFx0XHRcdDogYXJnVHlwZSA9PT0gJ3N0cmluZydcblx0XHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdFx0OiBhcmd1bWVudHM7XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50c1xuXHRcdFx0XHRcdD8gbmV3IENvbG9yKHR5cGUsIGNvbXBvbmVudHMpXG5cdFx0XHRcdFx0OiBuZXcgQ29sb3IoYXJnKTtcblx0XHR9O1xuXHRpZiAodHlwZS5sZW5ndGggPT0gMykge1xuXHRcdHZhciBhY3JvbnltID0gdHlwZS50b1VwcGVyQ2FzZSgpO1xuXHRcdENvbG9yW2Fjcm9ueW1dID0gdGhpc1thY3JvbnltICsgJ0NvbG9yJ10gPSBjdG9yO1xuXHR9XG59LCBCYXNlLmV4cG9ydHMpO1xuXG52YXIgR3JhZGllbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyYWRpZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBHcmFkaWVudChzdG9wcywgcmFkaWFsKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KCk7XG5cdFx0aWYgKHN0b3BzICYmIHRoaXMuX3NldChzdG9wcykpXG5cdFx0XHRzdG9wcyA9IHJhZGlhbCA9IG51bGw7XG5cdFx0aWYgKCF0aGlzLl9zdG9wcylcblx0XHRcdHRoaXMuc2V0U3RvcHMoc3RvcHMgfHwgWyd3aGl0ZScsICdibGFjayddKTtcblx0XHRpZiAodGhpcy5fcmFkaWFsID09IG51bGwpXG5cdFx0XHR0aGlzLnNldFJhZGlhbCh0eXBlb2YgcmFkaWFsID09PSAnc3RyaW5nJyAmJiByYWRpYWwgPT09ICdyYWRpYWwnXG5cdFx0XHRcdFx0fHwgcmFkaWFsIHx8IGZhbHNlKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9zdG9wcywgdGhpcy5fcmFkaWFsXSxcblx0XHRcdFx0XHRvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0XHR9KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9vd25lcnMgJiYgdGhpcy5fb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHRoaXMuX293bmVyc1tpXS5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdF9hZGRPd25lcjogZnVuY3Rpb24oY29sb3IpIHtcblx0XHRpZiAoIXRoaXMuX293bmVycylcblx0XHRcdHRoaXMuX293bmVycyA9IFtdO1xuXHRcdHRoaXMuX293bmVycy5wdXNoKGNvbG9yKTtcblx0fSxcblxuXHRfcmVtb3ZlT3duZXI6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fb3duZXJzID8gdGhpcy5fb3duZXJzLmluZGV4T2YoY29sb3IpIDogLTE7XG5cdFx0aWYgKGluZGV4ICE9IC0xKSB7XG5cdFx0XHR0aGlzLl9vd25lcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdGlmICh0aGlzLl9vd25lcnMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aGlzLl9vd25lcnMgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3RvcHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHN0b3BzW2ldID0gdGhpcy5fc3RvcHNbaV0uY2xvbmUoKTtcblx0XHRyZXR1cm4gbmV3IEdyYWRpZW50KHN0b3BzLCB0aGlzLl9yYWRpYWwpO1xuXHR9LFxuXG5cdGdldFN0b3BzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RvcHM7XG5cdH0sXG5cblx0c2V0U3RvcHM6IGZ1bmN0aW9uKHN0b3BzKSB7XG5cdFx0aWYgKHRoaXMuc3RvcHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLl9zdG9wc1tpXS5fb3duZXIgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChzdG9wcy5sZW5ndGggPCAyKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdHcmFkaWVudCBzdG9wIGxpc3QgbmVlZHMgdG8gY29udGFpbiBhdCBsZWFzdCB0d28gc3RvcHMuJyk7XG5cdFx0dGhpcy5fc3RvcHMgPSBHcmFkaWVudFN0b3AucmVhZEFsbChzdG9wcywgMCwgeyBjbG9uZTogdHJ1ZSB9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHN0b3AgPSB0aGlzLl9zdG9wc1tpXTtcblx0XHRcdHN0b3AuX293bmVyID0gdGhpcztcblx0XHRcdGlmIChzdG9wLl9kZWZhdWx0UmFtcClcblx0XHRcdFx0c3RvcC5zZXRSYW1wUG9pbnQoaSAvIChsIC0gMSkpO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0Z2V0UmFkaWFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaWFsO1xuXHR9LFxuXG5cdHNldFJhZGlhbDogZnVuY3Rpb24ocmFkaWFsKSB7XG5cdFx0dGhpcy5fcmFkaWFsID0gcmFkaWFsO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGdyYWRpZW50KSB7XG5cdFx0aWYgKGdyYWRpZW50ID09PSB0aGlzKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0aWYgKGdyYWRpZW50ICYmIHRoaXMuX2NsYXNzID09PSBncmFkaWVudC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fc3RvcHMubGVuZ3RoID09PSBncmFkaWVudC5fc3RvcHMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoIXRoaXMuX3N0b3BzW2ldLmVxdWFscyhncmFkaWVudC5fc3RvcHNbaV0pKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG52YXIgR3JhZGllbnRTdG9wID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcmFkaWVudFN0b3AnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50U3RvcChhcmcwLCBhcmcxKSB7XG5cdFx0aWYgKGFyZzApIHtcblx0XHRcdHZhciBjb2xvciwgcmFtcFBvaW50O1xuXHRcdFx0aWYgKGFyZzEgPT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdGNvbG9yID0gYXJnMFswXTtcblx0XHRcdFx0cmFtcFBvaW50ID0gYXJnMFsxXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5jb2xvcikge1xuXHRcdFx0XHRjb2xvciA9IGFyZzAuY29sb3I7XG5cdFx0XHRcdHJhbXBQb2ludCA9IGFyZzAucmFtcFBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwO1xuXHRcdFx0XHRyYW1wUG9pbnQgPSBhcmcxO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRDb2xvcihjb2xvcik7XG5cdFx0XHR0aGlzLnNldFJhbXBQb2ludChyYW1wUG9pbnQpO1xuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBHcmFkaWVudFN0b3AodGhpcy5fY29sb3IuY2xvbmUoKSwgdGhpcy5fcmFtcFBvaW50KTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9jb2xvciwgdGhpcy5fcmFtcFBvaW50XSwgb3B0aW9ucywgdHJ1ZSxcblx0XHRcdFx0ZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9vd25lcilcblx0XHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcblx0fSxcblxuXHRnZXRSYW1wUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYW1wUG9pbnQ7XG5cdH0sXG5cblx0c2V0UmFtcFBvaW50OiBmdW5jdGlvbihyYW1wUG9pbnQpIHtcblx0XHR0aGlzLl9kZWZhdWx0UmFtcCA9IHJhbXBQb2ludCA9PSBudWxsO1xuXHRcdHRoaXMuX3JhbXBQb2ludCA9IHJhbXBQb2ludCB8fCAwO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRnZXRDb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbG9yO1xuXHR9LFxuXG5cdHNldENvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHRoaXMuX2NvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICh0aGlzLl9jb2xvciA9PT0gY29sb3IpXG5cdFx0XHR0aGlzLl9jb2xvciA9IGNvbG9yLmNsb25lKCk7XG5cdFx0dGhpcy5fY29sb3IuX293bmVyID0gdGhpcztcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzdG9wKSB7XG5cdFx0cmV0dXJuIHN0b3AgPT09IHRoaXMgfHwgc3RvcCAmJiB0aGlzLl9jbGFzcyA9PT0gc3RvcC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fY29sb3IuZXF1YWxzKHN0b3AuX2NvbG9yKVxuXHRcdFx0XHQmJiB0aGlzLl9yYW1wUG9pbnQgPT0gc3RvcC5fcmFtcFBvaW50XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9XG59KTtcblxudmFyIFN0eWxlID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgZGVmYXVsdHMgPSB7XG5cdFx0ZmlsbENvbG9yOiB1bmRlZmluZWQsXG5cdFx0c3Ryb2tlQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRzdHJva2VXaWR0aDogMSxcblx0XHRzdHJva2VDYXA6ICdidXR0Jyxcblx0XHRzdHJva2VKb2luOiAnbWl0ZXInLFxuXHRcdHN0cm9rZVNjYWxpbmc6IHRydWUsXG5cdFx0bWl0ZXJMaW1pdDogMTAsXG5cdFx0ZGFzaE9mZnNldDogMCxcblx0XHRkYXNoQXJyYXk6IFtdLFxuXHRcdHdpbmRpbmdSdWxlOiAnbm9uemVybycsXG5cdFx0c2hhZG93Q29sb3I6IHVuZGVmaW5lZCxcblx0XHRzaGFkb3dCbHVyOiAwLFxuXHRcdHNoYWRvd09mZnNldDogbmV3IFBvaW50KCksXG5cdFx0c2VsZWN0ZWRDb2xvcjogdW5kZWZpbmVkLFxuXHRcdGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcblx0XHRmb250V2VpZ2h0OiAnbm9ybWFsJyxcblx0XHRmb250U2l6ZTogMTIsXG5cdFx0Zm9udDogJ3NhbnMtc2VyaWYnLFxuXHRcdGxlYWRpbmc6IG51bGwsXG5cdFx0anVzdGlmaWNhdGlvbjogJ2xlZnQnXG5cdH07XG5cblx0dmFyIGZsYWdzID0ge1xuXHRcdHN0cm9rZVdpZHRoOiA5Nyxcblx0XHRzdHJva2VDYXA6IDk3LFxuXHRcdHN0cm9rZUpvaW46IDk3LFxuXHRcdHN0cm9rZVNjYWxpbmc6IDEwNSxcblx0XHRtaXRlckxpbWl0OiA5Nyxcblx0XHRmb250RmFtaWx5OiA5LFxuXHRcdGZvbnRXZWlnaHQ6IDksXG5cdFx0Zm9udFNpemU6IDksXG5cdFx0Zm9udDogOSxcblx0XHRsZWFkaW5nOiA5LFxuXHRcdGp1c3RpZmljYXRpb246IDlcblx0fTtcblxuXHR2YXIgaXRlbSA9IHsgYmVhbnM6IHRydWUgfSxcblx0XHRmaWVsZHMgPSB7XG5cdFx0XHRfZGVmYXVsdHM6IGRlZmF1bHRzLFxuXHRcdFx0X3RleHREZWZhdWx0czogbmV3IEJhc2UoZGVmYXVsdHMsIHtcblx0XHRcdFx0ZmlsbENvbG9yOiBuZXcgQ29sb3IoKVxuXHRcdFx0fSksXG5cdFx0XHRiZWFuczogdHJ1ZVxuXHRcdH07XG5cblx0QmFzZS5lYWNoKGRlZmF1bHRzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0dmFyIGlzQ29sb3IgPSAvQ29sb3IkLy50ZXN0KGtleSksXG5cdFx0XHRpc1BvaW50ID0ga2V5ID09PSAnc2hhZG93T2Zmc2V0Jyxcblx0XHRcdHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRcdGZsYWcgPSBmbGFnc1trZXldLFxuXHRcdFx0c2V0ID0gJ3NldCcgKyBwYXJ0LFxuXHRcdFx0Z2V0ID0gJ2dldCcgKyBwYXJ0O1xuXG5cdFx0ZmllbGRzW3NldF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG5cdFx0XHRcdGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuO1xuXHRcdFx0aWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcblx0XHRcdFx0XHQmJiAhKG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRjaGlsZHJlbltpXS5fc3R5bGVbc2V0XSh2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgb2xkID0gdGhpcy5fdmFsdWVzW2tleV07XG5cdFx0XHRcdGlmIChvbGQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKGlzQ29sb3IpIHtcblx0XHRcdFx0XHRcdGlmIChvbGQpXG5cdFx0XHRcdFx0XHRcdG9sZC5fb3duZXIgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IENvbG9yKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZS5fb3duZXIpXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuXHRcdFx0XHRcdFx0XHR2YWx1ZS5fb3duZXIgPSBvd25lcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fdmFsdWVzW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAob3duZXIpXG5cdFx0XHRcdFx0XHRvd25lci5fY2hhbmdlZChmbGFnIHx8IDY1KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmaWVsZHNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TWVyZ2UpIHtcblx0XHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyLFxuXHRcdFx0XHRjaGlsZHJlbiA9IG93bmVyICYmIG93bmVyLl9jaGlsZHJlbixcblx0XHRcdFx0dmFsdWU7XG5cdFx0XHRpZiAoIWNoaWxkcmVuIHx8IGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBfZG9udE1lcmdlXG5cdFx0XHRcdFx0fHwgb3duZXIgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5fdmFsdWVzW2tleV07XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLl9kZWZhdWx0c1trZXldO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5jbG9uZSlcblx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuY2xvbmUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgY3RvciA9IGlzQ29sb3IgPyBDb2xvciA6IGlzUG9pbnQgPyBQb2ludCA6IG51bGw7XG5cdFx0XHRcdFx0aWYgKGN0b3IgJiYgISh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gY3RvcikpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWUgPSBjdG9yLnJlYWQoW3ZhbHVlXSwgMCxcblx0XHRcdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlLCBjbG9uZTogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiBpc0NvbG9yKVxuXHRcdFx0XHRcdFx0XHR2YWx1ZS5fb3duZXIgPSBvd25lcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkVmFsdWUgPSBjaGlsZHJlbltpXS5fc3R5bGVbZ2V0XSgpO1xuXHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2hpbGRWYWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsdWUsIGNoaWxkVmFsdWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cblx0XHRpdGVtW2dldF0gPSBmdW5jdGlvbihfZG9udE1lcmdlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3R5bGVbZ2V0XShfZG9udE1lcmdlKTtcblx0XHR9O1xuXG5cdFx0aXRlbVtzZXRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuX3N0eWxlW3NldF0odmFsdWUpO1xuXHRcdH07XG5cdH0pO1xuXG5cdEl0ZW0uaW5qZWN0KGl0ZW0pO1xuXHRyZXR1cm4gZmllbGRzO1xufSwge1xuXHRfY2xhc3M6ICdTdHlsZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU3R5bGUoc3R5bGUsIF9vd25lciwgX3Byb2plY3QpIHtcblx0XHR0aGlzLl92YWx1ZXMgPSB7fTtcblx0XHR0aGlzLl9vd25lciA9IF9vd25lcjtcblx0XHR0aGlzLl9wcm9qZWN0ID0gX293bmVyICYmIF9vd25lci5fcHJvamVjdCB8fCBfcHJvamVjdCB8fCBwYXBlci5wcm9qZWN0O1xuXHRcdGlmIChfb3duZXIgaW5zdGFuY2VvZiBUZXh0SXRlbSlcblx0XHRcdHRoaXMuX2RlZmF1bHRzID0gdGhpcy5fdGV4dERlZmF1bHRzO1xuXHRcdGlmIChzdHlsZSlcblx0XHRcdHRoaXMuc2V0KHN0eWxlKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dmFyIGlzU3R5bGUgPSBzdHlsZSBpbnN0YW5jZW9mIFN0eWxlLFxuXHRcdFx0dmFsdWVzID0gaXNTdHlsZSA/IHN0eWxlLl92YWx1ZXMgOiBzdHlsZTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG5cdFx0XHRcdGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XTtcblx0XHRcdFx0XHR0aGlzW2tleV0gPSB2YWx1ZSAmJiBpc1N0eWxlICYmIHZhbHVlLmNsb25lXG5cdFx0XHRcdFx0XHRcdD8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHRyZXR1cm4gc3R5bGUgPT09IHRoaXMgfHwgc3R5bGUgJiYgdGhpcy5fY2xhc3MgPT09IHN0eWxlLl9jbGFzc1xuXHRcdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl92YWx1ZXMsIHN0eWxlLl92YWx1ZXMpXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0RmlsbENvbG9yKCk7XG5cdH0sXG5cblx0aGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLmdldFN0cm9rZUNvbG9yKCkgJiYgdGhpcy5nZXRTdHJva2VXaWR0aCgpID4gMDtcblx0fSxcblxuXHRoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0U2hhZG93Q29sb3IoKSAmJiB0aGlzLmdldFNoYWRvd0JsdXIoKSA+IDA7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuZ2V0VmlldygpO1xuXHR9LFxuXG5cdGdldEZvbnRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuXHRcdHJldHVybiB0aGlzLmdldEZvbnRXZWlnaHQoKVxuXHRcdFx0XHQrICcgJyArIGZvbnRTaXplICsgKC9bYS16XS9pLnRlc3QoZm9udFNpemUgKyAnJykgPyAnICcgOiAncHggJylcblx0XHRcdFx0KyB0aGlzLmdldEZvbnRGYW1pbHkoKTtcblx0fSxcblxuXHRnZXRGb250OiAnI2dldEZvbnRGYW1pbHknLFxuXHRzZXRGb250OiAnI3NldEZvbnRGYW1pbHknLFxuXG5cdGdldExlYWRpbmc6IGZ1bmN0aW9uIGdldExlYWRpbmcoKSB7XG5cdFx0dmFyIGxlYWRpbmcgPSBnZXRMZWFkaW5nLmJhc2UuY2FsbCh0aGlzKSxcblx0XHRcdGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuXHRcdGlmICgvcHR8ZW18JXxweC8udGVzdChmb250U2l6ZSkpXG5cdFx0XHRmb250U2l6ZSA9IHRoaXMuZ2V0VmlldygpLmdldFBpeGVsU2l6ZShmb250U2l6ZSk7XG5cdFx0cmV0dXJuIGxlYWRpbmcgIT0gbnVsbCA/IGxlYWRpbmcgOiBmb250U2l6ZSAqIDEuMjtcblx0fVxuXG59KTtcblxudmFyIERvbUVsZW1lbnQgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGhhbmRsZVByZWZpeChlbCwgbmFtZSwgc2V0LCB2YWx1ZSkge1xuXHRcdHZhciBwcmVmaXhlcyA9IFsnJywgJ3dlYmtpdCcsICdtb3onLCAnTW96JywgJ21zJywgJ28nXSxcblx0XHRcdHN1ZmZpeCA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHR2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV0sXG5cdFx0XHRcdGtleSA9IHByZWZpeCA/IHByZWZpeCArIHN1ZmZpeCA6IG5hbWU7XG5cdFx0XHRpZiAoa2V5IGluIGVsKSB7XG5cdFx0XHRcdGlmIChzZXQpIHtcblx0XHRcdFx0XHRlbFtrZXldID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXRTdHlsZXM6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHR2YXIgZG9jID0gZWwgJiYgZWwubm9kZVR5cGUgIT09IDkgPyBlbC5vd25lckRvY3VtZW50IDogZWwsXG5cdFx0XHRcdHZpZXcgPSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3O1xuXHRcdFx0cmV0dXJuIHZpZXcgJiYgdmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJyk7XG5cdFx0fSxcblxuXHRcdGdldEJvdW5kczogZnVuY3Rpb24oZWwsIHZpZXdwb3J0KSB7XG5cdFx0XHR2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudCxcblx0XHRcdFx0Ym9keSA9IGRvYy5ib2R5LFxuXHRcdFx0XHRodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudCxcblx0XHRcdFx0cmVjdDtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVjdCA9IHsgbGVmdDogMCwgdG9wOiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG5cdFx0XHR9XG5cdFx0XHR2YXIgeCA9IHJlY3QubGVmdCAtIChodG1sLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDApLFxuXHRcdFx0XHR5ID0gcmVjdC50b3AgLSAoaHRtbC5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMCk7XG5cdFx0XHRpZiAoIXZpZXdwb3J0KSB7XG5cdFx0XHRcdHZhciB2aWV3ID0gZG9jLmRlZmF1bHRWaWV3O1xuXHRcdFx0XHR4ICs9IHZpZXcucGFnZVhPZmZzZXQgfHwgaHRtbC5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcblx0XHRcdFx0eSArPSB2aWV3LnBhZ2VZT2Zmc2V0IHx8IGh0bWwuc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeCwgeSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHRcdH0sXG5cblx0XHRnZXRWaWV3cG9ydEJvdW5kczogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuXHRcdFx0XHR2aWV3ID0gZG9jLmRlZmF1bHRWaWV3LFxuXHRcdFx0XHRodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKDAsIDAsXG5cdFx0XHRcdHZpZXcuaW5uZXJXaWR0aCB8fCBodG1sLmNsaWVudFdpZHRoLFxuXHRcdFx0XHR2aWV3LmlubmVySGVpZ2h0IHx8IGh0bWwuY2xpZW50SGVpZ2h0XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKGVsLCB2aWV3cG9ydCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB2aWV3cG9ydCkuZ2V0UG9pbnQoKTtcblx0XHR9LFxuXG5cdFx0Z2V0U2l6ZTogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiBEb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdHJ1ZSkuZ2V0U2l6ZSgpO1xuXHRcdH0sXG5cblx0XHRpc0ludmlzaWJsZTogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiBEb21FbGVtZW50LmdldFNpemUoZWwpLmVxdWFscyhuZXcgU2l6ZSgwLCAwKSk7XG5cdFx0fSxcblxuXHRcdGlzSW5WaWV3OiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuICFEb21FbGVtZW50LmlzSW52aXNpYmxlKGVsKVxuXHRcdFx0XHRcdCYmIERvbUVsZW1lbnQuZ2V0Vmlld3BvcnRCb3VuZHMoZWwpLmludGVyc2VjdHMoXG5cdFx0XHRcdFx0XHREb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdHJ1ZSkpO1xuXHRcdH0sXG5cblx0XHRnZXRQcmVmaXhlZDogZnVuY3Rpb24oZWwsIG5hbWUpIHtcblx0XHRcdHJldHVybiBoYW5kbGVQcmVmaXgoZWwsIG5hbWUpO1xuXHRcdH0sXG5cblx0XHRzZXRQcmVmaXhlZDogZnVuY3Rpb24oZWwsIG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBuYW1lKVxuXHRcdFx0XHRcdGhhbmRsZVByZWZpeChlbCwga2V5LCB0cnVlLCBuYW1lW2tleV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlUHJlZml4KGVsLCBuYW1lLCB0cnVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIERvbUV2ZW50ID0ge1xuXHRhZGQ6IGZ1bmN0aW9uKGVsLCBldmVudHMpIHtcblx0XHRmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuXHRcdFx0dmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG5cdFx0XHRcdHBhcnRzID0gdHlwZS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRlbC5hZGRFdmVudExpc3RlbmVyKHBhcnRzW2ldLCBmdW5jLCBmYWxzZSk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuXHRcdGZvciAodmFyIHR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHR2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcblx0XHRcdFx0cGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIocGFydHNbaV0sIGZ1bmMsIGZhbHNlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHBvcyA9IGV2ZW50LnRhcmdldFRvdWNoZXNcblx0XHRcdFx0PyBldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aFxuXHRcdFx0XHRcdD8gZXZlbnQudGFyZ2V0VG91Y2hlc1swXVxuXHRcdFx0XHRcdDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF1cblx0XHRcdFx0OiBldmVudDtcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0cG9zLnBhZ2VYIHx8IHBvcy5jbGllbnRYICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG5cdFx0XHRwb3MucGFnZVkgfHwgcG9zLmNsaWVudFkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG5cdFx0KTtcblx0fSxcblxuXHRnZXRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuXHR9LFxuXG5cdGdldFJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudG9FbGVtZW50O1xuXHR9LFxuXG5cdGdldE9mZnNldDogZnVuY3Rpb24oZXZlbnQsIHRhcmdldCkge1xuXHRcdHJldHVybiBEb21FdmVudC5nZXRQb2ludChldmVudCkuc3VidHJhY3QoRG9tRWxlbWVudC5nZXRPZmZzZXQoXG5cdFx0XHRcdHRhcmdldCB8fCBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpKSk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG59O1xuXG5Eb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBuYXRpdmVSZXF1ZXN0ID0gRG9tRWxlbWVudC5nZXRQcmVmaXhlZCh3aW5kb3csICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSxcblx0XHRyZXF1ZXN0ZWQgPSBmYWxzZSxcblx0XHRjYWxsYmFja3MgPSBbXSxcblx0XHRmb2N1c2VkID0gdHJ1ZSxcblx0XHR0aW1lcjtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0Zm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9jdXNlZCA9IHRydWU7XG5cdFx0fSxcblx0XHRibHVyOiBmdW5jdGlvbigpIHtcblx0XHRcdGZvY3VzZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGhhbmRsZUNhbGxiYWNrcygpIHtcblx0XHRmb3IgKHZhciBpID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgZW50cnkgPSBjYWxsYmFja3NbaV0sXG5cdFx0XHRcdGZ1bmMgPSBlbnRyeVswXSxcblx0XHRcdFx0ZWwgPSBlbnRyeVsxXTtcblx0XHRcdGlmICghZWwgfHwgKFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGVsLCAna2VlcGFsaXZlJykgPT0gJ3RydWUnXG5cdFx0XHRcdFx0fHwgZm9jdXNlZCkgJiYgRG9tRWxlbWVudC5pc0luVmlldyhlbCkpIHtcblx0XHRcdFx0Y2FsbGJhY2tzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0ZnVuYygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobmF0aXZlUmVxdWVzdCkge1xuXHRcdFx0aWYgKGNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0bmF0aXZlUmVxdWVzdChoYW5kbGVDYWxsYmFja3MpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVxdWVzdGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG5cdFx0Y2FsbGJhY2tzLnB1c2goW2NhbGxiYWNrLCBlbGVtZW50XSk7XG5cdFx0aWYgKG5hdGl2ZVJlcXVlc3QpIHtcblx0XHRcdGlmICghcmVxdWVzdGVkKSB7XG5cdFx0XHRcdG5hdGl2ZVJlcXVlc3QoaGFuZGxlQ2FsbGJhY2tzKTtcblx0XHRcdFx0cmVxdWVzdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCF0aW1lcikge1xuXHRcdFx0dGltZXIgPSBzZXRJbnRlcnZhbChoYW5kbGVDYWxsYmFja3MsIDEwMDAgLyA2MCk7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFZpZXcgPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cdF9jbGFzczogJ1ZpZXcnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFZpZXcocHJvamVjdCwgZWxlbWVudCkge1xuXHRcdHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuXHRcdHRoaXMuX3Njb3BlID0gcHJvamVjdC5fc2NvcGU7XG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0dmFyIHNpemU7XG5cdFx0aWYgKCF0aGlzLl9waXhlbFJhdGlvKVxuXHRcdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdFx0dGhpcy5faWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcblx0XHRpZiAodGhpcy5faWQgPT0gbnVsbClcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuX2lkID0gJ3ZpZXctJyArIFZpZXcuX2lkKyspO1xuXHRcdERvbUV2ZW50LmFkZChlbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcblx0XHR2YXIgbm9uZSA9ICdub25lJztcblx0XHREb21FbGVtZW50LnNldFByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIHtcblx0XHRcdHVzZXJTZWxlY3Q6IG5vbmUsXG5cdFx0XHR0b3VjaEFjdGlvbjogbm9uZSxcblx0XHRcdHRvdWNoQ2FsbG91dDogbm9uZSxcblx0XHRcdGNvbnRlbnRab29taW5nOiBub25lLFxuXHRcdFx0dXNlckRyYWc6IG5vbmUsXG5cdFx0XHR0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG5cdFx0fSk7XG5cblx0XHRmdW5jdGlvbiBnZXRTaXplKG5hbWUpIHtcblx0XHRcdHJldHVybiBlbGVtZW50W25hbWVdIHx8IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpLCAxMCk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldENhbnZhc1NpemUoKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IERvbUVsZW1lbnQuZ2V0U2l6ZShlbGVtZW50KTtcblx0XHRcdHJldHVybiBzaXplLmlzTmFOKCkgfHwgc2l6ZS5pc1plcm8oKVxuXHRcdFx0XHRcdD8gbmV3IFNpemUoZ2V0U2l6ZSgnd2lkdGgnKSwgZ2V0U2l6ZSgnaGVpZ2h0JykpXG5cdFx0XHRcdFx0OiBzaXplO1xuXHRcdH07XG5cblx0XHRpZiAoUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3Jlc2l6ZScpKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHREb21FdmVudC5hZGQod2luZG93LCB0aGlzLl93aW5kb3dFdmVudHMgPSB7XG5cdFx0XHRcdHJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhhdC5zZXRWaWV3U2l6ZShnZXRDYW52YXNTaXplKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0dGhpcy5fc2V0Vmlld1NpemUoc2l6ZSA9IGdldENhbnZhc1NpemUoKSk7XG5cdFx0aWYgKFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdzdGF0cycpXG5cdFx0XHRcdCYmIHR5cGVvZiBTdGF0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRoaXMuX3N0YXRzID0gbmV3IFN0YXRzKCk7XG5cdFx0XHR2YXIgc3RhdHMgPSB0aGlzLl9zdGF0cy5kb21FbGVtZW50LFxuXHRcdFx0XHRzdHlsZSA9IHN0YXRzLnN0eWxlLFxuXHRcdFx0XHRvZmZzZXQgPSBEb21FbGVtZW50LmdldE9mZnNldChlbGVtZW50KTtcblx0XHRcdHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0XHRcdHN0eWxlLmxlZnQgPSBvZmZzZXQueCArICdweCc7XG5cdFx0XHRzdHlsZS50b3AgPSBvZmZzZXQueSArICdweCc7XG5cdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXRzKTtcblx0XHR9XG5cdFx0Vmlldy5fdmlld3MucHVzaCh0aGlzKTtcblx0XHRWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdID0gdGhpcztcblx0XHR0aGlzLl92aWV3U2l6ZSA9IHNpemU7XG5cdFx0KHRoaXMuX21hdHJpeCA9IG5ldyBNYXRyaXgoKSkuX293bmVyID0gdGhpcztcblx0XHR0aGlzLl96b29tID0gMTtcblx0XHRpZiAoIVZpZXcuX2ZvY3VzZWQpXG5cdFx0XHRWaWV3Ll9mb2N1c2VkID0gdGhpcztcblx0XHR0aGlzLl9mcmFtZUl0ZW1zID0ge307XG5cdFx0dGhpcy5fZnJhbWVJdGVtQ291bnQgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wcm9qZWN0KVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmIChWaWV3Ll9mb2N1c2VkID09PSB0aGlzKVxuXHRcdFx0Vmlldy5fZm9jdXNlZCA9IG51bGw7XG5cdFx0Vmlldy5fdmlld3Muc3BsaWNlKFZpZXcuX3ZpZXdzLmluZGV4T2YodGhpcyksIDEpO1xuXHRcdGRlbGV0ZSBWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdO1xuXHRcdGlmICh0aGlzLl9wcm9qZWN0Ll92aWV3ID09PSB0aGlzKVxuXHRcdFx0dGhpcy5fcHJvamVjdC5fdmlldyA9IG51bGw7XG5cdFx0RG9tRXZlbnQucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3ZpZXdFdmVudHMpO1xuXHRcdERvbUV2ZW50LnJlbW92ZSh3aW5kb3csIHRoaXMuX3dpbmRvd0V2ZW50cyk7XG5cdFx0dGhpcy5fZWxlbWVudCA9IHRoaXMuX3Byb2plY3QgPSBudWxsO1xuXHRcdHRoaXMub2ZmKCdmcmFtZScpO1xuXHRcdHRoaXMuX2FuaW1hdGUgPSBmYWxzZTtcblx0XHR0aGlzLl9mcmFtZUl0ZW1zID0ge307XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2V2ZW50czoge1xuXHRcdG9uRnJhbWU6IHtcblx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBsYXkoKTtcblx0XHRcdH0sXG5cblx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25SZXNpemU6IHt9XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZhbHNlLFxuXHRfdGltZTogMCxcblx0X2NvdW50OiAwLFxuXG5cdF9yZXF1ZXN0RnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHREb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGF0Ll9yZXF1ZXN0ZWQgPSBmYWxzZTtcblx0XHRcdGlmICghdGhhdC5fYW5pbWF0ZSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dGhhdC5fcmVxdWVzdEZyYW1lKCk7XG5cdFx0XHR0aGF0Ll9oYW5kbGVGcmFtZSgpO1xuXHRcdH0sIHRoaXMuX2VsZW1lbnQpO1xuXHRcdHRoaXMuX3JlcXVlc3RlZCA9IHRydWU7XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXMuX3Njb3BlO1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpIC8gMTAwMCxcblx0XHRcdGRlbHRhID0gdGhpcy5fYmVmb3JlID8gbm93IC0gdGhpcy5fYmVmb3JlIDogMDtcblx0XHR0aGlzLl9iZWZvcmUgPSBub3c7XG5cdFx0dGhpcy5faGFuZGxpbmdGcmFtZSA9IHRydWU7XG5cdFx0dGhpcy5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKHtcblx0XHRcdGRlbHRhOiBkZWx0YSxcblx0XHRcdHRpbWU6IHRoaXMuX3RpbWUgKz0gZGVsdGEsXG5cdFx0XHRjb3VudDogdGhpcy5fY291bnQrK1xuXHRcdH0pKTtcblx0XHRpZiAodGhpcy5fc3RhdHMpXG5cdFx0XHR0aGlzLl9zdGF0cy51cGRhdGUoKTtcblx0XHR0aGlzLl9oYW5kbGluZ0ZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZUl0ZW06IGZ1bmN0aW9uKGl0ZW0sIGFuaW1hdGUpIHtcblx0XHR2YXIgaXRlbXMgPSB0aGlzLl9mcmFtZUl0ZW1zO1xuXHRcdGlmIChhbmltYXRlKSB7XG5cdFx0XHRpdGVtc1tpdGVtLl9pZF0gPSB7XG5cdFx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRcdHRpbWU6IDAsXG5cdFx0XHRcdGNvdW50OiAwXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCsrdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDEpXG5cdFx0XHRcdHRoaXMub24oJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSBpdGVtc1tpdGVtLl9pZF07XG5cdFx0XHRpZiAoLS10aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLm9mZignZnJhbWUnLCB0aGlzLl9oYW5kbGVGcmFtZUl0ZW1zKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lSXRlbXM6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9mcmFtZUl0ZW1zKSB7XG5cdFx0XHR2YXIgZW50cnkgPSB0aGlzLl9mcmFtZUl0ZW1zW2ldO1xuXHRcdFx0ZW50cnkuaXRlbS5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKGV2ZW50LCB7XG5cdFx0XHRcdHRpbWU6IGVudHJ5LnRpbWUgKz0gZXZlbnQuZGVsdGEsXG5cdFx0XHRcdGNvdW50OiBlbnRyeS5jb3VudCsrXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Byb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5faGFuZGxpbmdGcmFtZSlcblx0XHRcdHJldHVybjtcblx0XHRpZiAodGhpcy5fYW5pbWF0ZSkge1xuXHRcdFx0dGhpcy5faGFuZGxlRnJhbWUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0aWYgKGZsYWdzICYgMSlcblx0XHRcdHRoaXMuX3Byb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0fSxcblxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl9tYXRyaXguY29uY2F0ZW5hdGUobWF0cml4KTtcblx0XHR0aGlzLl9ib3VuZHMgPSBudWxsO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9lbGVtZW50O1xuXHR9LFxuXG5cdGdldFBpeGVsUmF0aW86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXhlbFJhdGlvO1xuXHR9LFxuXG5cdGdldFJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXhlbFJhdGlvICogNzI7XG5cdH0sXG5cblx0Z2V0Vmlld1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fdmlld1NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0Vmlld1NpemUnKTtcblx0fSxcblxuXHRzZXRWaWV3U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGRlbHRhID0gc2l6ZS5zdWJ0cmFjdCh0aGlzLl92aWV3U2l6ZSk7XG5cdFx0aWYgKGRlbHRhLmlzWmVybygpKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuX3ZpZXdTaXplLnNldChzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0dGhpcy5fc2V0Vmlld1NpemUoc2l6ZSk7XG5cdFx0dGhpcy5fYm91bmRzID0gbnVsbDtcblx0XHR0aGlzLmVtaXQoJ3Jlc2l6ZScsIHtcblx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRkZWx0YTogZGVsdGFcblx0XHR9KTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfc2V0Vmlld1NpemU6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG5cdFx0ZWxlbWVudC53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0ZWxlbWVudC5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fYm91bmRzKVxuXHRcdFx0dGhpcy5fYm91bmRzID0gdGhpcy5fbWF0cml4LmludmVydGVkKCkuX3RyYW5zZm9ybUJvdW5kcyhcblx0XHRcdFx0XHRuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLCB0aGlzLl92aWV3U2l6ZSkpO1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuZ2V0U2l6ZSgpO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKCk7XG5cdH0sXG5cblx0c2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuc2Nyb2xsQnkoY2VudGVyLnN1YnRyYWN0KHRoaXMuZ2V0Q2VudGVyKCkpKTtcblx0fSxcblxuXHRnZXRab29tOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcblx0fSxcblxuXHRzZXRab29tOiBmdW5jdGlvbih6b29tKSB7XG5cdFx0dGhpcy5fdHJhbnNmb3JtKG5ldyBNYXRyaXgoKS5zY2FsZSh6b29tIC8gdGhpcy5fem9vbSxcblx0XHRcdHRoaXMuZ2V0Q2VudGVyKCkpKTtcblx0XHR0aGlzLl96b29tID0gem9vbTtcblx0fSxcblxuXHRpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBEb21FbGVtZW50LmlzSW5WaWV3KHRoaXMuX2VsZW1lbnQpO1xuXHR9LFxuXG5cdHNjcm9sbEJ5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykubmVnYXRlKCkpKTtcblx0fSxcblxuXHRwbGF5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hbmltYXRlID0gdHJ1ZTtcblx0XHRpZiAoIXRoaXMuX3JlcXVlc3RlZClcblx0XHRcdHRoaXMuX3JlcXVlc3RGcmFtZSgpO1xuXHR9LFxuXG5cdHBhdXNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hbmltYXRlID0gZmFsc2U7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fSxcblxuXHRwcm9qZWN0VG9WaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHZpZXdUb1Byb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fVxuXG59LCB7XG5cdHN0YXRpY3M6IHtcblx0XHRfdmlld3M6IFtdLFxuXHRcdF92aWV3c0J5SWQ6IHt9LFxuXHRcdF9pZDogMCxcblxuXHRcdGNyZWF0ZTogZnVuY3Rpb24ocHJvamVjdCwgZWxlbWVudCkge1xuXHRcdFx0aWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJylcblx0XHRcdFx0ZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuXHRcdFx0cmV0dXJuIG5ldyBDYW52YXNWaWV3KHByb2plY3QsIGVsZW1lbnQpO1xuXHRcdH1cblx0fVxufSwgbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgdG9vbCxcblx0XHRwcmV2Rm9jdXMsXG5cdFx0dGVtcEZvY3VzLFxuXHRcdGRyYWdnaW5nID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gZ2V0VmlldyhldmVudCkge1xuXHRcdHZhciB0YXJnZXQgPSBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpO1xuXHRcdHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIFZpZXcuX3ZpZXdzQnlJZFt0YXJnZXQuZ2V0QXR0cmlidXRlKCdpZCcpXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpIHtcblx0XHRyZXR1cm4gdmlldy52aWV3VG9Qcm9qZWN0KERvbUV2ZW50LmdldE9mZnNldChldmVudCwgdmlldy5fZWxlbWVudCkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlRm9jdXMoKSB7XG5cdFx0aWYgKCFWaWV3Ll9mb2N1c2VkIHx8ICFWaWV3Ll9mb2N1c2VkLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IFZpZXcuX3ZpZXdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmlldyA9IFZpZXcuX3ZpZXdzW2ldO1xuXHRcdFx0XHRpZiAodmlldyAmJiB2aWV3LmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdFx0Vmlldy5fZm9jdXNlZCA9IHRlbXBGb2N1cyA9IHZpZXc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUodmlldywgcG9pbnQsIGV2ZW50KSB7XG5cdFx0dmlldy5faGFuZGxlRXZlbnQoJ21vdXNlbW92ZScsIHBvaW50LCBldmVudCk7XG5cdFx0dmFyIHRvb2wgPSB2aWV3Ll9zY29wZS50b29sO1xuXHRcdGlmICh0b29sKSB7XG5cdFx0XHR0b29sLl9oYW5kbGVFdmVudChkcmFnZ2luZyAmJiB0b29sLnJlc3BvbmRzKCdtb3VzZWRyYWcnKVxuXHRcdFx0XHRcdD8gJ21vdXNlZHJhZycgOiAnbW91c2Vtb3ZlJywgcG9pbnQsIGV2ZW50KTtcblx0XHR9XG5cdFx0dmlldy51cGRhdGUoKTtcblx0XHRyZXR1cm4gdG9vbDtcblx0fVxuXG5cdHZhciBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLFxuXHRcdG1vdXNlZG93biwgbW91c2Vtb3ZlLCBtb3VzZXVwO1xuXHRpZiAobmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG5cdFx0bW91c2Vkb3duID0gJ3BvaW50ZXJkb3duIE1TUG9pbnRlckRvd24nO1xuXHRcdG1vdXNlbW92ZSA9ICdwb2ludGVybW92ZSBNU1BvaW50ZXJNb3ZlJztcblx0XHRtb3VzZXVwID0gJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG5cdH0gZWxzZSB7XG5cdFx0bW91c2Vkb3duID0gJ3RvdWNoc3RhcnQnO1xuXHRcdG1vdXNlbW92ZSA9ICd0b3VjaG1vdmUnO1xuXHRcdG1vdXNldXAgPSAndG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXHRcdGlmICghKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKFxuXHRcdFx0XHQvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaSkpKSB7XG5cdFx0XHRtb3VzZWRvd24gKz0gJyBtb3VzZWRvd24nO1xuXHRcdFx0bW91c2Vtb3ZlICs9ICcgbW91c2Vtb3ZlJztcblx0XHRcdG1vdXNldXAgKz0gJyBtb3VzZXVwJztcblx0XHR9XG5cdH1cblxuXHR2YXIgdmlld0V2ZW50cyA9IHtcblx0XHQnc2VsZWN0c3RhcnQgZHJhZ3N0YXJ0JzogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmIChkcmFnZ2luZylcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIGRvY0V2ZW50cyA9IHtcblx0XHRtb3VzZW91dDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZCxcblx0XHRcdFx0dGFyZ2V0ID0gRG9tRXZlbnQuZ2V0UmVsYXRlZFRhcmdldChldmVudCk7XG5cdFx0XHRpZiAodmlldyAmJiAoIXRhcmdldCB8fCB0YXJnZXQubm9kZU5hbWUgPT09ICdIVE1MJykpXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZSh2aWV3LCB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KSwgZXZlbnQpO1xuXHRcdH0sXG5cblx0XHRzY3JvbGw6IHVwZGF0ZUZvY3VzXG5cdH07XG5cblx0dmlld0V2ZW50c1ttb3VzZWRvd25dID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQgPSBnZXRWaWV3KGV2ZW50KSxcblx0XHRcdHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0ZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZWRvd24nLCBwb2ludCwgZXZlbnQpO1xuXHRcdGlmICh0b29sID0gdmlldy5fc2NvcGUudG9vbClcblx0XHRcdHRvb2wuX2hhbmRsZUV2ZW50KCdtb3VzZWRvd24nLCBwb2ludCwgZXZlbnQpO1xuXHRcdHZpZXcudXBkYXRlKCk7XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNlbW92ZV0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblx0XHRpZiAoIWRyYWdnaW5nKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gZ2V0VmlldyhldmVudCk7XG5cdFx0XHRpZiAodGFyZ2V0KSB7XG5cdFx0XHRcdGlmICh2aWV3ICE9PSB0YXJnZXQpXG5cdFx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlKHZpZXcsIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpLCBldmVudCk7XG5cdFx0XHRcdHByZXZGb2N1cyA9IHZpZXc7XG5cdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gdGVtcEZvY3VzID0gdGFyZ2V0O1xuXHRcdFx0fSBlbHNlIGlmICh0ZW1wRm9jdXMgJiYgdGVtcEZvY3VzID09PSB2aWV3KSB7XG5cdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gcHJldkZvY3VzO1xuXHRcdFx0XHR1cGRhdGVGb2N1cygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodmlldykge1xuXHRcdFx0dmFyIHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0XHRpZiAoZHJhZ2dpbmcgfHwgdmlldy5nZXRCb3VuZHMoKS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdHRvb2wgPSBoYW5kbGVNb3VzZU1vdmUodmlldywgcG9pbnQsIGV2ZW50KTtcblx0XHR9XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNldXBdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cdFx0aWYgKCF2aWV3IHx8ICFkcmFnZ2luZylcblx0XHRcdHJldHVybjtcblx0XHR2YXIgcG9pbnQgPSB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KTtcblx0XHRkcmFnZ2luZyA9IGZhbHNlO1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZXVwJywgcG9pbnQsIGV2ZW50KTtcblx0XHRpZiAodG9vbClcblx0XHRcdHRvb2wuX2hhbmRsZUV2ZW50KCdtb3VzZXVwJywgcG9pbnQsIGV2ZW50KTtcblx0XHR2aWV3LnVwZGF0ZSgpO1xuXHR9O1xuXG5cdERvbUV2ZW50LmFkZChkb2N1bWVudCwgZG9jRXZlbnRzKTtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0bG9hZDogdXBkYXRlRm9jdXNcblx0fSk7XG5cblx0cmV0dXJuIHtcblx0XHRfdmlld0V2ZW50czogdmlld0V2ZW50cyxcblxuXHRcdF9oYW5kbGVFdmVudDogZnVuY3Rpb24oKSB7fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdHVwZGF0ZUZvY3VzOiB1cGRhdGVGb2N1c1xuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgQ2FudmFzVmlldyA9IFZpZXcuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ2FudmFzVmlldycsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ2FudmFzVmlldyhwcm9qZWN0LCBjYW52YXMpIHtcblx0XHRpZiAoIShjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkpIHtcblx0XHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0XHRpZiAoc2l6ZS5pc1plcm8oKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgQ2FudmFzVmlldyB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudDogJ1xuXHRcdFx0XHRcdFx0KyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuXHRcdFx0Y2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpO1xuXHRcdH1cblx0XHR0aGlzLl9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0dGhpcy5fZXZlbnRDb3VudGVycyA9IHt9O1xuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSAxO1xuXHRcdGlmICghL15vZmZ8ZmFsc2UkLy50ZXN0KFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGNhbnZhcywgJ2hpZHBpJykpKSB7XG5cdFx0XHR2YXIgZGV2aWNlUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuXHRcdFx0XHRiYWNraW5nU3RvcmVSYXRpbyA9IERvbUVsZW1lbnQuZ2V0UHJlZml4ZWQodGhpcy5fY29udGV4dCxcblx0XHRcdFx0XHRcdCdiYWNraW5nU3RvcmVQaXhlbFJhdGlvJykgfHwgMTtcblx0XHRcdHRoaXMuX3BpeGVsUmF0aW8gPSBkZXZpY2VSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuXHRcdH1cblx0XHRWaWV3LmNhbGwodGhpcywgcHJvamVjdCwgY2FudmFzKTtcblx0fSxcblxuXHRfc2V0Vmlld1NpemU6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQsXG5cdFx0XHRwaXhlbFJhdGlvID0gdGhpcy5fcGl4ZWxSYXRpbyxcblx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdGVsZW1lbnQud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG5cdFx0ZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXHRcdGlmIChwaXhlbFJhdGlvICE9PSAxKSB7XG5cdFx0XHRpZiAoIVBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdyZXNpemUnKSkge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBpeGVsU2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHZhciBicm93c2VyID0gcGFwZXIuYnJvd3Nlcixcblx0XHRcdHBpeGVscztcblx0XHRpZiAoYnJvd3NlciAmJiBicm93c2VyLmZpcmVmb3gpIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG5cdFx0XHRcdHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdHRlbXAuc3R5bGUuZm9udFNpemUgPSBzaXplO1xuXHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKHRlbXApO1xuXHRcdFx0cGl4ZWxzID0gcGFyc2VGbG9hdChEb21FbGVtZW50LmdldFN0eWxlcyh0ZW1wKS5mb250U2l6ZSk7XG5cdFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQodGVtcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0XHRwcmV2Rm9udCA9IGN0eC5mb250O1xuXHRcdFx0Y3R4LmZvbnQgPSBzaXplICsgJyBzZXJpZic7XG5cdFx0XHRwaXhlbHMgPSBwYXJzZUZsb2F0KGN0eC5mb250KTtcblx0XHRcdGN0eC5mb250ID0gcHJldkZvbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBwaXhlbHM7XG5cdH0sXG5cblx0Z2V0VGV4dFdpZHRoOiBmdW5jdGlvbihmb250LCBsaW5lcykge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0cHJldkZvbnQgPSBjdHguZm9udCxcblx0XHRcdHdpZHRoID0gMDtcblx0XHRjdHguZm9udCA9IGZvbnQ7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoKTtcblx0XHRjdHguZm9udCA9IHByZXZGb250O1xuXHRcdHJldHVybiB3aWR0aDtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKGZvcmNlKSB7XG5cdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdGlmICghcHJvamVjdCB8fCAhZm9yY2UgJiYgIXByb2plY3QuX25lZWRzVXBkYXRlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0c2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgc2l6ZS53aWR0aCArIDEsIHNpemUuaGVpZ2h0ICsgMSk7XG5cdFx0cHJvamVjdC5kcmF3KGN0eCwgdGhpcy5fbWF0cml4LCB0aGlzLl9waXhlbFJhdGlvKTtcblx0XHRwcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGRvd25Qb2ludCxcblx0XHRsYXN0UG9pbnQsXG5cdFx0b3ZlclBvaW50LFxuXHRcdGRvd25JdGVtLFxuXHRcdGxhc3RJdGVtLFxuXHRcdG92ZXJJdGVtLFxuXHRcdGRyYWdJdGVtLFxuXHRcdGRibENsaWNrLFxuXHRcdGNsaWNrVGltZTtcblxuXHRmdW5jdGlvbiBjYWxsRXZlbnQodmlldywgdHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQsIGxhc3RQb2ludCkge1xuXHRcdHZhciBpdGVtID0gdGFyZ2V0LFxuXHRcdFx0bW91c2VFdmVudDtcblxuXHRcdGZ1bmN0aW9uIGNhbGwob2JqKSB7XG5cdFx0XHRpZiAob2JqLnJlc3BvbmRzKHR5cGUpKSB7XG5cdFx0XHRcdGlmICghbW91c2VFdmVudCkge1xuXHRcdFx0XHRcdG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCxcblx0XHRcdFx0XHRcdFx0bGFzdFBvaW50ID8gcG9pbnQuc3VidHJhY3QobGFzdFBvaW50KSA6IG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvYmouZW1pdCh0eXBlLCBtb3VzZUV2ZW50KSAmJiBtb3VzZUV2ZW50LmlzU3RvcHBlZCkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR3aGlsZSAoaXRlbSkge1xuXHRcdFx0aWYgKGNhbGwoaXRlbSkpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0aXRlbSA9IGl0ZW0uZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdGlmIChjYWxsKHZpZXcpKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHBvaW50LCBldmVudCkge1xuXHRcdFx0aWYgKCF0aGlzLl9ldmVudENvdW50ZXJzW3R5cGVdKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdGhpdCA9IHByb2plY3QuaGl0VGVzdChwb2ludCwge1xuXHRcdFx0XHRcdHRvbGVyYW5jZTogMCxcblx0XHRcdFx0XHRmaWxsOiB0cnVlLFxuXHRcdFx0XHRcdHN0cm9rZTogdHJ1ZVxuXHRcdFx0XHR9KSxcblx0XHRcdFx0aXRlbSA9IGhpdCAmJiBoaXQuaXRlbSxcblx0XHRcdFx0c3RvcHBlZCA9IGZhbHNlO1xuXHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSk7XG5cdFx0XHRcdGRibENsaWNrID0gbGFzdEl0ZW0gPT0gaXRlbSAmJiAoRGF0ZS5ub3coKSAtIGNsaWNrVGltZSA8IDMwMCk7XG5cdFx0XHRcdGRvd25JdGVtID0gbGFzdEl0ZW0gPSBpdGVtO1xuXHRcdFx0XHRkb3duUG9pbnQgPSBsYXN0UG9pbnQgPSBvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0ZHJhZ0l0ZW0gPSAhc3RvcHBlZCAmJiBpdGVtO1xuXHRcdFx0XHR3aGlsZSAoZHJhZ0l0ZW0gJiYgIWRyYWdJdGVtLnJlc3BvbmRzKCdtb3VzZWRyYWcnKSlcblx0XHRcdFx0XHRkcmFnSXRlbSA9IGRyYWdJdGVtLl9wYXJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgdHlwZSwgZXZlbnQsIHBvaW50LCBpdGVtLCBkb3duUG9pbnQpO1xuXHRcdFx0XHRpZiAoZHJhZ0l0ZW0pIHtcblx0XHRcdFx0XHRpZiAobGFzdFBvaW50ICYmICFsYXN0UG9pbnQuZXF1YWxzKHBvaW50KSlcblx0XHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCAnbW91c2VkcmFnJywgZXZlbnQsIHBvaW50LCBkcmFnSXRlbSxcblx0XHRcdFx0XHRcdFx0XHRsYXN0UG9pbnQpO1xuXHRcdFx0XHRcdGlmIChpdGVtICE9PSBkcmFnSXRlbSkge1xuXHRcdFx0XHRcdFx0b3ZlclBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlbW92ZScsIGV2ZW50LCBwb2ludCwgaXRlbSxcblx0XHRcdFx0XHRcdFx0XHRvdmVyUG9pbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN0b3BwZWQgJiYgaXRlbSAmJiBpdGVtID09PSBkb3duSXRlbSkge1xuXHRcdFx0XHRcdGNsaWNrVGltZSA9IERhdGUubm93KCk7XG5cdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsIGRibENsaWNrICYmIGRvd25JdGVtLnJlc3BvbmRzKCdkb3VibGVjbGljaycpXG5cdFx0XHRcdFx0XHRcdD8gJ2RvdWJsZWNsaWNrJyA6ICdjbGljaycsIGV2ZW50LCBkb3duUG9pbnQsIGl0ZW0pO1xuXHRcdFx0XHRcdGRibENsaWNrID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZG93bkl0ZW0gPSBkcmFnSXRlbSA9IG51bGw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0aWYgKGRyYWdJdGVtKVxuXHRcdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgJ21vdXNlZHJhZycsIGV2ZW50LCBwb2ludCxcblx0XHRcdFx0XHRcdFx0ZHJhZ0l0ZW0sIGxhc3RQb2ludCk7XG5cdFx0XHRcdGlmICghc3RvcHBlZCkge1xuXHRcdFx0XHRcdGlmIChpdGVtICE9PSBvdmVySXRlbSlcblx0XHRcdFx0XHRcdG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgdHlwZSwgZXZlbnQsIHBvaW50LCBpdGVtLFxuXHRcdFx0XHRcdFx0XHRvdmVyUG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RQb2ludCA9IG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRpZiAoaXRlbSAhPT0gb3Zlckl0ZW0pIHtcblx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlbGVhdmUnLCBldmVudCwgcG9pbnQsIG92ZXJJdGVtKTtcblx0XHRcdFx0XHRvdmVySXRlbSA9IGl0ZW07XG5cdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZWVudGVyJywgZXZlbnQsIHBvaW50LCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdG9wcGVkO1xuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgRXZlbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0V2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBFdmVudChldmVudCkge1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0fSxcblxuXHRpc1ByZXZlbnRlZDogZmFsc2UsXG5cdGlzU3RvcHBlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaXNQcmV2ZW50ZWQgPSB0cnVlO1xuXHRcdHRoaXMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fSxcblxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcblx0XHR0aGlzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0dGhpcy5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9LFxuXG5cdGdldE1vZGlmaWVyczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEtleS5tb2RpZmllcnM7XG5cdH1cbn0pO1xuXG52YXIgS2V5RXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdLZXlFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gS2V5RXZlbnQoZG93biwga2V5LCBjaGFyYWN0ZXIsIGV2ZW50KSB7XG5cdFx0RXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0dGhpcy50eXBlID0gZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCc7XG5cdFx0dGhpcy5rZXkgPSBrZXk7XG5cdFx0dGhpcy5jaGFyYWN0ZXIgPSBjaGFyYWN0ZXI7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgXCInLCBrZXk6ICdcIiArIHRoaXMua2V5XG5cdFx0XHRcdCsgXCInLCBjaGFyYWN0ZXI6ICdcIiArIHRoaXMuY2hhcmFjdGVyXG5cdFx0XHRcdCsgXCInLCBtb2RpZmllcnM6IFwiICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrIFwiIH1cIjtcblx0fVxufSk7XG5cbnZhciBLZXkgPSBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIHNwZWNpYWxLZXlzID0ge1xuXHRcdDg6ICdiYWNrc3BhY2UnLFxuXHRcdDk6ICd0YWInLFxuXHRcdDEzOiAnZW50ZXInLFxuXHRcdDE2OiAnc2hpZnQnLFxuXHRcdDE3OiAnY29udHJvbCcsXG5cdFx0MTg6ICdvcHRpb24nLFxuXHRcdDE5OiAncGF1c2UnLFxuXHRcdDIwOiAnY2Fwcy1sb2NrJyxcblx0XHQyNzogJ2VzY2FwZScsXG5cdFx0MzI6ICdzcGFjZScsXG5cdFx0MzU6ICdlbmQnLFxuXHRcdDM2OiAnaG9tZScsXG5cdFx0Mzc6ICdsZWZ0Jyxcblx0XHQzODogJ3VwJyxcblx0XHQzOTogJ3JpZ2h0Jyxcblx0XHQ0MDogJ2Rvd24nLFxuXHRcdDQ2OiAnZGVsZXRlJyxcblx0XHQ5MTogJ2NvbW1hbmQnLFxuXHRcdDkzOiAnY29tbWFuZCcsXG5cdFx0MjI0OiAnY29tbWFuZCdcblx0fSxcblxuXHRzcGVjaWFsQ2hhcnMgPSB7XG5cdFx0OTogdHJ1ZSxcblx0XHQxMzogdHJ1ZSxcblx0XHQzMjogdHJ1ZVxuXHR9LFxuXG5cdG1vZGlmaWVycyA9IG5ldyBCYXNlKHtcblx0XHRzaGlmdDogZmFsc2UsXG5cdFx0Y29udHJvbDogZmFsc2UsXG5cdFx0b3B0aW9uOiBmYWxzZSxcblx0XHRjb21tYW5kOiBmYWxzZSxcblx0XHRjYXBzTG9jazogZmFsc2UsXG5cdFx0c3BhY2U6IGZhbHNlXG5cdH0pLFxuXG5cdGNoYXJDb2RlTWFwID0ge30sXG5cdGtleU1hcCA9IHt9LFxuXHRjb21tYW5kRml4TWFwLFxuXHRkb3duQ29kZTtcblxuXHRmdW5jdGlvbiBoYW5kbGVLZXkoZG93biwga2V5Q29kZSwgY2hhckNvZGUsIGV2ZW50KSB7XG5cdFx0dmFyIGNoYXJhY3RlciA9IGNoYXJDb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSkgOiAnJyxcblx0XHRcdHNwZWNpYWxLZXkgPSBzcGVjaWFsS2V5c1trZXlDb2RlXSxcblx0XHRcdGtleSA9IHNwZWNpYWxLZXkgfHwgY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCksXG5cdFx0XHR0eXBlID0gZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCcsXG5cdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCxcblx0XHRcdHNjb3BlID0gdmlldyAmJiB2aWV3LmlzVmlzaWJsZSgpICYmIHZpZXcuX3Njb3BlLFxuXHRcdFx0dG9vbCA9IHNjb3BlICYmIHNjb3BlLnRvb2wsXG5cdFx0XHRuYW1lO1xuXHRcdGtleU1hcFtrZXldID0gZG93bjtcblx0XHRpZiAoZG93bikge1xuXHRcdFx0Y2hhckNvZGVNYXBba2V5Q29kZV0gPSBjaGFyQ29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIGNoYXJDb2RlTWFwW2tleUNvZGVdO1xuXHRcdH1cblx0XHRpZiAoc3BlY2lhbEtleSAmJiAobmFtZSA9IEJhc2UuY2FtZWxpemUoc3BlY2lhbEtleSkpIGluIG1vZGlmaWVycykge1xuXHRcdFx0bW9kaWZpZXJzW25hbWVdID0gZG93bjtcblx0XHRcdHZhciBicm93c2VyID0gcGFwZXIuYnJvd3Nlcjtcblx0XHRcdGlmIChuYW1lID09PSAnY29tbWFuZCcgJiYgYnJvd3NlciAmJiBicm93c2VyLm1hYykge1xuXHRcdFx0XHRpZiAoZG93bikge1xuXHRcdFx0XHRcdGNvbW1hbmRGaXhNYXAgPSB7fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBjb2RlIGluIGNvbW1hbmRGaXhNYXApIHtcblx0XHRcdFx0XHRcdGlmIChjb2RlIGluIGNoYXJDb2RlTWFwKVxuXHRcdFx0XHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGNvZGUsIGNvbW1hbmRGaXhNYXBbY29kZV0sIGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29tbWFuZEZpeE1hcCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGRvd24gJiYgY29tbWFuZEZpeE1hcCkge1xuXHRcdFx0Y29tbWFuZEZpeE1hcFtrZXlDb2RlXSA9IGNoYXJDb2RlO1xuXHRcdH1cblx0XHRpZiAodG9vbCAmJiB0b29sLnJlc3BvbmRzKHR5cGUpKSB7XG5cdFx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdFx0dG9vbC5lbWl0KHR5cGUsIG5ldyBLZXlFdmVudChkb3duLCBrZXksIGNoYXJhY3RlciwgZXZlbnQpKTtcblx0XHRcdGlmICh2aWV3KVxuXHRcdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdH1cblx0fVxuXG5cdERvbUV2ZW50LmFkZChkb2N1bWVudCwge1xuXHRcdGtleWRvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgY29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XG5cdFx0XHRpZiAoY29kZSBpbiBzcGVjaWFsS2V5cyB8fCBtb2RpZmllcnMuY29tbWFuZCkge1xuXHRcdFx0XHRoYW5kbGVLZXkodHJ1ZSwgY29kZSxcblx0XHRcdFx0XHRcdGNvZGUgaW4gc3BlY2lhbENoYXJzIHx8IG1vZGlmaWVycy5jb21tYW5kID8gY29kZSA6IDAsXG5cdFx0XHRcdFx0XHRldmVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb3duQ29kZSA9IGNvZGU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGtleXByZXNzOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYgKGRvd25Db2RlICE9IG51bGwpIHtcblx0XHRcdFx0aGFuZGxlS2V5KHRydWUsIGRvd25Db2RlLCBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlLCBldmVudCk7XG5cdFx0XHRcdGRvd25Db2RlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0a2V5dXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgY29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XG5cdFx0XHRpZiAoY29kZSBpbiBjaGFyQ29kZU1hcClcblx0XHRcdFx0aGFuZGxlS2V5KGZhbHNlLCBjb2RlLCBjaGFyQ29kZU1hcFtjb2RlXSwgZXZlbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0RG9tRXZlbnQuYWRkKHdpbmRvdywge1xuXHRcdGJsdXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRmb3IgKHZhciBjb2RlIGluIGNoYXJDb2RlTWFwKVxuXHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGNvZGUsIGNoYXJDb2RlTWFwW2NvZGVdLCBldmVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4ge1xuXHRcdG1vZGlmaWVyczogbW9kaWZpZXJzLFxuXG5cdFx0aXNEb3duOiBmdW5jdGlvbihrZXkpIHtcblx0XHRcdHJldHVybiAhIWtleU1hcFtrZXldO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBNb3VzZUV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTW91c2VFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCwgZGVsdGEpIHtcblx0XHRFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMucG9pbnQgPSBwb2ludDtcblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0XHR0aGlzLmRlbHRhID0gZGVsdGE7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgXCInLCBwb2ludDogXCIgKyB0aGlzLnBvaW50XG5cdFx0XHRcdCsgJywgdGFyZ2V0OiAnICsgdGhpcy50YXJnZXRcblx0XHRcdFx0KyAodGhpcy5kZWx0YSA/ICcsIGRlbHRhOiAnICsgdGhpcy5kZWx0YSA6ICcnKVxuXHRcdFx0XHQrICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyAnIH0nO1xuXHR9XG59KTtcblxudmFyIFRvb2xFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ1Rvb2xFdmVudCcsXG5cdF9pdGVtOiBudWxsLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2xFdmVudCh0b29sLCB0eXBlLCBldmVudCkge1xuXHRcdHRoaXMudG9vbCA9IHRvb2w7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdH0sXG5cblx0X2Nob29zZVBvaW50OiBmdW5jdGlvbihwb2ludCwgdG9vbFBvaW50KSB7XG5cdFx0cmV0dXJuIHBvaW50ID8gcG9pbnQgOiB0b29sUG9pbnQgPyB0b29sUG9pbnQuY2xvbmUoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9wb2ludCwgdGhpcy50b29sLl9wb2ludCk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludDtcblx0fSxcblxuXHRnZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9sYXN0UG9pbnQsIHRoaXMudG9vbC5fbGFzdFBvaW50KTtcblx0fSxcblxuXHRzZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKGxhc3RQb2ludCkge1xuXHRcdHRoaXMuX2xhc3RQb2ludCA9IGxhc3RQb2ludDtcblx0fSxcblxuXHRnZXREb3duUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9kb3duUG9pbnQsIHRoaXMudG9vbC5fZG93blBvaW50KTtcblx0fSxcblxuXHRzZXREb3duUG9pbnQ6IGZ1bmN0aW9uKGRvd25Qb2ludCkge1xuXHRcdHRoaXMuX2Rvd25Qb2ludCA9IGRvd25Qb2ludDtcblx0fSxcblxuXHRnZXRNaWRkbGVQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9taWRkbGVQb2ludCAmJiB0aGlzLnRvb2wuX2xhc3RQb2ludCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudG9vbC5fcG9pbnQuYWRkKHRoaXMudG9vbC5fbGFzdFBvaW50KS5kaXZpZGUoMik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9taWRkbGVQb2ludDtcblx0fSxcblxuXHRzZXRNaWRkbGVQb2ludDogZnVuY3Rpb24obWlkZGxlUG9pbnQpIHtcblx0XHR0aGlzLl9taWRkbGVQb2ludCA9IG1pZGRsZVBvaW50O1xuXHR9LFxuXG5cdGdldERlbHRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2RlbHRhICYmIHRoaXMudG9vbC5fbGFzdFBvaW50XG5cdFx0XHRcdD8gdGhpcy50b29sLl9wb2ludC5zdWJ0cmFjdCh0aGlzLnRvb2wuX2xhc3RQb2ludClcblx0XHRcdFx0OiB0aGlzLl9kZWx0YTtcblx0fSxcblxuXHRzZXREZWx0YTogZnVuY3Rpb24oZGVsdGEpIHtcblx0XHR0aGlzLl9kZWx0YSA9IGRlbHRhO1xuXHR9LFxuXG5cdGdldENvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKVxuXHRcdFx0XHQ/IHRoaXMudG9vbC5fZG93bkNvdW50XG5cdFx0XHRcdDogdGhpcy50b29sLl9jb3VudDtcblx0fSxcblxuXHRzZXRDb3VudDogZnVuY3Rpb24oY291bnQpIHtcblx0XHR0aGlzLnRvb2xbL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKSA/ICdkb3duQ291bnQnIDogJ2NvdW50J11cblx0XHRcdD0gY291bnQ7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9pdGVtKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy50b29sLl9zY29wZS5wcm9qZWN0LmhpdFRlc3QodGhpcy5nZXRQb2ludCgpKTtcblx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSByZXN1bHQuaXRlbSxcblx0XHRcdFx0XHRwYXJlbnQgPSBpdGVtLl9wYXJlbnQ7XG5cdFx0XHRcdHdoaWxlICgvXihHcm91cHxDb21wb3VuZFBhdGgpJC8udGVzdChwYXJlbnQuX2NsYXNzKSkge1xuXHRcdFx0XHRcdGl0ZW0gPSBwYXJlbnQ7XG5cdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9pdGVtO1xuXHR9LFxuXG5cdHNldEl0ZW06IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR0aGlzLl9pdGVtID0gaXRlbTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICd7IHR5cGU6ICcgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyAnLCBwb2ludDogJyArIHRoaXMuZ2V0UG9pbnQoKVxuXHRcdFx0XHQrICcsIGNvdW50OiAnICsgdGhpcy5nZXRDb3VudCgpXG5cdFx0XHRcdCsgJywgbW9kaWZpZXJzOiAnICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrICcgfSc7XG5cdH1cbn0pO1xuXG52YXIgVG9vbCA9IFBhcGVyU2NvcGVJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1Rvb2wnLFxuXHRfbGlzdDogJ3Rvb2xzJyxcblx0X3JlZmVyZW5jZTogJ3Rvb2wnLFxuXHRfZXZlbnRzOiBbICdvbkFjdGl2YXRlJywgJ29uRGVhY3RpdmF0ZScsICdvbkVkaXRPcHRpb25zJyxcblx0XHRcdCdvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZURyYWcnLCAnb25Nb3VzZU1vdmUnLFxuXHRcdFx0J29uS2V5RG93bicsICdvbktleVVwJyBdLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2wocHJvcHMpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX2ZpcnN0TW92ZSA9IHRydWU7XG5cdFx0dGhpcy5fY291bnQgPSAwO1xuXHRcdHRoaXMuX2Rvd25Db3VudCA9IDA7XG5cdFx0dGhpcy5fc2V0KHByb3BzKTtcblx0fSxcblxuXHRnZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlO1xuXHR9LFxuXG5cdHNldE1pbkRpc3RhbmNlOiBmdW5jdGlvbihtaW5EaXN0YW5jZSkge1xuXHRcdHRoaXMuX21pbkRpc3RhbmNlID0gbWluRGlzdGFuY2U7XG5cdFx0aWYgKG1pbkRpc3RhbmNlICE9IG51bGwgJiYgdGhpcy5fbWF4RGlzdGFuY2UgIT0gbnVsbFxuXHRcdFx0XHQmJiBtaW5EaXN0YW5jZSA+IHRoaXMuX21heERpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuXHRcdH1cblx0fSxcblxuXHRnZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21heERpc3RhbmNlO1xuXHR9LFxuXG5cdHNldE1heERpc3RhbmNlOiBmdW5jdGlvbihtYXhEaXN0YW5jZSkge1xuXHRcdHRoaXMuX21heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG5cdFx0aWYgKHRoaXMuX21pbkRpc3RhbmNlICE9IG51bGwgJiYgbWF4RGlzdGFuY2UgIT0gbnVsbFxuXHRcdFx0XHQmJiBtYXhEaXN0YW5jZSA8IHRoaXMuX21pbkRpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuXHRcdH1cblx0fSxcblxuXHRnZXRGaXhlZERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2UgPT0gdGhpcy5fbWF4RGlzdGFuY2Vcblx0XHRcdD8gdGhpcy5fbWluRGlzdGFuY2UgOiBudWxsO1xuXHR9LFxuXG5cdHNldEZpeGVkRGlzdGFuY2U6IGZ1bmN0aW9uKGRpc3RhbmNlKSB7XG5cdFx0dGhpcy5fbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHR9LFxuXG5cdF91cGRhdGVFdmVudDogZnVuY3Rpb24odHlwZSwgcG9pbnQsIG1pbkRpc3RhbmNlLCBtYXhEaXN0YW5jZSwgc3RhcnQsXG5cdFx0XHRuZWVkc0NoYW5nZSwgbWF0Y2hNYXhEaXN0YW5jZSkge1xuXHRcdGlmICghc3RhcnQpIHtcblx0XHRcdGlmIChtaW5EaXN0YW5jZSAhPSBudWxsIHx8IG1heERpc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIG1pbkRpc3QgPSBtaW5EaXN0YW5jZSAhPSBudWxsID8gbWluRGlzdGFuY2UgOiAwLFxuXHRcdFx0XHRcdHZlY3RvciA9IHBvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KSxcblx0XHRcdFx0XHRkaXN0YW5jZSA9IHZlY3Rvci5nZXRMZW5ndGgoKTtcblx0XHRcdFx0aWYgKGRpc3RhbmNlIDwgbWluRGlzdClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlmIChtYXhEaXN0YW5jZSAhPSBudWxsICYmIG1heERpc3RhbmNlICE9IDApIHtcblx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0cG9pbnQgPSB0aGlzLl9wb2ludC5hZGQodmVjdG9yLm5vcm1hbGl6ZShtYXhEaXN0YW5jZSkpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobWF0Y2hNYXhEaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG5lZWRzQ2hhbmdlICYmIHBvaW50LmVxdWFscyh0aGlzLl9wb2ludCkpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5fbGFzdFBvaW50ID0gc3RhcnQgJiYgdHlwZSA9PSAnbW91c2Vtb3ZlJyA/IHBvaW50IDogdGhpcy5fcG9pbnQ7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludDtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0dGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fZG93blBvaW50O1xuXHRcdFx0dGhpcy5fZG93blBvaW50ID0gdGhpcy5fcG9pbnQ7XG5cdFx0XHR0aGlzLl9kb3duQ291bnQrKztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0dGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fZG93blBvaW50O1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHRoaXMuX2NvdW50ID0gc3RhcnQgPyAwIDogdGhpcy5fY291bnQgKyAxO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50KSB7XG5cdFx0dmFyIHNldHMgPSBwYXBlci5wcm9qZWN0Ll9yZW1vdmVTZXRzO1xuXHRcdGlmIChzZXRzKSB7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNldXAnKVxuXHRcdFx0XHRzZXRzLm1vdXNlZHJhZyA9IG51bGw7XG5cdFx0XHR2YXIgc2V0ID0gc2V0c1t0eXBlXTtcblx0XHRcdGlmIChzZXQpIHtcblx0XHRcdFx0Zm9yICh2YXIgaWQgaW4gc2V0KSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSBzZXRbaWRdO1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBzZXRzKSB7XG5cdFx0XHRcdFx0XHR2YXIgb3RoZXIgPSBzZXRzW2tleV07XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIgJiYgb3RoZXIgIT0gc2V0KVxuXHRcdFx0XHRcdFx0XHRkZWxldGUgb3RoZXJbaXRlbS5faWRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldHNbdHlwZV0gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5yZXNwb25kcyh0eXBlKVxuXHRcdFx0XHQmJiB0aGlzLmVtaXQodHlwZSwgbmV3IFRvb2xFdmVudCh0aGlzLCB0eXBlLCBldmVudCkpO1xuXHR9LFxuXG5cdF9oYW5kbGVFdmVudDogZnVuY3Rpb24odHlwZSwgcG9pbnQsIGV2ZW50KSB7XG5cdFx0cGFwZXIgPSB0aGlzLl9zY29wZTtcblx0XHR2YXIgY2FsbGVkID0gZmFsc2U7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCBudWxsLCBudWxsLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNlZHJhZyc6XG5cdFx0XHR2YXIgbmVlZHNDaGFuZ2UgPSBmYWxzZSxcblx0XHRcdFx0bWF0Y2hNYXhEaXN0YW5jZSA9IGZhbHNlO1xuXHRcdFx0d2hpbGUgKHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCB0aGlzLm1pbkRpc3RhbmNlLFxuXHRcdFx0XHRcdHRoaXMubWF4RGlzdGFuY2UsIGZhbHNlLCBuZWVkc0NoYW5nZSwgbWF0Y2hNYXhEaXN0YW5jZSkpIHtcblx0XHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KSB8fCBjYWxsZWQ7XG5cdFx0XHRcdG5lZWRzQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0bWF0Y2hNYXhEaXN0YW5jZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdGlmICghcG9pbnQuZXF1YWxzKHRoaXMuX3BvaW50KVxuXHRcdFx0XHRcdCYmIHRoaXMuX3VwZGF0ZUV2ZW50KCdtb3VzZWRyYWcnLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdFx0XHRcdFx0dGhpcy5tYXhEaXN0YW5jZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSkpIHtcblx0XHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KCdtb3VzZWRyYWcnLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgbnVsbCwgdGhpcy5tYXhEaXN0YW5jZSwgZmFsc2UsXG5cdFx0XHRcdFx0ZmFsc2UsIGZhbHNlKTtcblx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCh0eXBlLCBldmVudCkgfHwgY2FsbGVkO1xuXHRcdFx0dGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIG51bGwsIG51bGwsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9maXJzdE1vdmUgPSB0cnVlO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdHdoaWxlICh0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdFx0XHR0aGlzLm1heERpc3RhbmNlLCB0aGlzLl9maXJzdE1vdmUsIHRydWUsIGZhbHNlKSkge1xuXHRcdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQodHlwZSwgZXZlbnQpIHx8IGNhbGxlZDtcblx0XHRcdFx0dGhpcy5fZmlyc3RNb3ZlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aWYgKGNhbGxlZClcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0cmV0dXJuIGNhbGxlZDtcblx0fVxuXG59KTtcblxudmFyIEh0dHAgPSB7XG5cdHJlcXVlc3Q6IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBjYWxsYmFjaywgYXN5bmMpIHtcblx0XHRhc3luYyA9IChhc3luYyA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBhc3luYztcblx0XHR2YXIgeGhyID0gbmV3ICh3aW5kb3cuQWN0aXZlWE9iamVjdCB8fCBYTUxIdHRwUmVxdWVzdCkoXG5cdFx0XHRcdFx0J01pY3Jvc29mdC5YTUxIVFRQJyk7XG5cdFx0eGhyLm9wZW4obWV0aG9kLnRvVXBwZXJDYXNlKCksIHVybCwgYXN5bmMpO1xuXHRcdGlmICgnb3ZlcnJpZGVNaW1lVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW4nKTtcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0dmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cdFx0XHRcdGlmIChzdGF0dXMgPT09IDAgfHwgc3RhdHVzID09PSAyMDApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHhociwgeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCAnICsgdXJsICsgJyAoRXJyb3IgJ1xuXHRcdFx0XHRcdFx0XHQrIHN0YXR1cyArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiB4aHIuc2VuZChudWxsKTtcblx0fVxufTtcblxudmFyIENhbnZhc1Byb3ZpZGVyID0ge1xuXHRjYW52YXNlczogW10sXG5cblx0Z2V0Q2FudmFzOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIGNhbnZhcyxcblx0XHRcdGNsZWFyID0gdHJ1ZTtcblx0XHRpZiAodHlwZW9mIHdpZHRoID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aGVpZ2h0ID0gd2lkdGguaGVpZ2h0O1xuXHRcdFx0d2lkdGggPSB3aWR0aC53aWR0aDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY2FudmFzZXMubGVuZ3RoKSB7XG5cdFx0XHRjYW52YXMgPSB0aGlzLmNhbnZhc2VzLnBvcCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHR9XG5cdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGlmIChjYW52YXMud2lkdGggPT09IHdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IGhlaWdodCkge1xuXHRcdFx0aWYgKGNsZWFyKVxuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoICsgMSwgaGVpZ2h0ICsgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRyZXR1cm4gY2FudmFzO1xuXHR9LFxuXG5cdGdldENvbnRleHQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDYW52YXMod2lkdGgsIGhlaWdodCkuZ2V0Q29udGV4dCgnMmQnKTtcblx0fSxcblxuXHRyZWxlYXNlOiBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIgY2FudmFzID0gb2JqLmNhbnZhcyA/IG9iai5jYW52YXMgOiBvYmo7XG5cdFx0Y2FudmFzLmdldENvbnRleHQoJzJkJykucmVzdG9yZSgpO1xuXHRcdHRoaXMuY2FudmFzZXMucHVzaChjYW52YXMpO1xuXHR9XG59O1xuXG52YXIgQmxlbmRNb2RlID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgbWluID0gTWF0aC5taW4sXG5cdFx0bWF4ID0gTWF0aC5tYXgsXG5cdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0c3IsIHNnLCBzYiwgc2EsXG5cdFx0YnIsIGJnLCBiYiwgYmEsXG5cdFx0ZHIsIGRnLCBkYjtcblxuXHRmdW5jdGlvbiBnZXRMdW0ociwgZywgYikge1xuXHRcdHJldHVybiAwLjI5ODkgKiByICsgMC41ODcgKiBnICsgMC4xMTQgKiBiO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0THVtKHIsIGcsIGIsIGwpIHtcblx0XHR2YXIgZCA9IGwgLSBnZXRMdW0ociwgZywgYik7XG5cdFx0ZHIgPSByICsgZDtcblx0XHRkZyA9IGcgKyBkO1xuXHRcdGRiID0gYiArIGQ7XG5cdFx0dmFyIGwgPSBnZXRMdW0oZHIsIGRnLCBkYiksXG5cdFx0XHRtbiA9IG1pbihkciwgZGcsIGRiKSxcblx0XHRcdG14ID0gbWF4KGRyLCBkZywgZGIpO1xuXHRcdGlmIChtbiA8IDApIHtcblx0XHRcdHZhciBsbW4gPSBsIC0gbW47XG5cdFx0XHRkciA9IGwgKyAoZHIgLSBsKSAqIGwgLyBsbW47XG5cdFx0XHRkZyA9IGwgKyAoZGcgLSBsKSAqIGwgLyBsbW47XG5cdFx0XHRkYiA9IGwgKyAoZGIgLSBsKSAqIGwgLyBsbW47XG5cdFx0fVxuXHRcdGlmIChteCA+IDI1NSkge1xuXHRcdFx0dmFyIGxuID0gMjU1IC0gbCxcblx0XHRcdFx0bXhsID0gbXggLSBsO1xuXHRcdFx0ZHIgPSBsICsgKGRyIC0gbCkgKiBsbiAvIG14bDtcblx0XHRcdGRnID0gbCArIChkZyAtIGwpICogbG4gLyBteGw7XG5cdFx0XHRkYiA9IGwgKyAoZGIgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFNhdChyLCBnLCBiKSB7XG5cdFx0cmV0dXJuIG1heChyLCBnLCBiKSAtIG1pbihyLCBnLCBiKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFNhdChyLCBnLCBiLCBzKSB7XG5cdFx0dmFyIGNvbCA9IFtyLCBnLCBiXSxcblx0XHRcdG14ID0gbWF4KHIsIGcsIGIpLFxuXHRcdFx0bW4gPSBtaW4ociwgZywgYiksXG5cdFx0XHRtZDtcblx0XHRtbiA9IG1uID09PSByID8gMCA6IG1uID09PSBnID8gMSA6IDI7XG5cdFx0bXggPSBteCA9PT0gciA/IDAgOiBteCA9PT0gZyA/IDEgOiAyO1xuXHRcdG1kID0gbWluKG1uLCBteCkgPT09IDAgPyBtYXgobW4sIG14KSA9PT0gMSA/IDIgOiAxIDogMDtcblx0XHRpZiAoY29sW214XSA+IGNvbFttbl0pIHtcblx0XHRcdGNvbFttZF0gPSAoY29sW21kXSAtIGNvbFttbl0pICogcyAvIChjb2xbbXhdIC0gY29sW21uXSk7XG5cdFx0XHRjb2xbbXhdID0gcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29sW21kXSA9IGNvbFtteF0gPSAwO1xuXHRcdH1cblx0XHRjb2xbbW5dID0gMDtcblx0XHRkciA9IGNvbFswXTtcblx0XHRkZyA9IGNvbFsxXTtcblx0XHRkYiA9IGNvbFsyXTtcblx0fVxuXG5cdHZhciBtb2RlcyA9IHtcblx0XHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyICogc3IgLyAyNTU7XG5cdFx0XHRkZyA9IGJnICogc2cgLyAyNTU7XG5cdFx0XHRkYiA9IGJiICogc2IgLyAyNTU7XG5cdFx0fSxcblxuXHRcdHNjcmVlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyICsgc3IgLSAoYnIgKiBzciAvIDI1NSk7XG5cdFx0XHRkZyA9IGJnICsgc2cgLSAoYmcgKiBzZyAvIDI1NSk7XG5cdFx0XHRkYiA9IGJiICsgc2IgLSAoYmIgKiBzYiAvIDI1NSk7XG5cdFx0fSxcblxuXHRcdG92ZXJsYXk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA8IDEyOCA/IDIgKiBiciAqIHNyIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBicikgKiAoMjU1IC0gc3IpIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyA8IDEyOCA/IDIgKiBiZyAqIHNnIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBiZykgKiAoMjU1IC0gc2cpIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiA8IDEyOCA/IDIgKiBiYiAqIHNiIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBiYikgKiAoMjU1IC0gc2IpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHQnc29mdC1saWdodCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHQgPSBzciAqIGJyIC8gMjU1O1xuXHRcdFx0ZHIgPSB0ICsgYnIgKiAoMjU1IC0gKDI1NSAtIGJyKSAqICgyNTUgLSBzcikgLyAyNTUgLSB0KSAvIDI1NTtcblx0XHRcdHQgPSBzZyAqIGJnIC8gMjU1O1xuXHRcdFx0ZGcgPSB0ICsgYmcgKiAoMjU1IC0gKDI1NSAtIGJnKSAqICgyNTUgLSBzZykgLyAyNTUgLSB0KSAvIDI1NTtcblx0XHRcdHQgPSBzYiAqIGJiIC8gMjU1O1xuXHRcdFx0ZGIgPSB0ICsgYmIgKiAoMjU1IC0gKDI1NSAtIGJiKSAqICgyNTUgLSBzYikgLyAyNTUgLSB0KSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0J2hhcmQtbGlnaHQnOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gc3IgPCAxMjggPyAyICogc3IgKiBiciAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gc3IpICogKDI1NSAtIGJyKSAvIDI1NTtcblx0XHRcdGRnID0gc2cgPCAxMjggPyAyICogc2cgKiBiZyAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gc2cpICogKDI1NSAtIGJnKSAvIDI1NTtcblx0XHRcdGRiID0gc2IgPCAxMjggPyAyICogc2IgKiBiYiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gc2IpICogKDI1NSAtIGJiKSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0J2NvbG9yLWRvZGdlJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyID09PSAwID8gMCA6IHNyID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiciAvICgyNTUgLSBzcikpO1xuXHRcdFx0ZGcgPSBiZyA9PT0gMCA/IDAgOiBzZyA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYmcgLyAoMjU1IC0gc2cpKTtcblx0XHRcdGRiID0gYmIgPT09IDAgPyAwIDogc2IgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJiIC8gKDI1NSAtIHNiKSk7XG5cdFx0fSxcblxuXHRcdCdjb2xvci1idXJuJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyID09PSAyNTUgPyAyNTUgOiBzciA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJyKSAqIDI1NSAvIHNyKTtcblx0XHRcdGRnID0gYmcgPT09IDI1NSA/IDI1NSA6IHNnID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYmcpICogMjU1IC8gc2cpO1xuXHRcdFx0ZGIgPSBiYiA9PT0gMjU1ID8gMjU1IDogc2IgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBiYikgKiAyNTUgLyBzYik7XG5cdFx0fSxcblxuXHRcdGRhcmtlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIDwgc3IgPyBiciA6IHNyO1xuXHRcdFx0ZGcgPSBiZyA8IHNnID8gYmcgOiBzZztcblx0XHRcdGRiID0gYmIgPCBzYiA/IGJiIDogc2I7XG5cdFx0fSxcblxuXHRcdGxpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA+IHNyID8gYnIgOiBzcjtcblx0XHRcdGRnID0gYmcgPiBzZyA/IGJnIDogc2c7XG5cdFx0XHRkYiA9IGJiID4gc2IgPyBiYiA6IHNiO1xuXHRcdH0sXG5cblx0XHRkaWZmZXJlbmNlOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgLSBzcjtcblx0XHRcdGlmIChkciA8IDApXG5cdFx0XHRcdGRyID0gLWRyO1xuXHRcdFx0ZGcgPSBiZyAtIHNnO1xuXHRcdFx0aWYgKGRnIDwgMClcblx0XHRcdFx0ZGcgPSAtZGc7XG5cdFx0XHRkYiA9IGJiIC0gc2I7XG5cdFx0XHRpZiAoZGIgPCAwKVxuXHRcdFx0XHRkYiA9IC1kYjtcblx0XHR9LFxuXG5cdFx0ZXhjbHVzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgKyBzciAqICgyNTUgLSBiciAtIGJyKSAvIDI1NTtcblx0XHRcdGRnID0gYmcgKyBzZyAqICgyNTUgLSBiZyAtIGJnKSAvIDI1NTtcblx0XHRcdGRiID0gYmIgKyBzYiAqICgyNTUgLSBiYiAtIGJiKSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0aHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldFNhdChzciwgc2csIHNiLCBnZXRTYXQoYnIsIGJnLCBiYikpO1xuXHRcdFx0c2V0THVtKGRyLCBkZywgZGIsIGdldEx1bShiciwgYmcsIGJiKSk7XG5cdFx0fSxcblxuXHRcdHNhdHVyYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0U2F0KGJyLCBiZywgYmIsIGdldFNhdChzciwgc2csIHNiKSk7XG5cdFx0XHRzZXRMdW0oZHIsIGRnLCBkYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcblx0XHR9LFxuXG5cdFx0bHVtaW5vc2l0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRMdW0oYnIsIGJnLCBiYiwgZ2V0THVtKHNyLCBzZywgc2IpKTtcblx0XHR9LFxuXG5cdFx0Y29sb3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0THVtKHNyLCBzZywgc2IsIGdldEx1bShiciwgYmcsIGJiKSk7XG5cdFx0fSxcblxuXHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IG1pbihiciArIHNyLCAyNTUpO1xuXHRcdFx0ZGcgPSBtaW4oYmcgKyBzZywgMjU1KTtcblx0XHRcdGRiID0gbWluKGJiICsgc2IsIDI1NSk7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gbWF4KGJyIC0gc3IsIDApO1xuXHRcdFx0ZGcgPSBtYXgoYmcgLSBzZywgMCk7XG5cdFx0XHRkYiA9IG1heChiYiAtIHNiLCAwKTtcblx0XHR9LFxuXG5cdFx0YXZlcmFnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IChiciArIHNyKSAvIDI7XG5cdFx0XHRkZyA9IChiZyArIHNnKSAvIDI7XG5cdFx0XHRkYiA9IChiYiArIHNiKSAvIDI7XG5cdFx0fSxcblxuXHRcdG5lZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gMjU1IC0gYWJzKDI1NSAtIHNyIC0gYnIpO1xuXHRcdFx0ZGcgPSAyNTUgLSBhYnMoMjU1IC0gc2cgLSBiZyk7XG5cdFx0XHRkYiA9IDI1NSAtIGFicygyNTUgLSBzYiAtIGJiKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIG5hdGl2ZU1vZGVzID0gdGhpcy5uYXRpdmVNb2RlcyA9IEJhc2UuZWFjaChbXG5cdFx0J3NvdXJjZS1vdmVyJywgJ3NvdXJjZS1pbicsICdzb3VyY2Utb3V0JywgJ3NvdXJjZS1hdG9wJyxcblx0XHQnZGVzdGluYXRpb24tb3ZlcicsICdkZXN0aW5hdGlvbi1pbicsICdkZXN0aW5hdGlvbi1vdXQnLFxuXHRcdCdkZXN0aW5hdGlvbi1hdG9wJywgJ2xpZ2h0ZXInLCAnZGFya2VyJywgJ2NvcHknLCAneG9yJ1xuXHRdLCBmdW5jdGlvbihtb2RlKSB7XG5cdFx0dGhpc1ttb2RlXSA9IHRydWU7XG5cdH0sIHt9KTtcblxuXHR2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcblx0QmFzZS5lYWNoKG1vZGVzLCBmdW5jdGlvbihmdW5jLCBtb2RlKSB7XG5cdFx0dmFyIGRhcmtlbiA9IG1vZGUgPT09ICdkYXJrZW4nLFxuXHRcdFx0b2sgPSBmYWxzZTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdHRyeSB7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gZGFya2VuID8gJyMzMDAnIDogJyNhMDAnO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG1vZGU7XG5cdFx0XHRpZiAoY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9PT0gbW9kZSkge1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gZGFya2VuID8gJyNhMDAnIDogJyMzMDAnO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cdFx0XHRcdG9rID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzBdICE9PSBkYXJrZW4gPyAxNzAgOiA1MTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0bmF0aXZlTW9kZXNbbW9kZV0gPSBvaztcblx0fSk7XG5cdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblxuXHR0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihtb2RlLCBzcmNDb250ZXh0LCBkc3RDb250ZXh0LCBhbHBoYSwgb2Zmc2V0KSB7XG5cdFx0dmFyIHNyY0NhbnZhcyA9IHNyY0NvbnRleHQuY2FudmFzLFxuXHRcdFx0bm9ybWFsID0gbW9kZSA9PT0gJ25vcm1hbCc7XG5cdFx0aWYgKG5vcm1hbCB8fCBuYXRpdmVNb2Rlc1ttb2RlXSkge1xuXHRcdFx0ZHN0Q29udGV4dC5zYXZlKCk7XG5cdFx0XHRkc3RDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRcdGRzdENvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcblx0XHRcdGlmICghbm9ybWFsKVxuXHRcdFx0XHRkc3RDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG1vZGU7XG5cdFx0XHRkc3RDb250ZXh0LmRyYXdJbWFnZShzcmNDYW52YXMsIG9mZnNldC54LCBvZmZzZXQueSk7XG5cdFx0XHRkc3RDb250ZXh0LnJlc3RvcmUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHByb2Nlc3MgPSBtb2Rlc1ttb2RlXTtcblx0XHRcdGlmICghcHJvY2Vzcylcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIGRzdERhdGEgPSBkc3RDb250ZXh0LmdldEltYWdlRGF0YShvZmZzZXQueCwgb2Zmc2V0LnksXG5cdFx0XHRcdFx0c3JjQ2FudmFzLndpZHRoLCBzcmNDYW52YXMuaGVpZ2h0KSxcblx0XHRcdFx0ZHN0ID0gZHN0RGF0YS5kYXRhLFxuXHRcdFx0XHRzcmMgPSBzcmNDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLFxuXHRcdFx0XHRcdHNyY0NhbnZhcy53aWR0aCwgc3JjQ2FudmFzLmhlaWdodCkuZGF0YTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gZHN0Lmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuXHRcdFx0XHRzciA9IHNyY1tpXTtcblx0XHRcdFx0YnIgPSBkc3RbaV07XG5cdFx0XHRcdHNnID0gc3JjW2kgKyAxXTtcblx0XHRcdFx0YmcgPSBkc3RbaSArIDFdO1xuXHRcdFx0XHRzYiA9IHNyY1tpICsgMl07XG5cdFx0XHRcdGJiID0gZHN0W2kgKyAyXTtcblx0XHRcdFx0c2EgPSBzcmNbaSArIDNdO1xuXHRcdFx0XHRiYSA9IGRzdFtpICsgM107XG5cdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0dmFyIGExID0gc2EgKiBhbHBoYSAvIDI1NSxcblx0XHRcdFx0XHRhMiA9IDEgLSBhMTtcblx0XHRcdFx0ZHN0W2ldID0gYTEgKiBkciArIGEyICogYnI7XG5cdFx0XHRcdGRzdFtpICsgMV0gPSBhMSAqIGRnICsgYTIgKiBiZztcblx0XHRcdFx0ZHN0W2kgKyAyXSA9IGExICogZGIgKyBhMiAqIGJiO1xuXHRcdFx0XHRkc3RbaSArIDNdID0gc2EgKiBhbHBoYSArIGEyICogYmE7XG5cdFx0XHR9XG5cdFx0XHRkc3RDb250ZXh0LnB1dEltYWdlRGF0YShkc3REYXRhLCBvZmZzZXQueCwgb2Zmc2V0LnkpO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBTVkdTdHlsZXMgPSBCYXNlLmVhY2goe1xuXHRmaWxsQ29sb3I6IFsnZmlsbCcsICdjb2xvciddLFxuXHRzdHJva2VDb2xvcjogWydzdHJva2UnLCAnY29sb3InXSxcblx0c3Ryb2tlV2lkdGg6IFsnc3Ryb2tlLXdpZHRoJywgJ251bWJlciddLFxuXHRzdHJva2VDYXA6IFsnc3Ryb2tlLWxpbmVjYXAnLCAnc3RyaW5nJ10sXG5cdHN0cm9rZUpvaW46IFsnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cmluZyddLFxuXHRzdHJva2VTY2FsaW5nOiBbJ3ZlY3Rvci1lZmZlY3QnLCAnbG9va3VwJywge1xuXHRcdHRydWU6ICdub25lJyxcblx0XHRmYWxzZTogJ25vbi1zY2FsaW5nLXN0cm9rZSdcblx0fSwgZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRyZXR1cm4gIXZhbHVlXG5cdFx0XHRcdCYmIChpdGVtIGluc3RhbmNlb2YgUGF0aEl0ZW1cblx0XHRcdFx0XHR8fCBpdGVtIGluc3RhbmNlb2YgU2hhcGVcblx0XHRcdFx0XHR8fCBpdGVtIGluc3RhbmNlb2YgVGV4dEl0ZW0pO1xuXHR9XSxcblx0bWl0ZXJMaW1pdDogWydzdHJva2UtbWl0ZXJsaW1pdCcsICdudW1iZXInXSxcblx0ZGFzaEFycmF5OiBbJ3N0cm9rZS1kYXNoYXJyYXknLCAnYXJyYXknXSxcblx0ZGFzaE9mZnNldDogWydzdHJva2UtZGFzaG9mZnNldCcsICdudW1iZXInXSxcblx0Zm9udEZhbWlseTogWydmb250LWZhbWlseScsICdzdHJpbmcnXSxcblx0Zm9udFdlaWdodDogWydmb250LXdlaWdodCcsICdzdHJpbmcnXSxcblx0Zm9udFNpemU6IFsnZm9udC1zaXplJywgJ251bWJlciddLFxuXHRqdXN0aWZpY2F0aW9uOiBbJ3RleHQtYW5jaG9yJywgJ2xvb2t1cCcsIHtcblx0XHRsZWZ0OiAnc3RhcnQnLFxuXHRcdGNlbnRlcjogJ21pZGRsZScsXG5cdFx0cmlnaHQ6ICdlbmQnXG5cdH1dLFxuXHRvcGFjaXR5OiBbJ29wYWNpdHknLCAnbnVtYmVyJ10sXG5cdGJsZW5kTW9kZTogWydtaXgtYmxlbmQtbW9kZScsICdzdHJpbmcnXVxufSwgZnVuY3Rpb24oZW50cnksIGtleSkge1xuXHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdGxvb2t1cCA9IGVudHJ5WzJdO1xuXHR0aGlzW2tleV0gPSB7XG5cdFx0dHlwZTogZW50cnlbMV0sXG5cdFx0cHJvcGVydHk6IGtleSxcblx0XHRhdHRyaWJ1dGU6IGVudHJ5WzBdLFxuXHRcdHRvU1ZHOiBsb29rdXAsXG5cdFx0ZnJvbVNWRzogbG9va3VwICYmIEJhc2UuZWFjaChsb29rdXAsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHR0aGlzW3ZhbHVlXSA9IG5hbWU7XG5cdFx0fSwge30pLFxuXHRcdGV4cG9ydEZpbHRlcjogZW50cnlbM10sXG5cdFx0Z2V0OiAnZ2V0JyArIHBhcnQsXG5cdFx0c2V0OiAnc2V0JyArIHBhcnRcblx0fTtcbn0sIHt9KTtcblxudmFyIFNWR05hbWVzcGFjZXMgPSB7XG5cdGhyZWY6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0eGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zJ1xufTtcblxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgZm9ybWF0dGVyO1xuXG5cdGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMobm9kZSwgYXR0cnMpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdHZhciB2YWwgPSBhdHRyc1trZXldLFxuXHRcdFx0XHRuYW1lc3BhY2UgPSBTVkdOYW1lc3BhY2VzW2tleV07XG5cdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXG5cdFx0XHRcdHZhbCA9IGZvcm1hdHRlci5udW1iZXIodmFsKTtcblx0XHRcdGlmIChuYW1lc3BhY2UpIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGtleSwgdmFsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cnMpIHtcblx0XHRyZXR1cm4gc2V0QXR0cmlidXRlcyhcblx0XHRcdGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCB0YWcpLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUcmFuc2Zvcm0obWF0cml4LCBjb29yZGluYXRlcywgY2VudGVyKSB7XG5cdFx0dmFyIGF0dHJzID0gbmV3IEJhc2UoKSxcblx0XHRcdHRyYW5zID0gbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cdFx0aWYgKGNvb3JkaW5hdGVzKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2hpZnRsZXNzKCk7XG5cdFx0XHR2YXIgcG9pbnQgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0odHJhbnMpO1xuXHRcdFx0YXR0cnNbY2VudGVyID8gJ2N4JyA6ICd4J10gPSBwb2ludC54O1xuXHRcdFx0YXR0cnNbY2VudGVyID8gJ2N5JyA6ICd5J10gPSBwb2ludC55O1xuXHRcdFx0dHJhbnMgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAoIW1hdHJpeC5pc0lkZW50aXR5KCkpIHtcblx0XHRcdHZhciBkZWNvbXBvc2VkID0gbWF0cml4LmRlY29tcG9zZSgpO1xuXHRcdFx0aWYgKGRlY29tcG9zZWQgJiYgIWRlY29tcG9zZWQuc2hlYXJpbmcpIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gW10sXG5cdFx0XHRcdFx0YW5nbGUgPSBkZWNvbXBvc2VkLnJvdGF0aW9uLFxuXHRcdFx0XHRcdHNjYWxlID0gZGVjb21wb3NlZC5zY2FsaW5nO1xuXHRcdFx0XHRpZiAodHJhbnMgJiYgIXRyYW5zLmlzWmVybygpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3RyYW5zbGF0ZSgnICsgZm9ybWF0dGVyLnBvaW50KHRyYW5zKSArICcpJyk7XG5cdFx0XHRcdGlmICghTnVtZXJpY2FsLmlzWmVybyhzY2FsZS54IC0gMSlcblx0XHRcdFx0XHRcdHx8ICFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnkgLSAxKSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdzY2FsZSgnICsgZm9ybWF0dGVyLnBvaW50KHNjYWxlKSArJyknKTtcblx0XHRcdFx0aWYgKGFuZ2xlKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3JvdGF0ZSgnICsgZm9ybWF0dGVyLm51bWJlcihhbmdsZSkgKyAnKScpO1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSBwYXJ0cy5qb2luKCcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyBtYXRyaXguZ2V0VmFsdWVzKCkuam9pbignLCcpICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYXR0cnM7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRHcm91cChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCksXG5cdFx0XHRjaGlsZHJlbiA9IGl0ZW0uX2NoaWxkcmVuO1xuXHRcdHZhciBub2RlID0gY3JlYXRlRWxlbWVudCgnZycsIGF0dHJzKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gZXhwb3J0U1ZHKGNoaWxkLCBvcHRpb25zKTtcblx0XHRcdGlmIChjaGlsZE5vZGUpIHtcblx0XHRcdFx0aWYgKGNoaWxkLmlzQ2xpcE1hc2soKSkge1xuXHRcdFx0XHRcdHZhciBjbGlwID0gY3JlYXRlRWxlbWVudCgnY2xpcFBhdGgnKTtcblx0XHRcdFx0XHRjbGlwLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG5cdFx0XHRcdFx0c2V0RGVmaW5pdGlvbihjaGlsZCwgY2xpcCwgJ2NsaXAnKTtcblx0XHRcdFx0XHRzZXRBdHRyaWJ1dGVzKG5vZGUsIHtcblx0XHRcdFx0XHRcdCdjbGlwLXBhdGgnOiAndXJsKCMnICsgY2xpcC5pZCArICcpJ1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFJhc3RlcihpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSksXG5cdFx0XHRzaXplID0gaXRlbS5nZXRTaXplKCksXG5cdFx0XHRpbWFnZSA9IGl0ZW0uZ2V0SW1hZ2UoKTtcblx0XHRhdHRycy54IC09IHNpemUud2lkdGggLyAyO1xuXHRcdGF0dHJzLnkgLT0gc2l6ZS5oZWlnaHQgLyAyO1xuXHRcdGF0dHJzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRhdHRycy5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRhdHRycy5ocmVmID0gb3B0aW9ucy5lbWJlZEltYWdlcyA9PT0gZmFsc2UgJiYgaW1hZ2UgJiYgaW1hZ2Uuc3JjXG5cdFx0XHRcdHx8IGl0ZW0udG9EYXRhVVJMKCk7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2ltYWdlJywgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0UGF0aChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIG1hdGNoU2hhcGVzID0gb3B0aW9ucy5tYXRjaFNoYXBlcztcblx0XHRpZiAobWF0Y2hTaGFwZXMpIHtcblx0XHRcdHZhciBzaGFwZSA9IGl0ZW0udG9TaGFwZShmYWxzZSk7XG5cdFx0XHRpZiAoc2hhcGUpXG5cdFx0XHRcdHJldHVybiBleHBvcnRTaGFwZShzaGFwZSwgb3B0aW9ucyk7XG5cdFx0fVxuXHRcdHZhciBzZWdtZW50cyA9IGl0ZW0uX3NlZ21lbnRzLFxuXHRcdFx0dHlwZSxcblx0XHRcdGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCk7XG5cdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGlmIChtYXRjaFNoYXBlcyAmJiAhaXRlbS5oYXNIYW5kbGVzKCkpIHtcblx0XHRcdGlmIChzZWdtZW50cy5sZW5ndGggPj0gMykge1xuXHRcdFx0XHR0eXBlID0gaXRlbS5fY2xvc2VkID8gJ3BvbHlnb24nIDogJ3BvbHlsaW5lJztcblx0XHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRcdGZvcih2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cGFydHMucHVzaChmb3JtYXR0ZXIucG9pbnQoc2VnbWVudHNbaV0uX3BvaW50KSk7XG5cdFx0XHRcdGF0dHJzLnBvaW50cyA9IHBhcnRzLmpvaW4oJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSAnbGluZSc7XG5cdFx0XHRcdHZhciBmaXJzdCA9IHNlZ21lbnRzWzBdLl9wb2ludCxcblx0XHRcdFx0XHRsYXN0ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uX3BvaW50O1xuXHRcdFx0XHRhdHRycy5zZXQoe1xuXHRcdFx0XHRcdHgxOiBmaXJzdC54LFxuXHRcdFx0XHRcdHkxOiBmaXJzdC55LFxuXHRcdFx0XHRcdHgyOiBsYXN0LngsXG5cdFx0XHRcdFx0eTI6IGxhc3QueVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dHlwZSA9ICdwYXRoJztcblx0XHRcdGF0dHJzLmQgPSBpdGVtLmdldFBhdGhEYXRhKG51bGwsIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQodHlwZSwgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U2hhcGUoaXRlbSkge1xuXHRcdHZhciB0eXBlID0gaXRlbS5fdHlwZSxcblx0XHRcdHJhZGl1cyA9IGl0ZW0uX3JhZGl1cyxcblx0XHRcdGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSwgdHlwZSAhPT0gJ3JlY3RhbmdsZScpO1xuXHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0dHlwZSA9ICdyZWN0Jztcblx0XHRcdHZhciBzaXplID0gaXRlbS5fc2l6ZSxcblx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdGF0dHJzLnggLT0gd2lkdGggLyAyO1xuXHRcdFx0YXR0cnMueSAtPSBoZWlnaHQgLyAyO1xuXHRcdFx0YXR0cnMud2lkdGggPSB3aWR0aDtcblx0XHRcdGF0dHJzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdGlmIChyYWRpdXMuaXNaZXJvKCkpXG5cdFx0XHRcdHJhZGl1cyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmIChyYWRpdXMpIHtcblx0XHRcdGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0XHRhdHRycy5yID0gcmFkaXVzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMucnggPSByYWRpdXMud2lkdGg7XG5cdFx0XHRcdGF0dHJzLnJ5ID0gcmFkaXVzLmhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQodHlwZSwgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0Q29tcG91bmRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KTtcblx0XHR2YXIgZGF0YSA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdGlmIChkYXRhKVxuXHRcdFx0YXR0cnMuZCA9IGRhdGE7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRQbGFjZWRTeW1ib2woaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpLFxuXHRcdFx0c3ltYm9sID0gaXRlbS5nZXRTeW1ib2woKSxcblx0XHRcdHN5bWJvbE5vZGUgPSBnZXREZWZpbml0aW9uKHN5bWJvbCwgJ3N5bWJvbCcpLFxuXHRcdFx0ZGVmaW5pdGlvbiA9IHN5bWJvbC5nZXREZWZpbml0aW9uKCksXG5cdFx0XHRib3VuZHMgPSBkZWZpbml0aW9uLmdldEJvdW5kcygpO1xuXHRcdGlmICghc3ltYm9sTm9kZSkge1xuXHRcdFx0c3ltYm9sTm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ3N5bWJvbCcsIHtcblx0XHRcdFx0dmlld0JveDogZm9ybWF0dGVyLnJlY3RhbmdsZShib3VuZHMpXG5cdFx0XHR9KTtcblx0XHRcdHN5bWJvbE5vZGUuYXBwZW5kQ2hpbGQoZXhwb3J0U1ZHKGRlZmluaXRpb24sIG9wdGlvbnMpKTtcblx0XHRcdHNldERlZmluaXRpb24oc3ltYm9sLCBzeW1ib2xOb2RlLCAnc3ltYm9sJyk7XG5cdFx0fVxuXHRcdGF0dHJzLmhyZWYgPSAnIycgKyBzeW1ib2xOb2RlLmlkO1xuXHRcdGF0dHJzLnggKz0gYm91bmRzLng7XG5cdFx0YXR0cnMueSArPSBib3VuZHMueTtcblx0XHRhdHRycy53aWR0aCA9IGZvcm1hdHRlci5udW1iZXIoYm91bmRzLndpZHRoKTtcblx0XHRhdHRycy5oZWlnaHQgPSBmb3JtYXR0ZXIubnVtYmVyKGJvdW5kcy5oZWlnaHQpO1xuXHRcdGF0dHJzLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KCd1c2UnLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRHcmFkaWVudChjb2xvcikge1xuXHRcdHZhciBncmFkaWVudE5vZGUgPSBnZXREZWZpbml0aW9uKGNvbG9yLCAnY29sb3InKTtcblx0XHRpZiAoIWdyYWRpZW50Tm9kZSkge1xuXHRcdFx0dmFyIGdyYWRpZW50ID0gY29sb3IuZ2V0R3JhZGllbnQoKSxcblx0XHRcdFx0cmFkaWFsID0gZ3JhZGllbnQuX3JhZGlhbCxcblx0XHRcdFx0b3JpZ2luID0gY29sb3IuZ2V0T3JpZ2luKCkudHJhbnNmb3JtKCksXG5cdFx0XHRcdGRlc3RpbmF0aW9uID0gY29sb3IuZ2V0RGVzdGluYXRpb24oKS50cmFuc2Zvcm0oKSxcblx0XHRcdFx0YXR0cnM7XG5cdFx0XHRpZiAocmFkaWFsKSB7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdGN4OiBvcmlnaW4ueCxcblx0XHRcdFx0XHRjeTogb3JpZ2luLnksXG5cdFx0XHRcdFx0cjogb3JpZ2luLmdldERpc3RhbmNlKGRlc3RpbmF0aW9uKVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR2YXIgaGlnaGxpZ2h0ID0gY29sb3IuZ2V0SGlnaGxpZ2h0KCk7XG5cdFx0XHRcdGlmIChoaWdobGlnaHQpIHtcblx0XHRcdFx0XHRoaWdobGlnaHQgPSBoaWdobGlnaHQudHJhbnNmb3JtKCk7XG5cdFx0XHRcdFx0YXR0cnMuZnggPSBoaWdobGlnaHQueDtcblx0XHRcdFx0XHRhdHRycy5meSA9IGhpZ2hsaWdodC55O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycyA9IHtcblx0XHRcdFx0XHR4MTogb3JpZ2luLngsXG5cdFx0XHRcdFx0eTE6IG9yaWdpbi55LFxuXHRcdFx0XHRcdHgyOiBkZXN0aW5hdGlvbi54LFxuXHRcdFx0XHRcdHkyOiBkZXN0aW5hdGlvbi55XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRhdHRycy5ncmFkaWVudFVuaXRzID0gJ3VzZXJTcGFjZU9uVXNlJztcblx0XHRcdGdyYWRpZW50Tm9kZSA9IGNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdFx0KHJhZGlhbCA/ICdyYWRpYWwnIDogJ2xpbmVhcicpICsgJ0dyYWRpZW50JywgYXR0cnMpO1xuXHRcdFx0dmFyIHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHN0b3AgPSBzdG9wc1tpXSxcblx0XHRcdFx0XHRzdG9wQ29sb3IgPSBzdG9wLl9jb2xvcixcblx0XHRcdFx0XHRhbHBoYSA9IHN0b3BDb2xvci5nZXRBbHBoYSgpO1xuXHRcdFx0XHRhdHRycyA9IHtcblx0XHRcdFx0XHRvZmZzZXQ6IHN0b3AuX3JhbXBQb2ludCxcblx0XHRcdFx0XHQnc3RvcC1jb2xvcic6IHN0b3BDb2xvci50b0NTUyh0cnVlKVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRcdGF0dHJzWydzdG9wLW9wYWNpdHknXSA9IGFscGhhO1xuXHRcdFx0XHRncmFkaWVudE5vZGUuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnc3RvcCcsIGF0dHJzKSk7XG5cdFx0XHR9XG5cdFx0XHRzZXREZWZpbml0aW9uKGNvbG9yLCBncmFkaWVudE5vZGUsICdjb2xvcicpO1xuXHRcdH1cblx0XHRyZXR1cm4gJ3VybCgjJyArIGdyYWRpZW50Tm9kZS5pZCArICcpJztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFRleHQoaXRlbSkge1xuXHRcdHZhciBub2RlID0gY3JlYXRlRWxlbWVudCgndGV4dCcsIGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpKTtcblx0XHRub2RlLnRleHRDb250ZW50ID0gaXRlbS5fY29udGVudDtcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdHZhciBleHBvcnRlcnMgPSB7XG5cdFx0R3JvdXA6IGV4cG9ydEdyb3VwLFxuXHRcdExheWVyOiBleHBvcnRHcm91cCxcblx0XHRSYXN0ZXI6IGV4cG9ydFJhc3Rlcixcblx0XHRQYXRoOiBleHBvcnRQYXRoLFxuXHRcdFNoYXBlOiBleHBvcnRTaGFwZSxcblx0XHRDb21wb3VuZFBhdGg6IGV4cG9ydENvbXBvdW5kUGF0aCxcblx0XHRQbGFjZWRTeW1ib2w6IGV4cG9ydFBsYWNlZFN5bWJvbCxcblx0XHRQb2ludFRleHQ6IGV4cG9ydFRleHRcblx0fTtcblxuXHRmdW5jdGlvbiBhcHBseVN0eWxlKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuXHRcdHZhciBhdHRycyA9IHt9LFxuXHRcdFx0cGFyZW50ID0gIWlzUm9vdCAmJiBpdGVtLmdldFBhcmVudCgpO1xuXG5cdFx0aWYgKGl0ZW0uX25hbWUgIT0gbnVsbClcblx0XHRcdGF0dHJzLmlkID0gaXRlbS5fbmFtZTtcblxuXHRcdEJhc2UuZWFjaChTVkdTdHlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG5cdFx0XHR2YXIgZ2V0ID0gZW50cnkuZ2V0LFxuXHRcdFx0XHR0eXBlID0gZW50cnkudHlwZSxcblx0XHRcdFx0dmFsdWUgPSBpdGVtW2dldF0oKTtcblx0XHRcdGlmIChlbnRyeS5leHBvcnRGaWx0ZXJcblx0XHRcdFx0XHQ/IGVudHJ5LmV4cG9ydEZpbHRlcihpdGVtLCB2YWx1ZSlcblx0XHRcdFx0XHQ6ICFwYXJlbnQgfHwgIUJhc2UuZXF1YWxzKHBhcmVudFtnZXRdKCksIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NvbG9yJyAmJiB2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dmFyIGFscGhhID0gdmFsdWUuZ2V0QWxwaGEoKTtcblx0XHRcdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRcdFx0YXR0cnNbZW50cnkuYXR0cmlidXRlICsgJy1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhdHRyc1tlbnRyeS5hdHRyaWJ1dGVdID0gdmFsdWUgPT0gbnVsbFxuXHRcdFx0XHRcdD8gJ25vbmUnXG5cdFx0XHRcdFx0OiB0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0PyBmb3JtYXR0ZXIubnVtYmVyKHZhbHVlKVxuXHRcdFx0XHRcdFx0OiB0eXBlID09PSAnY29sb3InXG5cdFx0XHRcdFx0XHRcdD8gdmFsdWUuZ3JhZGllbnRcblx0XHRcdFx0XHRcdFx0XHQ/IGV4cG9ydEdyYWRpZW50KHZhbHVlLCBpdGVtKVxuXHRcdFx0XHRcdFx0XHRcdDogdmFsdWUudG9DU1ModHJ1ZSlcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnYXJyYXknXG5cdFx0XHRcdFx0XHRcdFx0PyB2YWx1ZS5qb2luKCcsJylcblx0XHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdsb29rdXAnXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGVudHJ5LnRvU1ZHW3ZhbHVlXVxuXHRcdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChhdHRycy5vcGFjaXR5ID09PSAxKVxuXHRcdFx0ZGVsZXRlIGF0dHJzLm9wYWNpdHk7XG5cblx0XHRpZiAoIWl0ZW0uX3Zpc2libGUpXG5cdFx0XHRhdHRycy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cblx0XHRyZXR1cm4gc2V0QXR0cmlidXRlcyhub2RlLCBhdHRycyk7XG5cdH1cblxuXHR2YXIgZGVmaW5pdGlvbnM7XG5cdGZ1bmN0aW9uIGdldERlZmluaXRpb24oaXRlbSwgdHlwZSkge1xuXHRcdGlmICghZGVmaW5pdGlvbnMpXG5cdFx0XHRkZWZpbml0aW9ucyA9IHsgaWRzOiB7fSwgc3Znczoge30gfTtcblx0XHRyZXR1cm4gaXRlbSAmJiBkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyBpdGVtLl9pZF07XG5cdH1cblxuXHRmdW5jdGlvbiBzZXREZWZpbml0aW9uKGl0ZW0sIG5vZGUsIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0Z2V0RGVmaW5pdGlvbigpO1xuXHRcdHZhciBpZCA9IGRlZmluaXRpb25zLmlkc1t0eXBlXSA9IChkZWZpbml0aW9ucy5pZHNbdHlwZV0gfHwgMCkgKyAxO1xuXHRcdG5vZGUuaWQgPSB0eXBlICsgJy0nICsgaWQ7XG5cdFx0ZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nICsgaXRlbS5faWRdID0gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpIHtcblx0XHR2YXIgc3ZnID0gbm9kZSxcblx0XHRcdGRlZnMgPSBudWxsO1xuXHRcdGlmIChkZWZpbml0aW9ucykge1xuXHRcdFx0c3ZnID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJyAmJiBub2RlO1xuXHRcdFx0Zm9yICh2YXIgaSBpbiBkZWZpbml0aW9ucy5zdmdzKSB7XG5cdFx0XHRcdGlmICghZGVmcykge1xuXHRcdFx0XHRcdGlmICghc3ZnKSB7XG5cdFx0XHRcdFx0XHRzdmcgPSBjcmVhdGVFbGVtZW50KCdzdmcnKTtcblx0XHRcdFx0XHRcdHN2Zy5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVmcyA9IHN2Zy5pbnNlcnRCZWZvcmUoY3JlYXRlRWxlbWVudCgnZGVmcycpLFxuXHRcdFx0XHRcdFx0XHRzdmcuZmlyc3RDaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVmcy5hcHBlbmRDaGlsZChkZWZpbml0aW9ucy5zdmdzW2ldKTtcblx0XHRcdH1cblx0XHRcdGRlZmluaXRpb25zID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXNTdHJpbmdcblx0XHRcdFx0PyBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zylcblx0XHRcdFx0OiBzdmc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTVkcoaXRlbSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0dmFyIGV4cG9ydGVyID0gZXhwb3J0ZXJzW2l0ZW0uX2NsYXNzXSxcblx0XHRcdG5vZGUgPSBleHBvcnRlciAmJiBleHBvcnRlcihpdGVtLCBvcHRpb25zKTtcblx0XHRpZiAobm9kZSkge1xuXHRcdFx0dmFyIG9uRXhwb3J0ID0gb3B0aW9ucy5vbkV4cG9ydDtcblx0XHRcdGlmIChvbkV4cG9ydClcblx0XHRcdFx0bm9kZSA9IG9uRXhwb3J0KGl0ZW0sIG5vZGUsIG9wdGlvbnMpIHx8IG5vZGU7XG5cdFx0XHR2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uX2RhdGEpO1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YSAhPT0gJ3t9JyAmJiBkYXRhICE9PSAnbnVsbCcpXG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWRhdGEnLCBkYXRhKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGUgJiYgYXBwbHlTdHlsZShpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGV4cG9ydFNWRzogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gZXhwb3J0RGVmaW5pdGlvbnMoZXhwb3J0U1ZHKHRoaXMsIG9wdGlvbnMsIHRydWUpLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRleHBvcnRTVkc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0dmFyIGxheWVycyA9IHRoaXMubGF5ZXJzLFxuXHRcdFx0XHR2aWV3ID0gdGhpcy5nZXRWaWV3KCksXG5cdFx0XHRcdHNpemUgPSB2aWV3LmdldFZpZXdTaXplKCksXG5cdFx0XHRcdG5vZGUgPSBjcmVhdGVFbGVtZW50KCdzdmcnLCB7XG5cdFx0XHRcdFx0eDogMCxcblx0XHRcdFx0XHR5OiAwLFxuXHRcdFx0XHRcdHdpZHRoOiBzaXplLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogc2l6ZS5oZWlnaHQsXG5cdFx0XHRcdFx0dmVyc2lvbjogJzEuMScsXG5cdFx0XHRcdFx0eG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0XHRcdFx0J3htbG5zOnhsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRwYXJlbnQgPSBub2RlLFxuXHRcdFx0XHRtYXRyaXggPSB2aWV3Ll9tYXRyaXg7XG5cdFx0XHRpZiAoIW1hdHJpeC5pc0lkZW50aXR5KCkpXG5cdFx0XHRcdHBhcmVudCA9IG5vZGUuYXBwZW5kQ2hpbGQoXG5cdFx0XHRcdFx0XHRjcmVhdGVFbGVtZW50KCdnJywgZ2V0VHJhbnNmb3JtKG1hdHJpeCkpKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKGV4cG9ydFNWRyhsYXllcnNbaV0sIG9wdGlvbnMsIHRydWUpKTtcblx0XHRcdHJldHVybiBleHBvcnREZWZpbml0aW9ucyhub2RlLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xufTtcblxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldFZhbHVlKG5vZGUsIG5hbWUsIGlzU3RyaW5nLCBhbGxvd051bGwpIHtcblx0XHR2YXIgbmFtZXNwYWNlID0gU1ZHTmFtZXNwYWNlc1tuYW1lXSxcblx0XHRcdHZhbHVlID0gbmFtZXNwYWNlXG5cdFx0XHRcdD8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpXG5cdFx0XHRcdDogbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdFx0aWYgKHZhbHVlID09PSAnbnVsbCcpXG5cdFx0XHR2YWx1ZSA9IG51bGw7XG5cdFx0cmV0dXJuIHZhbHVlID09IG51bGxcblx0XHRcdFx0PyBhbGxvd051bGxcblx0XHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0XHQ6IGlzU3RyaW5nXG5cdFx0XHRcdFx0XHQ/ICcnXG5cdFx0XHRcdFx0XHQ6IDBcblx0XHRcdFx0OiBpc1N0cmluZ1xuXHRcdFx0XHRcdD8gdmFsdWVcblx0XHRcdFx0XHQ6IHBhcnNlRmxvYXQodmFsdWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UG9pbnQobm9kZSwgeCwgeSwgYWxsb3dOdWxsKSB7XG5cdFx0eCA9IGdldFZhbHVlKG5vZGUsIHgsIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdHkgPSBnZXRWYWx1ZShub2RlLCB5LCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHRyZXR1cm4gYWxsb3dOdWxsICYmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSA/IG51bGxcblx0XHRcdFx0OiBuZXcgUG9pbnQoeCwgeSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTaXplKG5vZGUsIHcsIGgsIGFsbG93TnVsbCkge1xuXHRcdHcgPSBnZXRWYWx1ZShub2RlLCB3LCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHRoID0gZ2V0VmFsdWUobm9kZSwgaCwgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0cmV0dXJuIGFsbG93TnVsbCAmJiAodyA9PSBudWxsIHx8IGggPT0gbnVsbCkgPyBudWxsXG5cdFx0XHRcdDogbmV3IFNpemUodywgaCk7XG5cdH1cblxuXHRmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUsIHR5cGUsIGxvb2t1cCkge1xuXHRcdHJldHVybiB2YWx1ZSA9PT0gJ25vbmUnXG5cdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHQ6IHR5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0PyBwYXJzZUZsb2F0KHZhbHVlKVxuXHRcdFx0XHRcdDogdHlwZSA9PT0gJ2FycmF5J1xuXHRcdFx0XHRcdFx0PyB2YWx1ZSA/IHZhbHVlLnNwbGl0KC9bXFxzLF0rL2cpLm1hcChwYXJzZUZsb2F0KSA6IFtdXG5cdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdjb2xvcidcblx0XHRcdFx0XHRcdFx0PyBnZXREZWZpbml0aW9uKHZhbHVlKSB8fCB2YWx1ZVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdsb29rdXAnXG5cdFx0XHRcdFx0XHRcdFx0PyBsb29rdXBbdmFsdWVdXG5cdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdGlzQ2xpcCA9IHR5cGUgPT09ICdjbGlwcGF0aCcsXG5cdFx0XHRpdGVtID0gbmV3IEdyb3VwKCksXG5cdFx0XHRwcm9qZWN0ID0gaXRlbS5fcHJvamVjdCxcblx0XHRcdGN1cnJlbnRTdHlsZSA9IHByb2plY3QuX2N1cnJlbnRTdHlsZSxcblx0XHRcdGNoaWxkcmVuID0gW107XG5cdFx0aWYgKCFpc0NsaXApIHtcblx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0XHRcdHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGl0ZW0uX3N0eWxlLmNsb25lKCk7XG5cdFx0fVxuXHRcdGlmIChpc1Jvb3QpIHtcblx0XHRcdHZhciBkZWZzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdkZWZzJyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGRlZnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGltcG9ydFNWRyhkZWZzW2ldLCBvcHRpb25zLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gbm9kZXNbaV0sXG5cdFx0XHRcdGNoaWxkO1xuXHRcdFx0aWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMVxuXHRcdFx0XHRcdCYmIGNoaWxkTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnZGVmcydcblx0XHRcdFx0XHQmJiAoY2hpbGQgPSBpbXBvcnRTVkcoY2hpbGROb2RlLCBvcHRpb25zLCBmYWxzZSkpXG5cdFx0XHRcdFx0JiYgIShjaGlsZCBpbnN0YW5jZW9mIFN5bWJvbCkpXG5cdFx0XHRcdGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXHRcdH1cblx0XHRpdGVtLmFkZENoaWxkcmVuKGNoaWxkcmVuKTtcblx0XHRpZiAoaXNDbGlwKVxuXHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLnJlZHVjZSgpLCBub2RlLCBpc1Jvb3QpO1xuXHRcdHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGN1cnJlbnRTdHlsZTtcblx0XHRpZiAoaXNDbGlwIHx8IHR5cGUgPT09ICdkZWZzJykge1xuXHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdGl0ZW0gPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFBvbHkobm9kZSwgdHlwZSkge1xuXHRcdHZhciBjb29yZHMgPSBub2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJykubWF0Y2goXG5cdFx0XHRcdFx0L1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpLFxuXHRcdFx0cG9pbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb29yZHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKVxuXHRcdFx0cG9pbnRzLnB1c2gobmV3IFBvaW50KFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoY29vcmRzW2ldKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KGNvb3Jkc1tpICsgMV0pKSk7XG5cdFx0dmFyIHBhdGggPSBuZXcgUGF0aChwb2ludHMpO1xuXHRcdGlmICh0eXBlID09PSAncG9seWdvbicpXG5cdFx0XHRwYXRoLmNsb3NlUGF0aCgpO1xuXHRcdHJldHVybiBwYXRoO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0UGF0aChub2RlKSB7XG5cdFx0dmFyIGRhdGEgPSBub2RlLmdldEF0dHJpYnV0ZSgnZCcpLFxuXHRcdFx0cGFyYW0gPSB7IHBhdGhEYXRhOiBkYXRhIH07XG5cdFx0cmV0dXJuIChkYXRhLm1hdGNoKC9tL2dpKSB8fCBbXSkubGVuZ3RoID4gMSB8fCAvelxcUysvaS50ZXN0KGRhdGEpXG5cdFx0XHRcdD8gbmV3IENvbXBvdW5kUGF0aChwYXJhbSlcblx0XHRcdFx0OiBuZXcgUGF0aChwYXJhbSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRHcmFkaWVudChub2RlLCB0eXBlKSB7XG5cdFx0dmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcblx0XHRcdGlzUmFkaWFsID0gdHlwZSA9PT0gJ3JhZGlhbGdyYWRpZW50Jyxcblx0XHRcdGdyYWRpZW50O1xuXHRcdGlmIChpZCkge1xuXHRcdFx0Z3JhZGllbnQgPSBkZWZpbml0aW9uc1tpZF0uZ2V0R3JhZGllbnQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0XHRzdG9wcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSlcblx0XHRcdFx0XHRzdG9wcy5wdXNoKGFwcGx5QXR0cmlidXRlcyhuZXcgR3JhZGllbnRTdG9wKCksIGNoaWxkKSk7XG5cdFx0XHR9XG5cdFx0XHRncmFkaWVudCA9IG5ldyBHcmFkaWVudChzdG9wcywgaXNSYWRpYWwpO1xuXHRcdH1cblx0XHR2YXIgb3JpZ2luLCBkZXN0aW5hdGlvbiwgaGlnaGxpZ2h0O1xuXHRcdGlmIChpc1JhZGlhbCkge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5Jyk7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IG9yaWdpbi5hZGQoZ2V0VmFsdWUobm9kZSwgJ3InKSwgMCk7XG5cdFx0XHRoaWdobGlnaHQgPSBnZXRQb2ludChub2RlLCAnZngnLCAnZnknLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJyk7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IGdldFBvaW50KG5vZGUsICd4MicsICd5MicpO1xuXHRcdH1cblx0XHRhcHBseUF0dHJpYnV0ZXMoXG5cdFx0XHRuZXcgQ29sb3IoZ3JhZGllbnQsIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodCksIG5vZGUpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGltcG9ydGVycyA9IHtcblx0XHQnI2RvY3VtZW50JzogZnVuY3Rpb24gKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdHZhciBuZXh0ID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSBpbXBvcnRTVkcoY2hpbGQsIG9wdGlvbnMsIGlzUm9vdCk7XG5cdFx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRcdG5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnOiBpbXBvcnRHcm91cCxcblx0XHRzdmc6IGltcG9ydEdyb3VwLFxuXHRcdGNsaXBwYXRoOiBpbXBvcnRHcm91cCxcblx0XHRwb2x5Z29uOiBpbXBvcnRQb2x5LFxuXHRcdHBvbHlsaW5lOiBpbXBvcnRQb2x5LFxuXHRcdHBhdGg6IGltcG9ydFBhdGgsXG5cdFx0bGluZWFyZ3JhZGllbnQ6IGltcG9ydEdyYWRpZW50LFxuXHRcdHJhZGlhbGdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcblxuXHRcdGltYWdlOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIHJhc3RlciA9IG5ldyBSYXN0ZXIoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSk7XG5cdFx0XHRyYXN0ZXIub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNpemUgPSBnZXRTaXplKG5vZGUsICd3aWR0aCcsICdoZWlnaHQnKTtcblx0XHRcdFx0dGhpcy5zZXRTaXplKHNpemUpO1xuXHRcdFx0XHR2YXIgY2VudGVyID0gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChcblx0XHRcdFx0XHRcdGdldFBvaW50KG5vZGUsICd4JywgJ3knKS5hZGQoc2l6ZS5kaXZpZGUoMikpKTtcblx0XHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJhc3Rlcjtcblx0XHR9LFxuXG5cdFx0c3ltYm9sOiBmdW5jdGlvbihub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRcdHJldHVybiBuZXcgU3ltYm9sKGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCksIHRydWUpO1xuXHRcdH0sXG5cblx0XHRkZWZzOiBpbXBvcnRHcm91cCxcblxuXHRcdHVzZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcblx0XHRcdFx0ZGVmaW5pdGlvbiA9IGRlZmluaXRpb25zW2lkXSxcblx0XHRcdFx0cG9pbnQgPSBnZXRQb2ludChub2RlLCAneCcsICd5Jyk7XG5cdFx0XHRyZXR1cm4gZGVmaW5pdGlvblxuXHRcdFx0XHRcdD8gZGVmaW5pdGlvbiBpbnN0YW5jZW9mIFN5bWJvbFxuXHRcdFx0XHRcdFx0PyBkZWZpbml0aW9uLnBsYWNlKHBvaW50KVxuXHRcdFx0XHRcdFx0OiBkZWZpbml0aW9uLmNsb25lKCkudHJhbnNsYXRlKHBvaW50KVxuXHRcdFx0XHRcdDogbnVsbDtcblx0XHR9LFxuXG5cdFx0Y2lyY2xlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLkNpcmNsZShnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKSxcblx0XHRcdFx0XHRnZXRWYWx1ZShub2RlLCAncicpKTtcblx0XHR9LFxuXG5cdFx0ZWxsaXBzZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5FbGxpcHNlKHtcblx0XHRcdFx0Y2VudGVyOiBnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKSxcblx0XHRcdFx0cmFkaXVzOiBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0cmVjdDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIHBvaW50ID0gZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpLFxuXHRcdFx0XHRzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0JyksXG5cdFx0XHRcdHJhZGl1cyA9IGdldFNpemUobm9kZSwgJ3J4JywgJ3J5Jyk7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLlJlY3RhbmdsZShuZXcgUmVjdGFuZ2xlKHBvaW50LCBzaXplKSwgcmFkaXVzKTtcblx0XHR9LFxuXG5cdFx0bGluZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBQYXRoLkxpbmUoZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJyksXG5cdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSwgJ3gyJywgJ3kyJykpO1xuXHRcdH0sXG5cblx0XHR0ZXh0OiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgdGV4dCA9IG5ldyBQb2ludFRleHQoZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpXG5cdFx0XHRcdFx0LmFkZChnZXRQb2ludChub2RlLCAnZHgnLCAnZHknKSkpO1xuXHRcdFx0dGV4dC5zZXRDb250ZW50KG5vZGUudGV4dENvbnRlbnQudHJpbSgpIHx8ICcnKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSkge1xuXHRcdHZhciB0cmFuc2Zvcm1zID0gKG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpIHx8ICcnKS5zcGxpdCgvXFwpXFxzKi9nKSxcblx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRyYW5zZm9ybXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1tpXTtcblx0XHRcdGlmICghdHJhbnNmb3JtKVxuXHRcdFx0XHRicmVhaztcblx0XHRcdHZhciBwYXJ0cyA9IHRyYW5zZm9ybS5zcGxpdCgvXFwoXFxzKi8pLFxuXHRcdFx0XHRjb21tYW5kID0gcGFydHNbMF0sXG5cdFx0XHRcdHYgPSBwYXJ0c1sxXS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdGZvciAodmFyIGogPSAwLCBtID0gdi5sZW5ndGg7IGogPCBtOyBqKyspXG5cdFx0XHRcdHZbal0gPSBwYXJzZUZsb2F0KHZbal0pO1xuXHRcdFx0c3dpdGNoIChjb21tYW5kKSB7XG5cdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRtYXRyaXguY29uY2F0ZW5hdGUoXG5cdFx0XHRcdFx0XHRuZXcgTWF0cml4KHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRtYXRyaXgucm90YXRlKHZbMF0sIHZbMV0sIHZbMl0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdG1hdHJpeC50cmFuc2xhdGUodlswXSwgdlsxXSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRtYXRyaXguc2NhbGUodik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2tld1gnOlxuXHRcdFx0XHRtYXRyaXguc2tldyh2WzBdLCAwKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdza2V3WSc6XG5cdFx0XHRcdG1hdHJpeC5za2V3KDAsIHZbMF0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0aXRlbS50cmFuc2Zvcm0obWF0cml4KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5T3BhY2l0eShpdGVtLCB2YWx1ZSwgbmFtZSkge1xuXHRcdHZhciBjb2xvciA9IGl0ZW1bbmFtZSA9PT0gJ2ZpbGwtb3BhY2l0eScgPyAnZ2V0RmlsbENvbG9yJ1xuXHRcdFx0XHQ6ICdnZXRTdHJva2VDb2xvciddKCk7XG5cdFx0aWYgKGNvbG9yKVxuXHRcdFx0Y29sb3Iuc2V0QWxwaGEocGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHR9XG5cblx0dmFyIGF0dHJpYnV0ZXMgPSBCYXNlLnNldChCYXNlLmVhY2goU1ZHU3R5bGVzLCBmdW5jdGlvbihlbnRyeSkge1xuXHRcdHRoaXNbZW50cnkuYXR0cmlidXRlXSA9IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpdGVtW2VudHJ5LnNldF0oY29udmVydFZhbHVlKHZhbHVlLCBlbnRyeS50eXBlLCBlbnRyeS5mcm9tU1ZHKSk7XG5cdFx0XHRpZiAoZW50cnkudHlwZSA9PT0gJ2NvbG9yJyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcblx0XHRcdFx0dmFyIGNvbG9yID0gaXRlbVtlbnRyeS5nZXRdKCk7XG5cdFx0XHRcdGlmIChjb2xvcilcblx0XHRcdFx0XHRjb2xvci50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0aXRlbS5nZXRQb3NpdGlvbih0cnVlKS5uZWdhdGUoKSkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sIHt9KSwge1xuXHRcdGlkOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0ZGVmaW5pdGlvbnNbdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmIChpdGVtLnNldE5hbWUpXG5cdFx0XHRcdGl0ZW0uc2V0TmFtZSh2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdCdjbGlwLXBhdGgnOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0dmFyIGNsaXAgPSBnZXREZWZpbml0aW9uKHZhbHVlKTtcblx0XHRcdGlmIChjbGlwKSB7XG5cdFx0XHRcdGNsaXAgPSBjbGlwLmNsb25lKCk7XG5cdFx0XHRcdGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG5cdFx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcblx0XHRcdFx0XHRpdGVtLmluc2VydENoaWxkKDAsIGNsaXApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgR3JvdXAoY2xpcCwgaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z3JhZGllbnRUcmFuc2Zvcm06IGFwcGx5VHJhbnNmb3JtLFxuXHRcdHRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG5cblx0XHQnZmlsbC1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuXHRcdCdzdHJva2Utb3BhY2l0eSc6IGFwcGx5T3BhY2l0eSxcblxuXHRcdHZpc2liaWxpdHk6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpdGVtLnNldFZpc2libGUodmFsdWUgPT09ICd2aXNpYmxlJyk7XG5cdFx0fSxcblxuXHRcdGRpc3BsYXk6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpdGVtLnNldFZpc2libGUodmFsdWUgIT09IG51bGwpO1xuXHRcdH0sXG5cblx0XHQnc3RvcC1jb2xvcic6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5zZXRDb2xvcilcblx0XHRcdFx0aXRlbS5zZXRDb2xvcih2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdCdzdG9wLW9wYWNpdHknOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGl0ZW0uX2NvbG9yKVxuXHRcdFx0XHRpdGVtLl9jb2xvci5zZXRBbHBoYShwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0fSxcblxuXHRcdG9mZnNldDogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdHZhciBwZXJjZW50YWdlID0gdmFsdWUubWF0Y2goLyguKiklJC8pO1xuXHRcdFx0aXRlbS5zZXRSYW1wUG9pbnQocGVyY2VudGFnZVxuXHRcdFx0XHRcdD8gcGVyY2VudGFnZVsxXSAvIDEwMFxuXHRcdFx0XHRcdDogcGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHRcdH0sXG5cblx0XHR2aWV3Qm94OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSwgc3R5bGVzKSB7XG5cdFx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUoY29udmVydFZhbHVlKHZhbHVlLCAnYXJyYXknKSksXG5cdFx0XHRcdHNpemUgPSBnZXRTaXplKG5vZGUsICd3aWR0aCcsICdoZWlnaHQnLCB0cnVlKTtcblx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcblx0XHRcdFx0dmFyIHNjYWxlID0gc2l6ZSA/IHJlY3QuZ2V0U2l6ZSgpLmRpdmlkZShzaXplKSA6IDEsXG5cdFx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShyZWN0LmdldFBvaW50KCkpLnNjYWxlKHNjYWxlKTtcblx0XHRcdFx0aXRlbS50cmFuc2Zvcm0obWF0cml4LmludmVydGVkKCkpO1xuXHRcdFx0fSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgU3ltYm9sKSB7XG5cdFx0XHRcdGlmIChzaXplKVxuXHRcdFx0XHRcdHJlY3Quc2V0U2l6ZShzaXplKTtcblx0XHRcdFx0dmFyIGNsaXAgPSBnZXRBdHRyaWJ1dGUobm9kZSwgJ292ZXJmbG93Jywgc3R5bGVzKSAhPSAndmlzaWJsZScsXG5cdFx0XHRcdFx0Z3JvdXAgPSBpdGVtLl9kZWZpbml0aW9uO1xuXHRcdFx0XHRpZiAoY2xpcCAmJiAhcmVjdC5jb250YWlucyhncm91cC5nZXRCb3VuZHMoKSkpIHtcblx0XHRcdFx0XHRjbGlwID0gbmV3IFNoYXBlLlJlY3RhbmdsZShyZWN0KS50cmFuc2Zvcm0oZ3JvdXAuX21hdHJpeCk7XG5cdFx0XHRcdFx0Y2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcblx0XHRcdFx0XHRncm91cC5hZGRDaGlsZChjbGlwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHN0eWxlcykge1xuXHRcdHZhciBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzW25hbWVdLFxuXHRcdFx0dmFsdWUgPSBhdHRyICYmIGF0dHIudmFsdWU7XG5cdFx0aWYgKCF2YWx1ZSkge1xuXHRcdFx0dmFyIHN0eWxlID0gQmFzZS5jYW1lbGl6ZShuYW1lKTtcblx0XHRcdHZhbHVlID0gbm9kZS5zdHlsZVtzdHlsZV07XG5cdFx0XHRpZiAoIXZhbHVlICYmIHN0eWxlcy5ub2RlW3N0eWxlXSAhPT0gc3R5bGVzLnBhcmVudFtzdHlsZV0pXG5cdFx0XHRcdHZhbHVlID0gc3R5bGVzLm5vZGVbc3R5bGVdO1xuXHRcdH1cblx0XHRyZXR1cm4gIXZhbHVlXG5cdFx0XHRcdD8gdW5kZWZpbmVkXG5cdFx0XHRcdDogdmFsdWUgPT09ICdub25lJ1xuXHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KSB7XG5cdFx0dmFyIHN0eWxlcyA9IHtcblx0XHRcdG5vZGU6IERvbUVsZW1lbnQuZ2V0U3R5bGVzKG5vZGUpIHx8IHt9LFxuXHRcdFx0cGFyZW50OiAhaXNSb290ICYmIERvbUVsZW1lbnQuZ2V0U3R5bGVzKG5vZGUucGFyZW50Tm9kZSkgfHwge31cblx0XHR9O1xuXHRcdEJhc2UuZWFjaChhdHRyaWJ1dGVzLCBmdW5jdGlvbihhcHBseSwgbmFtZSkge1xuXHRcdFx0dmFyIHZhbHVlID0gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHN0eWxlcyk7XG5cdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0aXRlbSA9IEJhc2UucGljayhhcHBseShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSwgc3R5bGVzKSwgaXRlbSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHR2YXIgZGVmaW5pdGlvbnMgPSB7fTtcblx0ZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbih2YWx1ZSkge1xuXHRcdHZhciBtYXRjaCA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9cXCgoPzojfCkoW14pJ10rKS8pO1xuXHRcdHJldHVybiBtYXRjaCAmJiBkZWZpbml0aW9uc1ttYXRjaFsxXV07XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRTVkcoc291cmNlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRpZiAoIXNvdXJjZSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGlmICghb3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG9wdGlvbnMgPSB7IG9uTG9hZDogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdHZhciBub2RlID0gc291cmNlLFxuXHRcdFx0c2NvcGUgPSBwYXBlcjtcblxuXHRcdGZ1bmN0aW9uIG9uTG9hZENhbGxiYWNrKHN2Zykge1xuXHRcdFx0cGFwZXIgPSBzY29wZTtcblx0XHRcdHZhciBpdGVtID0gaW1wb3J0U1ZHKHN2Zywgb3B0aW9ucywgaXNSb290KSxcblx0XHRcdFx0b25Mb2FkID0gb3B0aW9ucy5vbkxvYWQsXG5cdFx0XHRcdHZpZXcgPSBzY29wZS5wcm9qZWN0ICYmIHNjb3BlLmdldFZpZXcoKTtcblx0XHRcdGlmIChvbkxvYWQpXG5cdFx0XHRcdG9uTG9hZC5jYWxsKHRoaXMsIGl0ZW0pO1xuXHRcdFx0dmlldy51cGRhdGUoKTtcblx0XHR9XG5cblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgIS9eLio8Ly50ZXN0KHNvdXJjZSkpIHtcblx0XHRcdFx0bm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNvdXJjZSk7XG5cdFx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdFx0c291cmNlID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gSHR0cC5yZXF1ZXN0KCdnZXQnLCBzb3VyY2UsIG9uTG9hZENhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc291cmNlIGluc3RhbmNlb2YgRmlsZSkge1xuXHRcdFx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG9uTG9hZENhbGxiYWNrKHJlYWRlci5yZXN1bHQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcmVhZGVyLnJlYWRBc1RleHQoc291cmNlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpXG5cdFx0XHRub2RlID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzb3VyY2UsICdpbWFnZS9zdmcreG1sJyk7XG5cdFx0aWYgKCFub2RlLm5vZGVOYW1lKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBTVkcgc291cmNlOiAnICsgc291cmNlKTtcblx0XHR2YXIgdHlwZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdGltcG9ydGVyID0gaW1wb3J0ZXJzW3R5cGVdLFxuXHRcdFx0aXRlbSxcblx0XHRcdGRhdGEgPSBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1kYXRhJyksXG5cdFx0XHRzZXR0aW5ncyA9IHNjb3BlLnNldHRpbmdzLFxuXHRcdFx0YXBwbHlNYXRyaXggPSBzZXR0aW5ncy5hcHBseU1hdHJpeDtcblx0XHRzZXR0aW5ncy5hcHBseU1hdHJpeCA9IGZhbHNlO1xuXHRcdGl0ZW0gPSBpbXBvcnRlciAmJiBpbXBvcnRlcihub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHx8IG51bGw7XG5cdFx0c2V0dGluZ3MuYXBwbHlNYXRyaXggPSBhcHBseU1hdHJpeDtcblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0aWYgKHR5cGUgIT09ICcjZG9jdW1lbnQnICYmICEoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSlcblx0XHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHRcdFx0dmFyIG9uSW1wb3J0ID0gb3B0aW9ucy5vbkltcG9ydDtcblx0XHRcdGlmIChvbkltcG9ydClcblx0XHRcdFx0aXRlbSA9IG9uSW1wb3J0KG5vZGUsIGl0ZW0sIG9wdGlvbnMpIHx8IGl0ZW07XG5cdFx0XHRpZiAob3B0aW9ucy5leHBhbmRTaGFwZXMgJiYgaXRlbSBpbnN0YW5jZW9mIFNoYXBlKSB7XG5cdFx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtLnRvUGF0aCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRhdGEpXG5cdFx0XHRcdGl0ZW0uX2RhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXHRcdH1cblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRkZWZpbml0aW9ucyA9IHt9O1xuXHRcdFx0aWYgKGl0ZW0gJiYgQmFzZS5waWNrKG9wdGlvbnMuYXBwbHlNYXRyaXgsIGFwcGx5TWF0cml4KSlcblx0XHRcdFx0aXRlbS5tYXRyaXguYXBwbHkodHJ1ZSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGltcG9ydFNWRzogZnVuY3Rpb24obm9kZSwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkQ2hpbGQoaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRydWUpKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRpbXBvcnRTVkc6IGZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHRcdHJldHVybiBpbXBvcnRTVkcobm9kZSwgb3B0aW9ucywgdHJ1ZSk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbkJhc2UuZXhwb3J0cy5QYXBlclNjcmlwdCA9IChmdW5jdGlvbigpIHtcblx0dmFyIGV4cG9ydHMsIGRlZmluZSxcblx0XHRzY29wZSA9IHRoaXM7XG4hZnVuY3Rpb24oZSxyKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9yKGV4cG9ydHMpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiXSxyKToocihlLmFjb3JufHwoZS5hY29ybj17fSkpLHZvaWQgMCl9KHRoaXMsZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtmcj1lfHx7fTtmb3IodmFyIHIgaW4gbXIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZyLHIpfHwoZnJbcl09bXJbcl0pO2hyPWZyLnNvdXJjZUZpbGV8fG51bGx9ZnVuY3Rpb24gdChlLHIpe3ZhciB0PXZyKGRyLGUpO3IrPVwiIChcIit0LmxpbmUrXCI6XCIrdC5jb2x1bW4rXCIpXCI7dmFyIG49bmV3IFN5bnRheEVycm9yKHIpO3Rocm93IG4ucG9zPWUsbi5sb2M9dCxuLnJhaXNlZEF0PWJyLG59ZnVuY3Rpb24gbihlKXtmdW5jdGlvbiByKGUpe2lmKDE9PWUubGVuZ3RoKXJldHVybiB0Kz1cInJldHVybiBzdHIgPT09IFwiK0pTT04uc3RyaW5naWZ5KGVbMF0pK1wiO1wiO3QrPVwic3dpdGNoKHN0cil7XCI7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDsrK3IpdCs9XCJjYXNlIFwiK0pTT04uc3RyaW5naWZ5KGVbcl0pK1wiOlwiO3QrPVwicmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO1wifWU9ZS5zcGxpdChcIiBcIik7dmFyIHQ9XCJcIixuPVtdO2U6Zm9yKHZhciBhPTA7YTxlLmxlbmd0aDsrK2Epe2Zvcih2YXIgbz0wO288bi5sZW5ndGg7KytvKWlmKG5bb11bMF0ubGVuZ3RoPT1lW2FdLmxlbmd0aCl7bltvXS5wdXNoKGVbYV0pO2NvbnRpbnVlIGV9bi5wdXNoKFtlW2FdXSl9aWYobi5sZW5ndGg+Myl7bi5zb3J0KGZ1bmN0aW9uKGUscil7cmV0dXJuIHIubGVuZ3RoLWUubGVuZ3RofSksdCs9XCJzd2l0Y2goc3RyLmxlbmd0aCl7XCI7Zm9yKHZhciBhPTA7YTxuLmxlbmd0aDsrK2Epe3ZhciBpPW5bYV07dCs9XCJjYXNlIFwiK2lbMF0ubGVuZ3RoK1wiOlwiLHIoaSl9dCs9XCJ9XCJ9ZWxzZSByKGUpO3JldHVybiBuZXcgRnVuY3Rpb24oXCJzdHJcIix0KX1mdW5jdGlvbiBhKCl7dGhpcy5saW5lPUFyLHRoaXMuY29sdW1uPWJyLVNyfWZ1bmN0aW9uIG8oKXtBcj0xLGJyPVNyPTAsRXI9ITAsdSgpfWZ1bmN0aW9uIGkoZSxyKXtncj1icixmci5sb2NhdGlvbnMmJihrcj1uZXcgYSksd3I9ZSx1KCksQ3I9cixFcj1lLmJlZm9yZUV4cHJ9ZnVuY3Rpb24gcygpe3ZhciBlPWZyLm9uQ29tbWVudCYmZnIubG9jYXRpb25zJiZuZXcgYSxyPWJyLG49ZHIuaW5kZXhPZihcIiovXCIsYnIrPTIpO2lmKC0xPT09biYmdChici0yLFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIiksYnI9bisyLGZyLmxvY2F0aW9ucyl7S3QubGFzdEluZGV4PXI7Zm9yKHZhciBvOyhvPUt0LmV4ZWMoZHIpKSYmby5pbmRleDxicjspKytBcixTcj1vLmluZGV4K29bMF0ubGVuZ3RofWZyLm9uQ29tbWVudCYmZnIub25Db21tZW50KCEwLGRyLnNsaWNlKHIrMixuKSxyLGJyLGUsZnIubG9jYXRpb25zJiZuZXcgYSl9ZnVuY3Rpb24gYygpe2Zvcih2YXIgZT1icixyPWZyLm9uQ29tbWVudCYmZnIubG9jYXRpb25zJiZuZXcgYSx0PWRyLmNoYXJDb2RlQXQoYnIrPTIpO3ByPmJyJiYxMCE9PXQmJjEzIT09dCYmODIzMiE9PXQmJjgyMzMhPT10OykrK2JyLHQ9ZHIuY2hhckNvZGVBdChicik7ZnIub25Db21tZW50JiZmci5vbkNvbW1lbnQoITEsZHIuc2xpY2UoZSsyLGJyKSxlLGJyLHIsZnIubG9jYXRpb25zJiZuZXcgYSl9ZnVuY3Rpb24gdSgpe2Zvcig7cHI+YnI7KXt2YXIgZT1kci5jaGFyQ29kZUF0KGJyKTtpZigzMj09PWUpKyticjtlbHNlIGlmKDEzPT09ZSl7Kyticjt2YXIgcj1kci5jaGFyQ29kZUF0KGJyKTsxMD09PXImJisrYnIsZnIubG9jYXRpb25zJiYoKytBcixTcj1icil9ZWxzZSBpZigxMD09PWV8fDgyMzI9PT1lfHw4MjMzPT09ZSkrK2JyLGZyLmxvY2F0aW9ucyYmKCsrQXIsU3I9YnIpO2Vsc2UgaWYoZT44JiYxND5lKSsrYnI7ZWxzZSBpZig0Nz09PWUpe3ZhciByPWRyLmNoYXJDb2RlQXQoYnIrMSk7aWYoNDI9PT1yKXMoKTtlbHNle2lmKDQ3IT09cilicmVhaztjKCl9fWVsc2UgaWYoMTYwPT09ZSkrK2JyO2Vsc2V7aWYoIShlPj01NzYwJiZKdC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpKSlicmVhazsrK2JyfX19ZnVuY3Rpb24gbCgpe3ZhciBlPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIGU+PTQ4JiY1Nz49ZT9FKCEwKTooKyticixpKHh0KSl9ZnVuY3Rpb24gZigpe3ZhciBlPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIEVyPygrK2JyLGsoKSk6NjE9PT1lP3goRXQsMik6eCh3dCwxKX1mdW5jdGlvbiBkKCl7dmFyIGU9ZHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gNjE9PT1lP3goRXQsMik6eChEdCwxKX1mdW5jdGlvbiBwKGUpe3ZhciByPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIHI9PT1lP3goMTI0PT09ZT9MdDpVdCwyKTo2MT09PXI/eChFdCwyKTp4KDEyND09PWU/UnQ6VHQsMSl9ZnVuY3Rpb24gaCgpe3ZhciBlPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIDYxPT09ZT94KEV0LDIpOngoVnQsMSl9ZnVuY3Rpb24gbShlKXt2YXIgcj1kci5jaGFyQ29kZUF0KGJyKzEpO3JldHVybiByPT09ZT80NT09ciYmNjI9PWRyLmNoYXJDb2RlQXQoYnIrMikmJkd0LnRlc3QoZHIuc2xpY2UoTHIsYnIpKT8oYnIrPTMsYygpLHUoKSxnKCkpOngoU3QsMik6NjE9PT1yP3goRXQsMik6eChBdCwxKX1mdW5jdGlvbiB2KGUpe3ZhciByPWRyLmNoYXJDb2RlQXQoYnIrMSksdD0xO3JldHVybiByPT09ZT8odD02Mj09PWUmJjYyPT09ZHIuY2hhckNvZGVBdChicisyKT8zOjIsNjE9PT1kci5jaGFyQ29kZUF0KGJyK3QpP3goRXQsdCsxKTp4KGp0LHQpKTozMz09ciYmNjA9PWUmJjQ1PT1kci5jaGFyQ29kZUF0KGJyKzIpJiY0NT09ZHIuY2hhckNvZGVBdChiciszKT8oYnIrPTQsYygpLHUoKSxnKCkpOig2MT09PXImJih0PTYxPT09ZHIuY2hhckNvZGVBdChicisyKT8zOjIpLHgoT3QsdCkpfWZ1bmN0aW9uIGIoZSl7dmFyIHI9ZHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gNjE9PT1yP3gocXQsNjE9PT1kci5jaGFyQ29kZUF0KGJyKzIpPzM6Mik6eCg2MT09PWU/Q3Q6SXQsMSl9ZnVuY3Rpb24geShlKXtzd2l0Y2goZSl7Y2FzZSA0NjpyZXR1cm4gbCgpO2Nhc2UgNDA6cmV0dXJuKyticixpKG10KTtjYXNlIDQxOnJldHVybisrYnIsaSh2dCk7Y2FzZSA1OTpyZXR1cm4rK2JyLGkoeXQpO2Nhc2UgNDQ6cmV0dXJuKyticixpKGJ0KTtjYXNlIDkxOnJldHVybisrYnIsaShmdCk7Y2FzZSA5MzpyZXR1cm4rK2JyLGkoZHQpO2Nhc2UgMTIzOnJldHVybisrYnIsaShwdCk7Y2FzZSAxMjU6cmV0dXJuKyticixpKGh0KTtjYXNlIDU4OnJldHVybisrYnIsaShndCk7Y2FzZSA2MzpyZXR1cm4rK2JyLGkoa3QpO2Nhc2UgNDg6dmFyIHI9ZHIuY2hhckNvZGVBdChicisxKTtpZigxMjA9PT1yfHw4OD09PXIpcmV0dXJuIEMoKTtjYXNlIDQ5OmNhc2UgNTA6Y2FzZSA1MTpjYXNlIDUyOmNhc2UgNTM6Y2FzZSA1NDpjYXNlIDU1OmNhc2UgNTY6Y2FzZSA1NzpyZXR1cm4gRSghMSk7Y2FzZSAzNDpjYXNlIDM5OnJldHVybiBBKGUpO2Nhc2UgNDc6cmV0dXJuIGYoZSk7Y2FzZSAzNzpjYXNlIDQyOnJldHVybiBkKCk7Y2FzZSAxMjQ6Y2FzZSAzODpyZXR1cm4gcChlKTtjYXNlIDk0OnJldHVybiBoKCk7Y2FzZSA0MzpjYXNlIDQ1OnJldHVybiBtKGUpO2Nhc2UgNjA6Y2FzZSA2MjpyZXR1cm4gdihlKTtjYXNlIDYxOmNhc2UgMzM6cmV0dXJuIGIoZSk7Y2FzZSAxMjY6cmV0dXJuIHgoSXQsMSl9cmV0dXJuITF9ZnVuY3Rpb24gZyhlKXtpZihlP2JyPXlyKzE6eXI9YnIsZnIubG9jYXRpb25zJiYoeHI9bmV3IGEpLGUpcmV0dXJuIGsoKTtpZihicj49cHIpcmV0dXJuIGkoQnIpO3ZhciByPWRyLmNoYXJDb2RlQXQoYnIpO2lmKFF0KHIpfHw5Mj09PXIpcmV0dXJuIEwoKTt2YXIgbj15KHIpO2lmKG49PT0hMSl7dmFyIG89U3RyaW5nLmZyb21DaGFyQ29kZShyKTtpZihcIlxcXFxcIj09PW98fCR0LnRlc3QobykpcmV0dXJuIEwoKTt0KGJyLFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiK28rXCInXCIpfXJldHVybiBufWZ1bmN0aW9uIHgoZSxyKXt2YXIgdD1kci5zbGljZShicixicityKTticis9cixpKGUsdCl9ZnVuY3Rpb24gaygpe2Zvcih2YXIgZSxyLG49XCJcIixhPWJyOzspe2JyPj1wciYmdChhLFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTt2YXIgbz1kci5jaGFyQXQoYnIpO2lmKEd0LnRlc3QobykmJnQoYSxcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIiksZSllPSExO2Vsc2V7aWYoXCJbXCI9PT1vKXI9ITA7ZWxzZSBpZihcIl1cIj09PW8mJnIpcj0hMTtlbHNlIGlmKFwiL1wiPT09byYmIXIpYnJlYWs7ZT1cIlxcXFxcIj09PW99Kyticn12YXIgbj1kci5zbGljZShhLGJyKTsrK2JyO3ZhciBzPUkoKTtyZXR1cm4gcyYmIS9eW2dtc2l5XSokLy50ZXN0KHMpJiZ0KGEsXCJJbnZhbGlkIHJlZ2V4cCBmbGFnXCIpLGkoanIsbmV3IFJlZ0V4cChuLHMpKX1mdW5jdGlvbiB3KGUscil7Zm9yKHZhciB0PWJyLG49MCxhPTAsbz1udWxsPT1yPzEvMDpyO28+YTsrK2Epe3ZhciBpLHM9ZHIuY2hhckNvZGVBdChicik7aWYoaT1zPj05Nz9zLTk3KzEwOnM+PTY1P3MtNjUrMTA6cz49NDgmJjU3Pj1zP3MtNDg6MS8wLGk+PWUpYnJlYWs7KyticixuPW4qZStpfXJldHVybiBicj09PXR8fG51bGwhPXImJmJyLXQhPT1yP251bGw6bn1mdW5jdGlvbiBDKCl7YnIrPTI7dmFyIGU9dygxNik7cmV0dXJuIG51bGw9PWUmJnQoeXIrMixcIkV4cGVjdGVkIGhleGFkZWNpbWFsIG51bWJlclwiKSxRdChkci5jaGFyQ29kZUF0KGJyKSkmJnQoYnIsXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKSxpKE9yLGUpfWZ1bmN0aW9uIEUoZSl7dmFyIHI9YnIsbj0hMSxhPTQ4PT09ZHIuY2hhckNvZGVBdChicik7ZXx8bnVsbCE9PXcoMTApfHx0KHIsXCJJbnZhbGlkIG51bWJlclwiKSw0Nj09PWRyLmNoYXJDb2RlQXQoYnIpJiYoKyticix3KDEwKSxuPSEwKTt2YXIgbz1kci5jaGFyQ29kZUF0KGJyKTsoNjk9PT1vfHwxMDE9PT1vKSYmKG89ZHIuY2hhckNvZGVBdCgrK2JyKSwoNDM9PT1vfHw0NT09PW8pJiYrK2JyLG51bGw9PT13KDEwKSYmdChyLFwiSW52YWxpZCBudW1iZXJcIiksbj0hMCksUXQoZHIuY2hhckNvZGVBdChicikpJiZ0KGJyLFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7dmFyIHMsYz1kci5zbGljZShyLGJyKTtyZXR1cm4gbj9zPXBhcnNlRmxvYXQoYyk6YSYmMSE9PWMubGVuZ3RoPy9bODldLy50ZXN0KGMpfHxUcj90KHIsXCJJbnZhbGlkIG51bWJlclwiKTpzPXBhcnNlSW50KGMsOCk6cz1wYXJzZUludChjLDEwKSxpKE9yLHMpfWZ1bmN0aW9uIEEoZSl7YnIrKztmb3IodmFyIHI9XCJcIjs7KXticj49cHImJnQoeXIsXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO3ZhciBuPWRyLmNoYXJDb2RlQXQoYnIpO2lmKG49PT1lKXJldHVybisrYnIsaShEcixyKTtpZig5Mj09PW4pe249ZHIuY2hhckNvZGVBdCgrK2JyKTt2YXIgYT0vXlswLTddKy8uZXhlYyhkci5zbGljZShicixiciszKSk7Zm9yKGEmJihhPWFbMF0pO2EmJnBhcnNlSW50KGEsOCk+MjU1OylhPWEuc2xpY2UoMCxhLmxlbmd0aC0xKTtpZihcIjBcIj09PWEmJihhPW51bGwpLCsrYnIsYSlUciYmdChici0yLFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiKSxyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGEsOCkpLGJyKz1hLmxlbmd0aC0xO2Vsc2Ugc3dpdGNoKG4pe2Nhc2UgMTEwOnIrPVwiXFxuXCI7YnJlYWs7Y2FzZSAxMTQ6cis9XCJcXHJcIjticmVhaztjYXNlIDEyMDpyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKFMoMikpO2JyZWFrO2Nhc2UgMTE3OnIrPVN0cmluZy5mcm9tQ2hhckNvZGUoUyg0KSk7YnJlYWs7Y2FzZSA4NTpyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKFMoOCkpO2JyZWFrO2Nhc2UgMTE2OnIrPVwiXHRcIjticmVhaztjYXNlIDk4OnIrPVwiXFxiXCI7YnJlYWs7Y2FzZSAxMTg6cis9XCJcdTAwMGJcIjticmVhaztjYXNlIDEwMjpyKz1cIlxcZlwiO2JyZWFrO2Nhc2UgNDg6cis9XCJcXDBcIjticmVhaztjYXNlIDEzOjEwPT09ZHIuY2hhckNvZGVBdChicikmJisrYnI7Y2FzZSAxMDpmci5sb2NhdGlvbnMmJihTcj1iciwrK0FyKTticmVhaztkZWZhdWx0OnIrPVN0cmluZy5mcm9tQ2hhckNvZGUobil9fWVsc2UoMTM9PT1ufHwxMD09PW58fDgyMzI9PT1ufHw4MjMzPT09bikmJnQoeXIsXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpLHIrPVN0cmluZy5mcm9tQ2hhckNvZGUobiksKyticn19ZnVuY3Rpb24gUyhlKXt2YXIgcj13KDE2LGUpO3JldHVybiBudWxsPT09ciYmdCh5cixcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpLHJ9ZnVuY3Rpb24gSSgpe0J0PSExO2Zvcih2YXIgZSxyPSEwLG49YnI7Oyl7dmFyIGE9ZHIuY2hhckNvZGVBdChicik7aWYoWXQoYSkpQnQmJihlKz1kci5jaGFyQXQoYnIpKSwrK2JyO2Vsc2V7aWYoOTIhPT1hKWJyZWFrO0J0fHwoZT1kci5zbGljZShuLGJyKSksQnQ9ITAsMTE3IT1kci5jaGFyQ29kZUF0KCsrYnIpJiZ0KGJyLFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKSwrK2JyO3ZhciBvPVMoNCksaT1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pO2l8fHQoYnItMSxcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIiksKHI/UXQobyk6WXQobykpfHx0KGJyLTQsXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpLGUrPWl9cj0hMX1yZXR1cm4gQnQ/ZTpkci5zbGljZShuLGJyKX1mdW5jdGlvbiBMKCl7dmFyIGU9SSgpLHI9RnI7cmV0dXJuIEJ0fHwoV3QoZSk/cj1sdFtlXTooZnIuZm9yYmlkUmVzZXJ2ZWQmJigzPT09ZnIuZWNtYVZlcnNpb24/TXQ6enQpKGUpfHxUciYmWHQoZSkpJiZ0KHlyLFwiVGhlIGtleXdvcmQgJ1wiK2UrXCInIGlzIHJlc2VydmVkXCIpKSxpKHIsZSl9ZnVuY3Rpb24gVSgpe0lyPXlyLExyPWdyLFVyPWtyLGcoKX1mdW5jdGlvbiBSKGUpe2lmKFRyPWUsYnI9THIsZnIubG9jYXRpb25zKWZvcig7U3I+YnI7KVNyPWRyLmxhc3RJbmRleE9mKFwiXFxuXCIsU3ItMikrMSwtLUFyO3UoKSxnKCl9ZnVuY3Rpb24gVigpe3RoaXMudHlwZT1udWxsLHRoaXMuc3RhcnQ9eXIsdGhpcy5lbmQ9bnVsbH1mdW5jdGlvbiBUKCl7dGhpcy5zdGFydD14cix0aGlzLmVuZD1udWxsLG51bGwhPT1ociYmKHRoaXMuc291cmNlPWhyKX1mdW5jdGlvbiBxKCl7dmFyIGU9bmV3IFY7cmV0dXJuIGZyLmxvY2F0aW9ucyYmKGUubG9jPW5ldyBUKSxmci5yYW5nZXMmJihlLnJhbmdlPVt5ciwwXSksZX1mdW5jdGlvbiBPKGUpe3ZhciByPW5ldyBWO3JldHVybiByLnN0YXJ0PWUuc3RhcnQsZnIubG9jYXRpb25zJiYoci5sb2M9bmV3IFQsci5sb2Muc3RhcnQ9ZS5sb2Muc3RhcnQpLGZyLnJhbmdlcyYmKHIucmFuZ2U9W2UucmFuZ2VbMF0sMF0pLHJ9ZnVuY3Rpb24gaihlLHIpe3JldHVybiBlLnR5cGU9cixlLmVuZD1Mcixmci5sb2NhdGlvbnMmJihlLmxvYy5lbmQ9VXIpLGZyLnJhbmdlcyYmKGUucmFuZ2VbMV09THIpLGV9ZnVuY3Rpb24gRChlKXtyZXR1cm4gZnIuZWNtYVZlcnNpb24+PTUmJlwiRXhwcmVzc2lvblN0YXRlbWVudFwiPT09ZS50eXBlJiZcIkxpdGVyYWxcIj09PWUuZXhwcmVzc2lvbi50eXBlJiZcInVzZSBzdHJpY3RcIj09PWUuZXhwcmVzc2lvbi52YWx1ZX1mdW5jdGlvbiBGKGUpe3JldHVybiB3cj09PWU/KFUoKSwhMCk6dm9pZCAwfWZ1bmN0aW9uIEIoKXtyZXR1cm4hZnIuc3RyaWN0U2VtaWNvbG9ucyYmKHdyPT09QnJ8fHdyPT09aHR8fEd0LnRlc3QoZHIuc2xpY2UoTHIseXIpKSl9ZnVuY3Rpb24gTSgpe0YoeXQpfHxCKCl8fFgoKX1mdW5jdGlvbiB6KGUpe3dyPT09ZT9VKCk6WCgpfWZ1bmN0aW9uIFgoKXt0KHlyLFwiVW5leHBlY3RlZCB0b2tlblwiKX1mdW5jdGlvbiBOKGUpe1wiSWRlbnRpZmllclwiIT09ZS50eXBlJiZcIk1lbWJlckV4cHJlc3Npb25cIiE9PWUudHlwZSYmdChlLnN0YXJ0LFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKSxUciYmXCJJZGVudGlmaWVyXCI9PT1lLnR5cGUmJk50KGUubmFtZSkmJnQoZS5zdGFydCxcIkFzc2lnbmluZyB0byBcIitlLm5hbWUrXCIgaW4gc3RyaWN0IG1vZGVcIil9ZnVuY3Rpb24gVyhlKXtJcj1Mcj1icixmci5sb2NhdGlvbnMmJihVcj1uZXcgYSksUnI9VHI9bnVsbCxWcj1bXSxnKCk7dmFyIHI9ZXx8cSgpLHQ9ITA7Zm9yKGV8fChyLmJvZHk9W10pO3dyIT09QnI7KXt2YXIgbj1KKCk7ci5ib2R5LnB1c2gobiksdCYmRChuKSYmUighMCksdD0hMX1yZXR1cm4gaihyLFwiUHJvZ3JhbVwiKX1mdW5jdGlvbiBKKCl7KHdyPT09d3R8fHdyPT09RXQmJlwiLz1cIj09Q3IpJiZnKCEwKTt2YXIgZT13cixyPXEoKTtzd2l0Y2goZSl7Y2FzZSBNcjpjYXNlIE5yOlUoKTt2YXIgbj1lPT09TXI7Rih5dCl8fEIoKT9yLmxhYmVsPW51bGw6d3IhPT1Gcj9YKCk6KHIubGFiZWw9bHIoKSxNKCkpO2Zvcih2YXIgYT0wO2E8VnIubGVuZ3RoOysrYSl7dmFyIG89VnJbYV07aWYobnVsbD09ci5sYWJlbHx8by5uYW1lPT09ci5sYWJlbC5uYW1lKXtpZihudWxsIT1vLmtpbmQmJihufHxcImxvb3BcIj09PW8ua2luZCkpYnJlYWs7aWYoci5sYWJlbCYmbilicmVha319cmV0dXJuIGE9PT1Wci5sZW5ndGgmJnQoci5zdGFydCxcIlVuc3ludGFjdGljIFwiK2Uua2V5d29yZCksaihyLG4/XCJCcmVha1N0YXRlbWVudFwiOlwiQ29udGludWVTdGF0ZW1lbnRcIik7Y2FzZSBXcjpyZXR1cm4gVSgpLE0oKSxqKHIsXCJEZWJ1Z2dlclN0YXRlbWVudFwiKTtjYXNlIFByOnJldHVybiBVKCksVnIucHVzaChadCksci5ib2R5PUooKSxWci5wb3AoKSx6KHR0KSxyLnRlc3Q9UCgpLE0oKSxqKHIsXCJEb1doaWxlU3RhdGVtZW50XCIpO2Nhc2UgX3I6aWYoVSgpLFZyLnB1c2goWnQpLHoobXQpLHdyPT09eXQpcmV0dXJuICQocixudWxsKTtpZih3cj09PXJ0KXt2YXIgaT1xKCk7cmV0dXJuIFUoKSxHKGksITApLGooaSxcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiksMT09PWkuZGVjbGFyYXRpb25zLmxlbmd0aCYmRih1dCk/XyhyLGkpOiQocixpKX12YXIgaT1LKCExLCEwKTtyZXR1cm4gRih1dCk/KE4oaSksXyhyLGkpKTokKHIsaSk7Y2FzZSBHcjpyZXR1cm4gVSgpLGNyKHIsITApO2Nhc2UgS3I6cmV0dXJuIFUoKSxyLnRlc3Q9UCgpLHIuY29uc2VxdWVudD1KKCksci5hbHRlcm5hdGU9RihIcik/SigpOm51bGwsaihyLFwiSWZTdGF0ZW1lbnRcIik7Y2FzZSBRcjpyZXR1cm4gUnJ8fHQoeXIsXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpLFUoKSxGKHl0KXx8QigpP3IuYXJndW1lbnQ9bnVsbDooci5hcmd1bWVudD1LKCksTSgpKSxqKHIsXCJSZXR1cm5TdGF0ZW1lbnRcIik7Y2FzZSBZcjpVKCksci5kaXNjcmltaW5hbnQ9UCgpLHIuY2FzZXM9W10seihwdCksVnIucHVzaChlbik7Zm9yKHZhciBzLGM7d3IhPWh0OylpZih3cj09PXpyfHx3cj09PUpyKXt2YXIgdT13cj09PXpyO3MmJmoocyxcIlN3aXRjaENhc2VcIiksci5jYXNlcy5wdXNoKHM9cSgpKSxzLmNvbnNlcXVlbnQ9W10sVSgpLHU/cy50ZXN0PUsoKTooYyYmdChJcixcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKSxjPSEwLHMudGVzdD1udWxsKSx6KGd0KX1lbHNlIHN8fFgoKSxzLmNvbnNlcXVlbnQucHVzaChKKCkpO3JldHVybiBzJiZqKHMsXCJTd2l0Y2hDYXNlXCIpLFUoKSxWci5wb3AoKSxqKHIsXCJTd2l0Y2hTdGF0ZW1lbnRcIik7Y2FzZSBacjpyZXR1cm4gVSgpLEd0LnRlc3QoZHIuc2xpY2UoTHIseXIpKSYmdChMcixcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKSxyLmFyZ3VtZW50PUsoKSxNKCksaihyLFwiVGhyb3dTdGF0ZW1lbnRcIik7Y2FzZSBldDppZihVKCksci5ibG9jaz1IKCksci5oYW5kbGVyPW51bGwsd3I9PT1Ycil7dmFyIGw9cSgpO1UoKSx6KG10KSxsLnBhcmFtPWxyKCksVHImJk50KGwucGFyYW0ubmFtZSkmJnQobC5wYXJhbS5zdGFydCxcIkJpbmRpbmcgXCIrbC5wYXJhbS5uYW1lK1wiIGluIHN0cmljdCBtb2RlXCIpLHoodnQpLGwuZ3VhcmQ9bnVsbCxsLmJvZHk9SCgpLHIuaGFuZGxlcj1qKGwsXCJDYXRjaENsYXVzZVwiKX1yZXR1cm4gci5ndWFyZGVkSGFuZGxlcnM9cXIsci5maW5hbGl6ZXI9Rigkcik/SCgpOm51bGwsci5oYW5kbGVyfHxyLmZpbmFsaXplcnx8dChyLnN0YXJ0LFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKSxqKHIsXCJUcnlTdGF0ZW1lbnRcIik7Y2FzZSBydDpyZXR1cm4gVSgpLEcociksTSgpLGoocixcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7Y2FzZSB0dDpyZXR1cm4gVSgpLHIudGVzdD1QKCksVnIucHVzaChadCksci5ib2R5PUooKSxWci5wb3AoKSxqKHIsXCJXaGlsZVN0YXRlbWVudFwiKTtjYXNlIG50OnJldHVybiBUciYmdCh5cixcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKSxVKCksci5vYmplY3Q9UCgpLHIuYm9keT1KKCksaihyLFwiV2l0aFN0YXRlbWVudFwiKTtjYXNlIHB0OnJldHVybiBIKCk7Y2FzZSB5dDpyZXR1cm4gVSgpLGoocixcIkVtcHR5U3RhdGVtZW50XCIpO2RlZmF1bHQ6dmFyIGY9Q3IsZD1LKCk7aWYoZT09PUZyJiZcIklkZW50aWZpZXJcIj09PWQudHlwZSYmRihndCkpe2Zvcih2YXIgYT0wO2E8VnIubGVuZ3RoOysrYSlWclthXS5uYW1lPT09ZiYmdChkLnN0YXJ0LFwiTGFiZWwgJ1wiK2YrXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7dmFyIHA9d3IuaXNMb29wP1wibG9vcFwiOndyPT09WXI/XCJzd2l0Y2hcIjpudWxsO3JldHVybiBWci5wdXNoKHtuYW1lOmYsa2luZDpwfSksci5ib2R5PUooKSxWci5wb3AoKSxyLmxhYmVsPWQsaihyLFwiTGFiZWxlZFN0YXRlbWVudFwiKX1yZXR1cm4gci5leHByZXNzaW9uPWQsTSgpLGoocixcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIil9fWZ1bmN0aW9uIFAoKXt6KG10KTt2YXIgZT1LKCk7cmV0dXJuIHoodnQpLGV9ZnVuY3Rpb24gSChlKXt2YXIgcix0PXEoKSxuPSEwLGE9ITE7Zm9yKHQuYm9keT1bXSx6KHB0KTshRihodCk7KXt2YXIgbz1KKCk7dC5ib2R5LnB1c2gobyksbiYmZSYmRChvKSYmKHI9YSxSKGE9ITApKSxuPSExfXJldHVybiBhJiYhciYmUighMSksaih0LFwiQmxvY2tTdGF0ZW1lbnRcIil9ZnVuY3Rpb24gJChlLHIpe3JldHVybiBlLmluaXQ9cix6KHl0KSxlLnRlc3Q9d3I9PT15dD9udWxsOksoKSx6KHl0KSxlLnVwZGF0ZT13cj09PXZ0P251bGw6SygpLHoodnQpLGUuYm9keT1KKCksVnIucG9wKCksaihlLFwiRm9yU3RhdGVtZW50XCIpfWZ1bmN0aW9uIF8oZSxyKXtyZXR1cm4gZS5sZWZ0PXIsZS5yaWdodD1LKCkseih2dCksZS5ib2R5PUooKSxWci5wb3AoKSxqKGUsXCJGb3JJblN0YXRlbWVudFwiKX1mdW5jdGlvbiBHKGUscil7Zm9yKGUuZGVjbGFyYXRpb25zPVtdLGUua2luZD1cInZhclwiOzspe3ZhciBuPXEoKTtpZihuLmlkPWxyKCksVHImJk50KG4uaWQubmFtZSkmJnQobi5pZC5zdGFydCxcIkJpbmRpbmcgXCIrbi5pZC5uYW1lK1wiIGluIHN0cmljdCBtb2RlXCIpLG4uaW5pdD1GKEN0KT9LKCEwLHIpOm51bGwsZS5kZWNsYXJhdGlvbnMucHVzaChqKG4sXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpLCFGKGJ0KSlicmVha31yZXR1cm4gZX1mdW5jdGlvbiBLKGUscil7dmFyIHQ9UShyKTtpZighZSYmd3I9PT1idCl7dmFyIG49Tyh0KTtmb3Iobi5leHByZXNzaW9ucz1bdF07RihidCk7KW4uZXhwcmVzc2lvbnMucHVzaChRKHIpKTtyZXR1cm4gaihuLFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpfXJldHVybiB0fWZ1bmN0aW9uIFEoZSl7dmFyIHI9WShlKTtpZih3ci5pc0Fzc2lnbil7dmFyIHQ9TyhyKTtyZXR1cm4gdC5vcGVyYXRvcj1Dcix0LmxlZnQ9cixVKCksdC5yaWdodD1RKGUpLE4ociksaih0LFwiQXNzaWdubWVudEV4cHJlc3Npb25cIil9cmV0dXJuIHJ9ZnVuY3Rpb24gWShlKXt2YXIgcj1aKGUpO2lmKEYoa3QpKXt2YXIgdD1PKHIpO3JldHVybiB0LnRlc3Q9cix0LmNvbnNlcXVlbnQ9SyghMCkseihndCksdC5hbHRlcm5hdGU9SyghMCxlKSxqKHQsXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIil9cmV0dXJuIHJ9ZnVuY3Rpb24gWihlKXtyZXR1cm4gZXIocnIoKSwtMSxlKX1mdW5jdGlvbiBlcihlLHIsdCl7dmFyIG49d3IuYmlub3A7aWYobnVsbCE9biYmKCF0fHx3ciE9PXV0KSYmbj5yKXt2YXIgYT1PKGUpO2EubGVmdD1lLGEub3BlcmF0b3I9Q3IsVSgpLGEucmlnaHQ9ZXIocnIoKSxuLHQpO3ZhciBvPWooYSwvJiZ8XFx8XFx8Ly50ZXN0KGEub3BlcmF0b3IpP1wiTG9naWNhbEV4cHJlc3Npb25cIjpcIkJpbmFyeUV4cHJlc3Npb25cIik7cmV0dXJuIGVyKG8scix0KX1yZXR1cm4gZX1mdW5jdGlvbiBycigpe2lmKHdyLnByZWZpeCl7dmFyIGU9cSgpLHI9d3IuaXNVcGRhdGU7cmV0dXJuIGUub3BlcmF0b3I9Q3IsZS5wcmVmaXg9ITAsRXI9ITAsVSgpLGUuYXJndW1lbnQ9cnIoKSxyP04oZS5hcmd1bWVudCk6VHImJlwiZGVsZXRlXCI9PT1lLm9wZXJhdG9yJiZcIklkZW50aWZpZXJcIj09PWUuYXJndW1lbnQudHlwZSYmdChlLnN0YXJ0LFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIiksaihlLHI/XCJVcGRhdGVFeHByZXNzaW9uXCI6XCJVbmFyeUV4cHJlc3Npb25cIil9Zm9yKHZhciBuPXRyKCk7d3IucG9zdGZpeCYmIUIoKTspe3ZhciBlPU8obik7ZS5vcGVyYXRvcj1DcixlLnByZWZpeD0hMSxlLmFyZ3VtZW50PW4sTihuKSxVKCksbj1qKGUsXCJVcGRhdGVFeHByZXNzaW9uXCIpfXJldHVybiBufWZ1bmN0aW9uIHRyKCl7cmV0dXJuIG5yKGFyKCkpfWZ1bmN0aW9uIG5yKGUscil7aWYoRih4dCkpe3ZhciB0PU8oZSk7cmV0dXJuIHQub2JqZWN0PWUsdC5wcm9wZXJ0eT1scighMCksdC5jb21wdXRlZD0hMSxucihqKHQsXCJNZW1iZXJFeHByZXNzaW9uXCIpLHIpfWlmKEYoZnQpKXt2YXIgdD1PKGUpO3JldHVybiB0Lm9iamVjdD1lLHQucHJvcGVydHk9SygpLHQuY29tcHV0ZWQ9ITAseihkdCksbnIoaih0LFwiTWVtYmVyRXhwcmVzc2lvblwiKSxyKX1pZighciYmRihtdCkpe3ZhciB0PU8oZSk7cmV0dXJuIHQuY2FsbGVlPWUsdC5hcmd1bWVudHM9dXIodnQsITEpLG5yKGoodCxcIkNhbGxFeHByZXNzaW9uXCIpLHIpfXJldHVybiBlfWZ1bmN0aW9uIGFyKCl7c3dpdGNoKHdyKXtjYXNlIG90OnZhciBlPXEoKTtyZXR1cm4gVSgpLGooZSxcIlRoaXNFeHByZXNzaW9uXCIpO2Nhc2UgRnI6cmV0dXJuIGxyKCk7Y2FzZSBPcjpjYXNlIERyOmNhc2UganI6dmFyIGU9cSgpO3JldHVybiBlLnZhbHVlPUNyLGUucmF3PWRyLnNsaWNlKHlyLGdyKSxVKCksaihlLFwiTGl0ZXJhbFwiKTtjYXNlIGl0OmNhc2Ugc3Q6Y2FzZSBjdDp2YXIgZT1xKCk7cmV0dXJuIGUudmFsdWU9d3IuYXRvbVZhbHVlLGUucmF3PXdyLmtleXdvcmQsVSgpLGooZSxcIkxpdGVyYWxcIik7Y2FzZSBtdDp2YXIgcj14cix0PXlyO1UoKTt2YXIgbj1LKCk7cmV0dXJuIG4uc3RhcnQ9dCxuLmVuZD1ncixmci5sb2NhdGlvbnMmJihuLmxvYy5zdGFydD1yLG4ubG9jLmVuZD1rciksZnIucmFuZ2VzJiYobi5yYW5nZT1bdCxncl0pLHoodnQpLG47Y2FzZSBmdDp2YXIgZT1xKCk7cmV0dXJuIFUoKSxlLmVsZW1lbnRzPXVyKGR0LCEwLCEwKSxqKGUsXCJBcnJheUV4cHJlc3Npb25cIik7Y2FzZSBwdDpyZXR1cm4gaXIoKTtjYXNlIEdyOnZhciBlPXEoKTtyZXR1cm4gVSgpLGNyKGUsITEpO2Nhc2UgYXQ6cmV0dXJuIG9yKCk7ZGVmYXVsdDpYKCl9fWZ1bmN0aW9uIG9yKCl7dmFyIGU9cSgpO3JldHVybiBVKCksZS5jYWxsZWU9bnIoYXIoKSwhMCksZS5hcmd1bWVudHM9RihtdCk/dXIodnQsITEpOnFyLGooZSxcIk5ld0V4cHJlc3Npb25cIil9ZnVuY3Rpb24gaXIoKXt2YXIgZT1xKCkscj0hMCxuPSExO2ZvcihlLnByb3BlcnRpZXM9W10sVSgpOyFGKGh0KTspe2lmKHIpcj0hMTtlbHNlIGlmKHooYnQpLGZyLmFsbG93VHJhaWxpbmdDb21tYXMmJkYoaHQpKWJyZWFrO3ZhciBhLG89e2tleTpzcigpfSxpPSExO2lmKEYoZ3QpPyhvLnZhbHVlPUsoITApLGE9by5raW5kPVwiaW5pdFwiKTpmci5lY21hVmVyc2lvbj49NSYmXCJJZGVudGlmaWVyXCI9PT1vLmtleS50eXBlJiYoXCJnZXRcIj09PW8ua2V5Lm5hbWV8fFwic2V0XCI9PT1vLmtleS5uYW1lKT8oaT1uPSEwLGE9by5raW5kPW8ua2V5Lm5hbWUsby5rZXk9c3IoKSx3ciE9PW10JiZYKCksby52YWx1ZT1jcihxKCksITEpKTpYKCksXCJJZGVudGlmaWVyXCI9PT1vLmtleS50eXBlJiYoVHJ8fG4pKWZvcih2YXIgcz0wO3M8ZS5wcm9wZXJ0aWVzLmxlbmd0aDsrK3Mpe3ZhciBjPWUucHJvcGVydGllc1tzXTtpZihjLmtleS5uYW1lPT09by5rZXkubmFtZSl7dmFyIHU9YT09Yy5raW5kfHxpJiZcImluaXRcIj09PWMua2luZHx8XCJpbml0XCI9PT1hJiYoXCJnZXRcIj09PWMua2luZHx8XCJzZXRcIj09PWMua2luZCk7dSYmIVRyJiZcImluaXRcIj09PWEmJlwiaW5pdFwiPT09Yy5raW5kJiYodT0hMSksdSYmdChvLmtleS5zdGFydCxcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKX19ZS5wcm9wZXJ0aWVzLnB1c2gobyl9cmV0dXJuIGooZSxcIk9iamVjdEV4cHJlc3Npb25cIil9ZnVuY3Rpb24gc3IoKXtyZXR1cm4gd3I9PT1Pcnx8d3I9PT1Ecj9hcigpOmxyKCEwKX1mdW5jdGlvbiBjcihlLHIpe3dyPT09RnI/ZS5pZD1scigpOnI/WCgpOmUuaWQ9bnVsbCxlLnBhcmFtcz1bXTt2YXIgbj0hMDtmb3IoeihtdCk7IUYodnQpOyluP249ITE6eihidCksZS5wYXJhbXMucHVzaChscigpKTt2YXIgYT1ScixvPVZyO2lmKFJyPSEwLFZyPVtdLGUuYm9keT1IKCEwKSxScj1hLFZyPW8sVHJ8fGUuYm9keS5ib2R5Lmxlbmd0aCYmRChlLmJvZHkuYm9keVswXSkpZm9yKHZhciBpPWUuaWQ/LTE6MDtpPGUucGFyYW1zLmxlbmd0aDsrK2kpe3ZhciBzPTA+aT9lLmlkOmUucGFyYW1zW2ldO2lmKChYdChzLm5hbWUpfHxOdChzLm5hbWUpKSYmdChzLnN0YXJ0LFwiRGVmaW5pbmcgJ1wiK3MubmFtZStcIicgaW4gc3RyaWN0IG1vZGVcIiksaT49MClmb3IodmFyIGM9MDtpPmM7KytjKXMubmFtZT09PWUucGFyYW1zW2NdLm5hbWUmJnQocy5zdGFydCxcIkFyZ3VtZW50IG5hbWUgY2xhc2ggaW4gc3RyaWN0IG1vZGVcIil9cmV0dXJuIGooZSxyP1wiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIpfWZ1bmN0aW9uIHVyKGUscix0KXtmb3IodmFyIG49W10sYT0hMDshRihlKTspe2lmKGEpYT0hMTtlbHNlIGlmKHooYnQpLHImJmZyLmFsbG93VHJhaWxpbmdDb21tYXMmJkYoZSkpYnJlYWs7dCYmd3I9PT1idD9uLnB1c2gobnVsbCk6bi5wdXNoKEsoITApKX1yZXR1cm4gbn1mdW5jdGlvbiBscihlKXt2YXIgcj1xKCk7cmV0dXJuIHIubmFtZT13cj09PUZyP0NyOmUmJiFmci5mb3JiaWRSZXNlcnZlZCYmd3Iua2V5d29yZHx8WCgpLEVyPSExLFUoKSxqKHIsXCJJZGVudGlmaWVyXCIpfWUudmVyc2lvbj1cIjAuNC4wXCI7dmFyIGZyLGRyLHByLGhyO2UucGFyc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZHI9U3RyaW5nKGUpLHByPWRyLmxlbmd0aCxyKHQpLG8oKSxXKGZyLnByb2dyYW0pfTt2YXIgbXI9ZS5kZWZhdWx0T3B0aW9ucz17ZWNtYVZlcnNpb246NSxzdHJpY3RTZW1pY29sb25zOiExLGFsbG93VHJhaWxpbmdDb21tYXM6ITAsZm9yYmlkUmVzZXJ2ZWQ6ITEsbG9jYXRpb25zOiExLG9uQ29tbWVudDpudWxsLHJhbmdlczohMSxwcm9ncmFtOm51bGwsc291cmNlRmlsZTpudWxsfSx2cj1lLmdldExpbmVJbmZvPWZ1bmN0aW9uKGUscil7Zm9yKHZhciB0PTEsbj0wOzspe0t0Lmxhc3RJbmRleD1uO3ZhciBhPUt0LmV4ZWMoZSk7aWYoIShhJiZhLmluZGV4PHIpKWJyZWFrOysrdCxuPWEuaW5kZXgrYVswXS5sZW5ndGh9cmV0dXJue2xpbmU6dCxjb2x1bW46ci1ufX07ZS50b2tlbml6ZT1mdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGcoZSksYS5zdGFydD15cixhLmVuZD1ncixhLnN0YXJ0TG9jPXhyLGEuZW5kTG9jPWtyLGEudHlwZT13cixhLnZhbHVlPUNyLGF9ZHI9U3RyaW5nKGUpLHByPWRyLmxlbmd0aCxyKHQpLG8oKTt2YXIgYT17fTtyZXR1cm4gbi5qdW1wVG89ZnVuY3Rpb24oZSxyKXtpZihicj1lLGZyLmxvY2F0aW9ucyl7QXI9MSxTcj1LdC5sYXN0SW5kZXg9MDtmb3IodmFyIHQ7KHQ9S3QuZXhlYyhkcikpJiZ0LmluZGV4PGU7KSsrQXIsU3I9dC5pbmRleCt0WzBdLmxlbmd0aH1Fcj1yLHUoKX0sbn07dmFyIGJyLHlyLGdyLHhyLGtyLHdyLENyLEVyLEFyLFNyLElyLExyLFVyLFJyLFZyLFRyLHFyPVtdLE9yPXt0eXBlOlwibnVtXCJ9LGpyPXt0eXBlOlwicmVnZXhwXCJ9LERyPXt0eXBlOlwic3RyaW5nXCJ9LEZyPXt0eXBlOlwibmFtZVwifSxCcj17dHlwZTpcImVvZlwifSxNcj17a2V5d29yZDpcImJyZWFrXCJ9LHpyPXtrZXl3b3JkOlwiY2FzZVwiLGJlZm9yZUV4cHI6ITB9LFhyPXtrZXl3b3JkOlwiY2F0Y2hcIn0sTnI9e2tleXdvcmQ6XCJjb250aW51ZVwifSxXcj17a2V5d29yZDpcImRlYnVnZ2VyXCJ9LEpyPXtrZXl3b3JkOlwiZGVmYXVsdFwifSxQcj17a2V5d29yZDpcImRvXCIsaXNMb29wOiEwfSxIcj17a2V5d29yZDpcImVsc2VcIixiZWZvcmVFeHByOiEwfSwkcj17a2V5d29yZDpcImZpbmFsbHlcIn0sX3I9e2tleXdvcmQ6XCJmb3JcIixpc0xvb3A6ITB9LEdyPXtrZXl3b3JkOlwiZnVuY3Rpb25cIn0sS3I9e2tleXdvcmQ6XCJpZlwifSxRcj17a2V5d29yZDpcInJldHVyblwiLGJlZm9yZUV4cHI6ITB9LFlyPXtrZXl3b3JkOlwic3dpdGNoXCJ9LFpyPXtrZXl3b3JkOlwidGhyb3dcIixiZWZvcmVFeHByOiEwfSxldD17a2V5d29yZDpcInRyeVwifSxydD17a2V5d29yZDpcInZhclwifSx0dD17a2V5d29yZDpcIndoaWxlXCIsaXNMb29wOiEwfSxudD17a2V5d29yZDpcIndpdGhcIn0sYXQ9e2tleXdvcmQ6XCJuZXdcIixiZWZvcmVFeHByOiEwfSxvdD17a2V5d29yZDpcInRoaXNcIn0saXQ9e2tleXdvcmQ6XCJudWxsXCIsYXRvbVZhbHVlOm51bGx9LHN0PXtrZXl3b3JkOlwidHJ1ZVwiLGF0b21WYWx1ZTohMH0sY3Q9e2tleXdvcmQ6XCJmYWxzZVwiLGF0b21WYWx1ZTohMX0sdXQ9e2tleXdvcmQ6XCJpblwiLGJpbm9wOjcsYmVmb3JlRXhwcjohMH0sbHQ9e1wiYnJlYWtcIjpNcixcImNhc2VcIjp6cixcImNhdGNoXCI6WHIsXCJjb250aW51ZVwiOk5yLFwiZGVidWdnZXJcIjpXcixcImRlZmF1bHRcIjpKcixcImRvXCI6UHIsXCJlbHNlXCI6SHIsXCJmaW5hbGx5XCI6JHIsXCJmb3JcIjpfcixcImZ1bmN0aW9uXCI6R3IsXCJpZlwiOktyLFwicmV0dXJuXCI6UXIsXCJzd2l0Y2hcIjpZcixcInRocm93XCI6WnIsXCJ0cnlcIjpldCxcInZhclwiOnJ0LFwid2hpbGVcIjp0dCxcIndpdGhcIjpudCxcIm51bGxcIjppdCxcInRydWVcIjpzdCxcImZhbHNlXCI6Y3QsXCJuZXdcIjphdCxcImluXCI6dXQsXCJpbnN0YW5jZW9mXCI6e2tleXdvcmQ6XCJpbnN0YW5jZW9mXCIsYmlub3A6NyxiZWZvcmVFeHByOiEwfSxcInRoaXNcIjpvdCxcInR5cGVvZlwiOntrZXl3b3JkOlwidHlwZW9mXCIscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9LFwidm9pZFwiOntrZXl3b3JkOlwidm9pZFwiLHByZWZpeDohMCxiZWZvcmVFeHByOiEwfSxcImRlbGV0ZVwiOntrZXl3b3JkOlwiZGVsZXRlXCIscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9fSxmdD17dHlwZTpcIltcIixiZWZvcmVFeHByOiEwfSxkdD17dHlwZTpcIl1cIn0scHQ9e3R5cGU6XCJ7XCIsYmVmb3JlRXhwcjohMH0saHQ9e3R5cGU6XCJ9XCJ9LG10PXt0eXBlOlwiKFwiLGJlZm9yZUV4cHI6ITB9LHZ0PXt0eXBlOlwiKVwifSxidD17dHlwZTpcIixcIixiZWZvcmVFeHByOiEwfSx5dD17dHlwZTpcIjtcIixiZWZvcmVFeHByOiEwfSxndD17dHlwZTpcIjpcIixiZWZvcmVFeHByOiEwfSx4dD17dHlwZTpcIi5cIn0sa3Q9e3R5cGU6XCI/XCIsYmVmb3JlRXhwcjohMH0sd3Q9e2Jpbm9wOjEwLGJlZm9yZUV4cHI6ITB9LEN0PXtpc0Fzc2lnbjohMCxiZWZvcmVFeHByOiEwfSxFdD17aXNBc3NpZ246ITAsYmVmb3JlRXhwcjohMH0sQXQ9e2Jpbm9wOjkscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9LFN0PXtwb3N0Zml4OiEwLHByZWZpeDohMCxpc1VwZGF0ZTohMH0sSXQ9e3ByZWZpeDohMCxiZWZvcmVFeHByOiEwfSxMdD17Ymlub3A6MSxiZWZvcmVFeHByOiEwfSxVdD17Ymlub3A6MixiZWZvcmVFeHByOiEwfSxSdD17Ymlub3A6MyxiZWZvcmVFeHByOiEwfSxWdD17Ymlub3A6NCxiZWZvcmVFeHByOiEwfSxUdD17Ymlub3A6NSxiZWZvcmVFeHByOiEwfSxxdD17Ymlub3A6NixiZWZvcmVFeHByOiEwfSxPdD17Ymlub3A6NyxiZWZvcmVFeHByOiEwfSxqdD17Ymlub3A6OCxiZWZvcmVFeHByOiEwfSxEdD17Ymlub3A6MTAsYmVmb3JlRXhwcjohMH07ZS50b2tUeXBlcz17YnJhY2tldEw6ZnQsYnJhY2tldFI6ZHQsYnJhY2VMOnB0LGJyYWNlUjpodCxwYXJlbkw6bXQscGFyZW5SOnZ0LGNvbW1hOmJ0LHNlbWk6eXQsY29sb246Z3QsZG90Onh0LHF1ZXN0aW9uOmt0LHNsYXNoOnd0LGVxOkN0LG5hbWU6RnIsZW9mOkJyLG51bTpPcixyZWdleHA6anIsc3RyaW5nOkRyfTtmb3IodmFyIEZ0IGluIGx0KWUudG9rVHlwZXNbXCJfXCIrRnRdPWx0W0Z0XTt2YXIgQnQsTXQ9bihcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIiksenQ9bihcImNsYXNzIGVudW0gZXh0ZW5kcyBzdXBlciBjb25zdCBleHBvcnQgaW1wb3J0XCIpLFh0PW4oXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIpLE50PW4oXCJldmFsIGFyZ3VtZW50c1wiKSxXdD1uKFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCIpLEp0PS9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS8sUHQ9XCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiLEh0PVwiXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDYyMC1cXHUwNjQ5XFx1MDY3Mi1cXHUwNmQzXFx1MDZlNy1cXHUwNmU4XFx1MDZmYi1cXHUwNmZjXFx1MDczMC1cXHUwNzRhXFx1MDgwMC1cXHUwODE0XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg0MC1cXHUwODU3XFx1MDhlNC1cXHUwOGZlXFx1MDkwMC1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2Mi1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDlkN1xcdTA5ZGYtXFx1MDllMFxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTItXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI1Zi1cXHUwYjYwXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAxLVxcdTBjMDNcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjItXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMi1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMlxcdTBkMDNcXHUwZDQ2LVxcdTBkNDhcXHUwZDU3XFx1MGQ2Mi1cXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUzNC1cXHUwZTNhXFx1MGU0MC1cXHUwZTQ1XFx1MGU1MC1cXHUwZTU5XFx1MGViNC1cXHUwZWI5XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjQxLVxcdTBmNDdcXHUwZjcxLVxcdTBmODRcXHUwZjg2LVxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAwMC1cXHUxMDI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTcwZS1cXHUxNzEwXFx1MTcyMC1cXHUxNzMwXFx1MTc0MC1cXHUxNzUwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3YjJcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk1MS1cXHUxOTZkXFx1MTliMC1cXHUxOWMwXFx1MTljOC1cXHUxOWM5XFx1MTlkMC1cXHUxOWQ5XFx1MWEwMC1cXHUxYTE1XFx1MWEyMC1cXHUxYTUzXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWI0Ni1cXHUxYjRiXFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMwMC1cXHUxYzIyXFx1MWM0MC1cXHUxYzQ5XFx1MWM1Yi1cXHUxYzdkXFx1MWNkMC1cXHUxY2QyXFx1MWQwMC1cXHUxZGJlXFx1MWUwMS1cXHUxZjE1XFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmQ4MS1cXHUyZDk2XFx1MmRlMC1cXHUyZGZmXFx1MzAyMS1cXHUzMDI4XFx1MzA5OVxcdTMwOWFcXHVhNjQwLVxcdWE2NmRcXHVhNjc0LVxcdWE2N2RcXHVhNjlmXFx1YTZmMC1cXHVhNmYxXFx1YTdmOC1cXHVhODAwXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwLVxcdWE4ODFcXHVhOGI0LVxcdWE4YzRcXHVhOGQwLVxcdWE4ZDlcXHVhOGYzLVxcdWE4ZjdcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTMwLVxcdWE5NDVcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhYTAwLVxcdWFhMjdcXHVhYTQwLVxcdWFhNDFcXHVhYTRjLVxcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiXFx1YWFlMC1cXHVhYWU5XFx1YWFmMi1cXHVhYWYzXFx1YWJjMC1cXHVhYmUxXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjIwLVxcdWZiMjhcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIiwkdD1uZXcgUmVnRXhwKFwiW1wiK1B0K1wiXVwiKSxfdD1uZXcgUmVnRXhwKFwiW1wiK1B0K0h0K1wiXVwiKSxHdD0vW1xcblxcclxcdTIwMjhcXHUyMDI5XS8sS3Q9L1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldL2csUXQ9ZS5pc0lkZW50aWZpZXJTdGFydD1mdW5jdGlvbihlKXtyZXR1cm4gNjU+ZT8zNj09PWU6OTE+ZT8hMDo5Nz5lPzk1PT09ZToxMjM+ZT8hMDplPj0xNzAmJiR0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShlKSl9LFl0PWUuaXNJZGVudGlmaWVyQ2hhcj1mdW5jdGlvbihlKXtyZXR1cm4gNDg+ZT8zNj09PWU6NTg+ZT8hMDo2NT5lPyExOjkxPmU/ITA6OTc+ZT85NT09PWU6MTIzPmU/ITA6ZT49MTcwJiZfdC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpfSxadD17a2luZDpcImxvb3BcIn0sZW49e2tpbmQ6XCJzd2l0Y2hcIn19KTtcblxuXHR2YXIgYmluYXJ5T3BlcmF0b3JzID0ge1xuXHRcdCcrJzogJ19fYWRkJyxcblx0XHQnLSc6ICdfX3N1YnRyYWN0Jyxcblx0XHQnKic6ICdfX211bHRpcGx5Jyxcblx0XHQnLyc6ICdfX2RpdmlkZScsXG5cdFx0JyUnOiAnX19tb2R1bG8nLFxuXHRcdCc9PSc6ICdlcXVhbHMnLFxuXHRcdCchPSc6ICdlcXVhbHMnXG5cdH07XG5cblx0dmFyIHVuYXJ5T3BlcmF0b3JzID0ge1xuXHRcdCctJzogJ19fbmVnYXRlJyxcblx0XHQnKyc6IG51bGxcblx0fTtcblxuXHR2YXIgZmllbGRzID0gQmFzZS5lYWNoKFxuXHRcdFsnYWRkJywgJ3N1YnRyYWN0JywgJ211bHRpcGx5JywgJ2RpdmlkZScsICdtb2R1bG8nLCAnbmVnYXRlJ10sXG5cdFx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dGhpc1snX18nICsgbmFtZV0gPSAnIycgKyBuYW1lO1xuXHRcdH0sXG5cdFx0e31cblx0KTtcblx0UG9pbnQuaW5qZWN0KGZpZWxkcyk7XG5cdFNpemUuaW5qZWN0KGZpZWxkcyk7XG5cdENvbG9yLmluamVjdChmaWVsZHMpO1xuXG5cdGZ1bmN0aW9uIF9fJF9fKGxlZnQsIG9wZXJhdG9yLCByaWdodCkge1xuXHRcdHZhciBoYW5kbGVyID0gYmluYXJ5T3BlcmF0b3JzW29wZXJhdG9yXTtcblx0XHRpZiAobGVmdCAmJiBsZWZ0W2hhbmRsZXJdKSB7XG5cdFx0XHR2YXIgcmVzID0gbGVmdFtoYW5kbGVyXShyaWdodCk7XG5cdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09ICchPScgPyAhcmVzIDogcmVzO1xuXHRcdH1cblx0XHRzd2l0Y2ggKG9wZXJhdG9yKSB7XG5cdFx0Y2FzZSAnKyc6IHJldHVybiBsZWZ0ICsgcmlnaHQ7XG5cdFx0Y2FzZSAnLSc6IHJldHVybiBsZWZ0IC0gcmlnaHQ7XG5cdFx0Y2FzZSAnKic6IHJldHVybiBsZWZ0ICogcmlnaHQ7XG5cdFx0Y2FzZSAnLyc6IHJldHVybiBsZWZ0IC8gcmlnaHQ7XG5cdFx0Y2FzZSAnJSc6IHJldHVybiBsZWZ0ICUgcmlnaHQ7XG5cdFx0Y2FzZSAnPT0nOiByZXR1cm4gbGVmdCA9PSByaWdodDtcblx0XHRjYXNlICchPSc6IHJldHVybiBsZWZ0ICE9IHJpZ2h0O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uICRfXyhvcGVyYXRvciwgdmFsdWUpIHtcblx0XHR2YXIgaGFuZGxlciA9IHVuYXJ5T3BlcmF0b3JzW29wZXJhdG9yXTtcblx0XHRpZiAoaGFuZGxlciAmJiB2YWx1ZSAmJiB2YWx1ZVtoYW5kbGVyXSlcblx0XHRcdHJldHVybiB2YWx1ZVtoYW5kbGVyXSgpO1xuXHRcdHN3aXRjaCAob3BlcmF0b3IpIHtcblx0XHRjYXNlICcrJzogcmV0dXJuICt2YWx1ZTtcblx0XHRjYXNlICctJzogcmV0dXJuIC12YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIHNjb3BlLmFjb3JuLnBhcnNlKGNvZGUsIG9wdGlvbnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tcGlsZShjb2RlLCB1cmwsIG9wdGlvbnMpIHtcblx0XHRpZiAoIWNvZGUpXG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0dXJsID0gdXJsIHx8ICcnO1xuXG5cdFx0dmFyIGluc2VydGlvbnMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGdldE9mZnNldChvZmZzZXQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaW5zZXJ0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGluc2VydGlvbiA9IGluc2VydGlvbnNbaV07XG5cdFx0XHRcdGlmIChpbnNlcnRpb25bMF0gPj0gb2Zmc2V0KVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRvZmZzZXQgKz0gaW5zZXJ0aW9uWzFdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDb2RlKG5vZGUpIHtcblx0XHRcdHJldHVybiBjb2RlLnN1YnN0cmluZyhnZXRPZmZzZXQobm9kZS5yYW5nZVswXSksXG5cdFx0XHRcdFx0Z2V0T2Zmc2V0KG5vZGUucmFuZ2VbMV0pKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRCZXR3ZWVuKGxlZnQsIHJpZ2h0KSB7XG5cdFx0XHRyZXR1cm4gY29kZS5zdWJzdHJpbmcoZ2V0T2Zmc2V0KGxlZnQucmFuZ2VbMV0pLFxuXHRcdFx0XHRcdGdldE9mZnNldChyaWdodC5yYW5nZVswXSkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlcGxhY2VDb2RlKG5vZGUsIHN0cikge1xuXHRcdFx0dmFyIHN0YXJ0ID0gZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMF0pLFxuXHRcdFx0XHRlbmQgPSBnZXRPZmZzZXQobm9kZS5yYW5nZVsxXSksXG5cdFx0XHRcdGluc2VydCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5zZXJ0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoc3RhcnQgPiBpbnNlcnRpb25zW2ldWzBdKSB7XG5cdFx0XHRcdFx0aW5zZXJ0ID0gaSArIDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGluc2VydGlvbnMuc3BsaWNlKGluc2VydCwgMCwgW3N0YXJ0LCBzdHIubGVuZ3RoIC0gZW5kICsgc3RhcnRdKTtcblx0XHRcdGNvZGUgPSBjb2RlLnN1YnN0cmluZygwLCBzdGFydCkgKyBzdHIgKyBjb2RlLnN1YnN0cmluZyhlbmQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdhbGtBU1Qobm9kZSwgcGFyZW50KSB7XG5cdFx0XHRpZiAoIW5vZGUpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGZvciAodmFyIGtleSBpbiBub2RlKSB7XG5cdFx0XHRcdGlmIChrZXkgPT09ICdyYW5nZScgfHwga2V5ID09PSAnbG9jJylcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0dmFyIHZhbHVlID0gbm9kZVtrZXldO1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRcdHdhbGtBU1QodmFsdWVbaV0sIG5vZGUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR3YWxrQVNUKHZhbHVlLCBub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c3dpdGNoIChub2RlLnR5cGUpIHtcblx0XHRcdGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG5cdFx0XHRcdGlmIChub2RlLm9wZXJhdG9yIGluIHVuYXJ5T3BlcmF0b3JzXG5cdFx0XHRcdFx0XHQmJiBub2RlLmFyZ3VtZW50LnR5cGUgIT09ICdMaXRlcmFsJykge1xuXHRcdFx0XHRcdHZhciBhcmcgPSBnZXRDb2RlKG5vZGUuYXJndW1lbnQpO1xuXHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsICckX18oXCInICsgbm9kZS5vcGVyYXRvciArICdcIiwgJ1xuXHRcdFx0XHRcdFx0XHQrIGFyZyArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcblx0XHRcdFx0aWYgKG5vZGUub3BlcmF0b3IgaW4gYmluYXJ5T3BlcmF0b3JzXG5cdFx0XHRcdFx0XHQmJiBub2RlLmxlZnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0dmFyIGxlZnQgPSBnZXRDb2RlKG5vZGUubGVmdCksXG5cdFx0XHRcdFx0XHRyaWdodCA9IGdldENvZGUobm9kZS5yaWdodCksXG5cdFx0XHRcdFx0XHRiZXR3ZWVuID0gZ2V0QmV0d2Vlbihub2RlLmxlZnQsIG5vZGUucmlnaHQpLFxuXHRcdFx0XHRcdFx0b3BlcmF0b3IgPSBub2RlLm9wZXJhdG9yO1xuXHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsICdfXyRfXygnICsgbGVmdCArICcsJ1xuXHRcdFx0XHRcdFx0XHQrIGJldHdlZW4ucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcJyArIG9wZXJhdG9yKSxcblx0XHRcdFx0XHRcdFx0XHQnXCInICsgb3BlcmF0b3IgKyAnXCInKVxuXHRcdFx0XHRcdFx0XHQrICcsICcgKyByaWdodCArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcblx0XHRcdGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcblx0XHRcdFx0dmFyIHBhcmVudFR5cGUgPSBwYXJlbnQgJiYgcGFyZW50LnR5cGU7XG5cdFx0XHRcdGlmICghKFxuXHRcdFx0XHRcdFx0cGFyZW50VHlwZSA9PT0gJ0ZvclN0YXRlbWVudCdcblx0XHRcdFx0XHRcdHx8IHBhcmVudFR5cGUgPT09ICdCaW5hcnlFeHByZXNzaW9uJ1xuXHRcdFx0XHRcdFx0XHQmJiAvXls9ITw+XS8udGVzdChwYXJlbnQub3BlcmF0b3IpXG5cdFx0XHRcdFx0XHR8fCBwYXJlbnRUeXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiYgcGFyZW50LmNvbXB1dGVkXG5cdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRpZiAobm9kZS50eXBlID09PSAnVXBkYXRlRXhwcmVzc2lvbicpIHtcblx0XHRcdFx0XHRcdHZhciBhcmcgPSBnZXRDb2RlKG5vZGUuYXJndW1lbnQpLFxuXHRcdFx0XHRcdFx0XHRleHAgPSAnX18kX18oJyArIGFyZyArICcsIFwiJyArIG5vZGUub3BlcmF0b3JbMF1cblx0XHRcdFx0XHRcdFx0XHRcdCsgJ1wiLCAxKScsXG5cdFx0XHRcdFx0XHRcdHN0ciA9IGFyZyArICcgPSAnICsgZXhwO1xuXHRcdFx0XHRcdFx0aWYgKCFub2RlLnByZWZpeFxuXHRcdFx0XHRcdFx0XHRcdCYmIChwYXJlbnRUeXBlID09PSAnQXNzaWdubWVudEV4cHJlc3Npb24nXG5cdFx0XHRcdFx0XHRcdFx0XHR8fCBwYXJlbnRUeXBlID09PSAnVmFyaWFibGVEZWNsYXJhdG9yJykpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGdldENvZGUocGFyZW50LmxlZnQgfHwgcGFyZW50LmlkKSA9PT0gYXJnKVxuXHRcdFx0XHRcdFx0XHRcdHN0ciA9IGV4cDtcblx0XHRcdFx0XHRcdFx0c3RyID0gYXJnICsgJzsgJyArIHN0cjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsIHN0cik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICgvXi49JC8udGVzdChub2RlLm9wZXJhdG9yKVxuXHRcdFx0XHRcdFx0XHRcdCYmIG5vZGUubGVmdC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGxlZnQgPSBnZXRDb2RlKG5vZGUubGVmdCksXG5cdFx0XHRcdFx0XHRcdFx0cmlnaHQgPSBnZXRDb2RlKG5vZGUucmlnaHQpO1xuXHRcdFx0XHRcdFx0XHRyZXBsYWNlQ29kZShub2RlLCBsZWZ0ICsgJyA9IF9fJF9fKCcgKyBsZWZ0ICsgJywgXCInXG5cdFx0XHRcdFx0XHRcdFx0XHQrIG5vZGUub3BlcmF0b3JbMF0gKyAnXCIsICcgKyByaWdodCArICcpJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgc291cmNlTWFwID0gbnVsbCxcblx0XHRcdGJyb3dzZXIgPSBwYXBlci5icm93c2VyLFxuXHRcdFx0dmVyc2lvbiA9IGJyb3dzZXIudmVyc2lvbk51bWJlcixcblx0XHRcdGxpbmVCcmVha3MgPSAvXFxyXFxufFxcbnxcXHIvbWc7XG5cdFx0aWYgKGJyb3dzZXIuY2hyb21lICYmIHZlcnNpb24gPj0gMzBcblx0XHRcdFx0fHwgYnJvd3Nlci53ZWJraXQgJiYgdmVyc2lvbiA+PSA1MzcuNzZcblx0XHRcdFx0fHwgYnJvd3Nlci5maXJlZm94ICYmIHZlcnNpb24gPj0gMjMpIHtcblx0XHRcdHZhciBvZmZzZXQgPSAwO1xuXHRcdFx0aWYgKHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YodXJsKSA9PT0gMCkge1xuXHRcdFx0XHR2YXIgaHRtbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0uaW5uZXJIVE1MO1xuXHRcdFx0XHRvZmZzZXQgPSBodG1sLnN1YnN0cigwLCBodG1sLmluZGV4T2YoY29kZSkgKyAxKS5tYXRjaChcblx0XHRcdFx0XHRcdGxpbmVCcmVha3MpLmxlbmd0aCArIDE7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbWFwcGluZ3MgPSBbJ0FBQUEnXTtcblx0XHRcdG1hcHBpbmdzLmxlbmd0aCA9IChjb2RlLm1hdGNoKGxpbmVCcmVha3MpIHx8IFtdKS5sZW5ndGggKyAxICsgb2Zmc2V0O1xuXHRcdFx0c291cmNlTWFwID0ge1xuXHRcdFx0XHR2ZXJzaW9uOiAzLFxuXHRcdFx0XHRmaWxlOiB1cmwsXG5cdFx0XHRcdG5hbWVzOltdLFxuXHRcdFx0XHRtYXBwaW5nczogbWFwcGluZ3Muam9pbignO0FBQ0EnKSxcblx0XHRcdFx0c291cmNlUm9vdDogJycsXG5cdFx0XHRcdHNvdXJjZXM6IFt1cmxdXG5cdFx0XHR9O1xuXHRcdFx0dmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlIHx8ICF1cmwgJiYgY29kZTtcblx0XHRcdGlmIChzb3VyY2UpXG5cdFx0XHRcdHNvdXJjZU1hcC5zb3VyY2VzQ29udGVudCA9IFtzb3VyY2VdO1xuXHRcdH1cblx0XHR3YWxrQVNUKHBhcnNlKGNvZGUsIHsgcmFuZ2VzOiB0cnVlIH0pKTtcblx0XHRpZiAoc291cmNlTWFwKSB7XG5cdFx0XHRjb2RlID0gbmV3IEFycmF5KG9mZnNldCArIDEpLmpvaW4oJ1xcbicpICsgY29kZVxuXHRcdFx0XHRcdCsgXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiXG5cdFx0XHRcdFx0KyAoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoXG5cdFx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpKVxuXHRcdFx0XHRcdCsgXCJcXG4vLyMgc291cmNlVVJMPVwiICsgKHVybCB8fCAncGFwZXJzY3JpcHQnKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBleGVjdXRlKGNvZGUsIHNjb3BlLCB1cmwsIG9wdGlvbnMpIHtcblx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdHZhciB2aWV3ID0gc2NvcGUuZ2V0VmlldygpLFxuXHRcdFx0dG9vbCA9IC9cXHMrb24oPzpLZXl8TW91c2UpKD86VXB8RG93bnxNb3ZlfERyYWcpXFxiLy50ZXN0KGNvZGUpXG5cdFx0XHRcdFx0PyBuZXcgVG9vbCgpXG5cdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0dG9vbEhhbmRsZXJzID0gdG9vbCA/IHRvb2wuX2V2ZW50cyA6IFtdLFxuXHRcdFx0aGFuZGxlcnMgPSBbJ29uRnJhbWUnLCAnb25SZXNpemUnXS5jb25jYXQodG9vbEhhbmRsZXJzKSxcblx0XHRcdHBhcmFtcyA9IFtdLFxuXHRcdFx0YXJncyA9IFtdLFxuXHRcdFx0ZnVuYztcblx0XHRjb2RlID0gY29tcGlsZShjb2RlLCB1cmwsIG9wdGlvbnMpO1xuXHRcdGZ1bmN0aW9uIGV4cG9zZShzY29wZSwgaGlkZGVuKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gc2NvcGUpIHtcblx0XHRcdFx0aWYgKChoaWRkZW4gfHwgIS9eXy8udGVzdChrZXkpKSAmJiBuZXcgUmVnRXhwKCcoW1xcXFxiXFxcXHNcXFxcV118XiknXG5cdFx0XHRcdFx0XHQrIGtleS5yZXBsYWNlKC9cXCQvZywgJ1xcXFwkJykgKyAnXFxcXGInKS50ZXN0KGNvZGUpKSB7XG5cdFx0XHRcdFx0cGFyYW1zLnB1c2goa2V5KTtcblx0XHRcdFx0XHRhcmdzLnB1c2goc2NvcGVba2V5XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXhwb3NlKHsgX18kX186IF9fJF9fLCAkX186ICRfXywgcGFwZXI6IHNjb3BlLCB2aWV3OiB2aWV3LCB0b29sOiB0b29sIH0sXG5cdFx0XHRcdHRydWUpO1xuXHRcdGV4cG9zZShzY29wZSk7XG5cdFx0aGFuZGxlcnMgPSBCYXNlLmVhY2goaGFuZGxlcnMsIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0aWYgKG5ldyBSZWdFeHAoJ1xcXFxzKycgKyBrZXkgKyAnXFxcXGInKS50ZXN0KGNvZGUpKSB7XG5cdFx0XHRcdHBhcmFtcy5wdXNoKGtleSk7XG5cdFx0XHRcdHRoaXMucHVzaChrZXkgKyAnOiAnICsga2V5KTtcblx0XHRcdH1cblx0XHR9LCBbXSkuam9pbignLCAnKTtcblx0XHRpZiAoaGFuZGxlcnMpXG5cdFx0XHRjb2RlICs9ICdcXG5yZXR1cm4geyAnICsgaGFuZGxlcnMgKyAnIH07Jztcblx0XHR2YXIgYnJvd3NlciA9IHBhcGVyLmJyb3dzZXI7XG5cdFx0aWYgKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZmlyZWZveCkge1xuXHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuXHRcdFx0XHRoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuXHRcdFx0aWYgKGJyb3dzZXIuZmlyZWZveClcblx0XHRcdFx0Y29kZSA9ICdcXG4nICsgY29kZTtcblx0XHRcdHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcblx0XHRcdFx0J3BhcGVyLl9leGVjdXRlID0gZnVuY3Rpb24oJyArIHBhcmFtcyArICcpIHsnICsgY29kZSArICdcXG59J1xuXHRcdFx0KSk7XG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0XHRmdW5jID0gcGFwZXIuX2V4ZWN1dGU7XG5cdFx0XHRkZWxldGUgcGFwZXIuX2V4ZWN1dGU7XG5cdFx0XHRoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZ1bmMgPSBGdW5jdGlvbihwYXJhbXMsIGNvZGUpO1xuXHRcdH1cblx0XHR2YXIgcmVzID0gZnVuYy5hcHBseShzY29wZSwgYXJncykgfHwge307XG5cdFx0QmFzZS5lYWNoKHRvb2xIYW5kbGVycywgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgdmFsdWUgPSByZXNba2V5XTtcblx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdFx0dG9vbFtrZXldID0gdmFsdWU7XG5cdFx0fSk7XG5cdFx0aWYgKHZpZXcpIHtcblx0XHRcdGlmIChyZXMub25SZXNpemUpXG5cdFx0XHRcdHZpZXcuc2V0T25SZXNpemUocmVzLm9uUmVzaXplKTtcblx0XHRcdHZpZXcuZW1pdCgncmVzaXplJywge1xuXHRcdFx0XHRzaXplOiB2aWV3LnNpemUsXG5cdFx0XHRcdGRlbHRhOiBuZXcgUG9pbnQoKVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAocmVzLm9uRnJhbWUpXG5cdFx0XHRcdHZpZXcuc2V0T25GcmFtZShyZXMub25GcmFtZSk7XG5cdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWRTY3JpcHQoc2NyaXB0KSB7XG5cdFx0aWYgKC9edGV4dFxcLyg/OngtfClwYXBlcnNjcmlwdCQvLnRlc3Qoc2NyaXB0LnR5cGUpXG5cdFx0XHRcdCYmIFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKHNjcmlwdCwgJ2lnbm9yZScpICE9PSAndHJ1ZScpIHtcblx0XHRcdHZhciBjYW52YXNJZCA9IFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKHNjcmlwdCwgJ2NhbnZhcycpLFxuXHRcdFx0XHRjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNJZCksXG5cdFx0XHRcdHNyYyA9IHNjcmlwdC5zcmMgfHwgc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKSxcblx0XHRcdFx0YXN5bmMgPSBQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShzY3JpcHQsICdhc3luYycpLFxuXHRcdFx0XHRzY29wZUF0dHJpYnV0ZSA9ICdkYXRhLXBhcGVyLXNjb3BlJztcblx0XHRcdGlmICghY2FudmFzKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGNhbnZhcyB3aXRoIGlkIFwiJ1xuXHRcdFx0XHRcdFx0KyBjYW52YXNJZCArICdcIicpO1xuXHRcdFx0dmFyIHNjb3BlID0gUGFwZXJTY29wZS5nZXQoY2FudmFzLmdldEF0dHJpYnV0ZShzY29wZUF0dHJpYnV0ZSkpXG5cdFx0XHRcdFx0XHR8fCBuZXcgUGFwZXJTY29wZSgpLnNldHVwKGNhbnZhcyk7XG5cdFx0XHRjYW52YXMuc2V0QXR0cmlidXRlKHNjb3BlQXR0cmlidXRlLCBzY29wZS5faWQpO1xuXHRcdFx0aWYgKHNyYykge1xuXHRcdFx0XHRIdHRwLnJlcXVlc3QoJ2dldCcsIHNyYywgZnVuY3Rpb24oY29kZSkge1xuXHRcdFx0XHRcdGV4ZWN1dGUoY29kZSwgc2NvcGUsIHNyYyk7XG5cdFx0XHRcdH0sIGFzeW5jKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4ZWN1dGUoc2NyaXB0LmlubmVySFRNTCwgc2NvcGUsIHNjcmlwdC5iYXNlVVJJKTtcblx0XHRcdH1cblx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItaWdub3JlJywgJ3RydWUnKTtcblx0XHRcdHJldHVybiBzY29wZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBsb2FkQWxsKCkge1xuXHRcdEJhc2UuZWFjaChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JyksIGxvYWRTY3JpcHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZChzY3JpcHQpIHtcblx0XHRyZXR1cm4gc2NyaXB0ID8gbG9hZFNjcmlwdChzY3JpcHQpIDogbG9hZEFsbCgpO1xuXHR9XG5cblx0aWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcblx0XHRzZXRUaW1lb3V0KGxvYWRBbGwpO1xuXHR9IGVsc2Uge1xuXHRcdERvbUV2ZW50LmFkZCh3aW5kb3csIHsgbG9hZDogbG9hZEFsbCB9KTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Y29tcGlsZTogY29tcGlsZSxcblx0XHRleGVjdXRlOiBleGVjdXRlLFxuXHRcdGxvYWQ6IGxvYWQsXG5cdFx0cGFyc2U6IHBhcnNlXG5cdH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbnBhcGVyID0gbmV3IChQYXBlclNjb3BlLmluamVjdChCYXNlLmV4cG9ydHMsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0QmFzZTogQmFzZSxcblx0TnVtZXJpY2FsOiBOdW1lcmljYWwsXG5cdEtleTogS2V5XG59KSkoKTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRkZWZpbmUoJ3BhcGVyJywgcGFwZXIpO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBwYXBlcjtcbn1cblxucmV0dXJuIHBhcGVyO1xufTtcbiIsIkF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dFxuXG5tb2R1bGUuZXhwb3J0cyA9XG4gIEF1ZGlvQ29udGV4dDogbmV3IEF1ZGlvQ29udGV4dCgpIiwiUHJvbWlzZSA9IChyZXF1aXJlICdlczYtcHJvbWlzZScpLlByb21pc2VcblxuY2xhc3MgRGlzcGF0Y2hlclxuICBjb25zdHJ1Y3RvcjogKCkgLT5cbiAgICBAZGVsZWdhdGVzID0gW11cblxuICByZWdpc3RlcjogKGRlbGVnYXRlKSAtPlxuICAgIEBkZWxlZ2F0ZXMucHVzaCBkZWxlZ2F0ZVxuXG4gIGRpc3BhdGNoOiAocGF5bG9hZCkgLT5cbiAgICBfcmVzb2x2ZXMgPSBbXVxuICAgIF9yZWplY3RzID0gW11cbiAgICBfcHJvbWlzZXMgPSBAZGVsZWdhdGVzXG4gICAgICAubWFwIChkLCBpZHgpIC0+XG4gICAgICAgIG5ldyBQcm9taXNlIChyZXNvbHZlLCByZWplY3QpIC0+XG4gICAgICAgICAgX3Jlc29sdmVzW2lkeF0gPSByZXNvbHZlXG4gICAgICAgICAgX3JlamVjdHNbaWR4XSA9IHJlamVjdFxuXG4gICAgQGRlbGVnYXRlc1xuICAgICAgLmZvckVhY2ggKGRlbGVnYXRlLCBpZHgpIC0+XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSAoZGVsZWdhdGUgcGF5bG9hZClcbiAgICAgICAgICAudGhlbiBcXFxuICAgICAgICAgICAgKCgpIC0+IF9yZXNvbHZlc1tpXSBwYXlsb2FkKSxcbiAgICAgICAgICAgICgoKSAtPiBfcmVqZWN0c1tpXSAobmV3IEVycm9yICdEaXNwYXRjaGVyIGNhbGxiYWNrIHVuc3VjY2Vzc2Z1bCcpKVxuXG4gICAgX3Byb21pc2VzID0gW11cblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBEaXNwYXRjaGVyKCkiLCJfID0gcmVxdWlyZSAnbG9kYXNoJ1xuayA9IHJlcXVpcmUgJy4uL0NvbnN0YW50cydcblxuR3JhbnVsYXJTeW50aCA9IHJlcXVpcmUgJy4vZ3JhbnVsYXInXG5TeW50aFN0b3JlID0gcmVxdWlyZSAnLi4vc3RvcmVzL1N5bnRocydcblxuY2xhc3MgU3ludGhQb29sXG4gIGNvbnN0cnVjdG9yOiAob3B0aW9ucyA9IHt9KSAtPlxuICAgIFN5bnRoU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIgKCkgPT5cbiAgICAgIEB1cGRhdGUgU3ludGhTdG9yZS5nZXRBbGwoKVxuXG4gICAgQG9wdGlvbnMgPSBfLmRlZmF1bHRzIG9wdGlvbnMsXG4gICAgICB2b2ljZXM6IDRcblxuICAgIEB2b2ljZXMgPSBbMC4uLkBvcHRpb25zLnZvaWNlc10ubWFwIChpZHgpID0+XG4gICAgICBzeW50aDogbmV3IEdyYW51bGFyU3ludGggay5BdWRpb0NvbnRleHRcbiAgICAgICMgZW50aXR5OiBudWxsXG4gICAgICBnYWluOiBrLkF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKClcbiAgICAgIGluZGV4OiBpZHhcbiAgICAgIGlkOiBudWxsXG4gICAgICBwcmlvcml0eTogLTFcbiAgICAgIGJ1c3k6ICgpIC0+IEBpZD9cblxuICAgIEBvdXRwdXQgPSBrLkF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKClcblxuICAgIEB2b2ljZXNcbiAgICAgIC5mb3JFYWNoICh2b2ljZSkgPT5cbiAgICAgICAgdm9pY2Uuc3ludGgub3V0cHV0LmNvbm5lY3Qgdm9pY2UuZ2FpblxuICAgICAgICB2b2ljZS5nYWluLmNvbm5lY3QgQG91dHB1dFxuXG4gICAgQHVwZGF0ZSBTeW50aFN0b3JlLmdldEFsbCgpXG5cbiAgdXBkYXRlOiAoc3RhdGUpIC0+XG4gICAgQG91dHB1dC5nYWluLnZhbHVlID1cbiAgICAgIHN0YXRlLm1hc3Rlci52b2x1bWUgKiAoaWYgc3RhdGUubWFzdGVyLmlzTXV0ZWQgdGhlbiAwIGVsc2UgMSlcblxuICAgIF8gc3RhdGUuc3ludGhzXG4gICAgICAudGFrZSBAb3B0aW9ucy52b2ljZXNcbiAgICAgIC52YWx1ZSgpXG4gICAgICAuZm9yRWFjaCAoc3ludGgpID0+XG4gICAgICAgIHYgPSBfLmZpbmQgQHZvaWNlcywgKHZvaWNlKSAtPlxuICAgICAgICAgIHZvaWNlLmlkIGlzIHN5bnRoLmlkXG4gICAgICAgIGlmIHY/XG4gICAgICAgICAgQF91cGRhdGVWb2ljZSB2LCBzeW50aFxuICAgICAgICBlbHNlXG4gICAgICAgICAgQHB1c2hTeW50aCBzeW50aCwgc3ludGgubGV2ZWxcblxuICBwdXNoU3ludGg6IChzeW50aCwgcHJpb3JpdHkpIC0+XG4gICAgYm90dG9tID0gKF8uc29ydEJ5IEB2b2ljZXMsICdwcmlvcml0eScpWzBdXG4gICAgaWYgYm90dG9tLnByaW9yaXR5IDwgcHJpb3JpdHlcbiAgICAgIEB2b2ljZXNbYm90dG9tLmluZGV4XSA9IF8uYXNzaWduIGJvdHRvbSxcbiAgICAgICAgaWQ6IHN5bnRoLmlkXG4gICAgICAgIHByaW9yaXR5OiBwcmlvcml0eVxuICAgICAgQHZvaWNlc1tib3R0b20uaW5kZXhdLnN5bnRoLnNldCBzeW50aC5vcHRpb25zXG5cbiAgICAgICMgZGVidWdcbiAgICAgIEBub3RlT24gYm90dG9tLmluZGV4LCAxXG4gICAgZWxzZVxuICAgICAgY29uc29sZS5sb2cgJ25vdCBoaWdoIGVub3VnaCBwcmlvcml0eSdcblxuICBzZXQ6ICh2b2ljZUlkeCwgdm9pY2VPcHRpb25zID0ge30sIHN5bnRoT3B0aW9ucyA9IHt9KSAtPlxuICAgIGlmIEB2b2ljZXNbdm9pY2VJZHhdP1xuICAgICAgQF9zZXRWb2ljZSBAdm9pY2VzW3ZvaWNlSWR4XSwgdm9pY2VPcHRpb25zLCBzeW50aE9wdGlvbnNcblxuXG4gIHByaW9yaXRpemU6IChwcmlvcml0eSwgc3ludGgpIC0+XG4gICAgaW5Qb29sID0gKEB2b2ljZXMuZmlsdGVyICh2KSAtPiB2LmlkIGlzIHN5bnRoLmlkKVswXVxuICAgIGlmIGluUG9vbD9cbiAgICAgIHJldHVybiBpblBvb2wucHJpb3JpdHkgPSBwcmlvcml0eVxuICAgIGVsc2VcbiAgICAgIGJvdHRvbSA9IChfLnNvcnRCeSBAdm9pY2VzLCAncHJpb3JpdHknKVswXVxuICAgICAgdm9pY2VPcHRpb25zID1cbiAgICAgICAgaWQ6IHN5bnRoLmlkXG4gICAgICAgIHByaW9yaXR5OiBwcmlvcml0eVxuICAgICAgQF9zZXRWb2ljZSBib3R0b20sIHZvaWNlT3B0aW9ucywgc3ludGgub3B0aW9uc1xuXG5cbiAgc2V0R2FpbjogKGdhaW4sIHN5bnRoKSAtPlxuICAgIHZvaWNlID0gbnVsbFxuICAgIGZvciB2IGluIEB2b2ljZXNcbiAgICAgIGlmIHYuaWQgaXMgc3ludGguaWRcbiAgICAgICAgdm9pY2UgPSB2XG4gICAgICAgIGJyZWFrXG4gICAgaWYgdm9pY2U/XG4gICAgICB2b2ljZS5nYWluLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUgXFxcbiAgICAgICAgZ2FpbixcbiAgICAgICAgay5BdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyAwLjAxNlxuICAgIGVsc2VcbiAgICAgIGNvbnNvbGUubG9nIFwiY291bGRuJ3QgZmluZCB2b2ljZVwiXG5cbiAgbm90ZU9uOiAodm9pY2VJZHgsIHZlbG9jaXR5KSAtPlxuICAgIEB2b2ljZXNbdm9pY2VJZHhdPy5zeW50aD8ubm90ZU9uIHZlbG9jaXR5XG5cbiAgX3VwZGF0ZVZvaWNlOiAodm9pY2UsIHN5bnRoKSAtPlxuICAgIHZvaWNlLnN5bnRoLnNldCBzeW50aC5vcHRpb25zXG4gICAgdm9pY2UuZ2Fpbi5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lIFxcXG4gICAgICAgIHN5bnRoLmxldmVsLFxuICAgICAgICBrLkF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIDAuMDE2XG5cbiAgX3NldFZvaWNlOiAodm9pY2UsIHZvaWNlT3B0aW9ucywgc3ludGhPcHRpb25zKSAtPlxuICAgIF8uYXNzaWduIHZvaWNlLCB2b2ljZU9wdGlvbnNcbiAgICB2b2ljZS5zeW50aC5zZXQgc3ludGhPcHRpb25zXG4gICAgIyB2b2ljZS5zeW50aC5vcHRpb25zID0gc3ludGhPcHRpb25zXG5cbiAgICAjIGRlYnVnXG4gICAgQG5vdGVPbiB2b2ljZS5pbmRleCwgMVxuXG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhQb29sIiwiXyA9IHJlcXVpcmUgJ2xvZGFzaCdcbkV2ZW50VGFyZ2V0ID0gcmVxdWlyZSAnb28tZXZlbnR0YXJnZXQnXG5cbm1zMnMgPSAobXMpIC0+IG1zIC8gMTAwMC4wXG5cbmNsYXNzIEVudmVsb3BlXG4gIGNvbnN0cnVjdG9yOiAoQGF1ZGlvQ29udGV4dCwgZW52ZWxvcGUgPSB7fSkgLT5cbiAgICBFdmVudFRhcmdldCB0aGlzXG4gICAgQGVudmVsb3BlID0gXy5kZWZhdWx0cyBlbnZlbG9wZSxcbiAgICAgIGF0dGFjazogMTAwXG4gICAgICByZWxlYXNlOiAxMDAwXG4gICAgQGdhaW5Ob2RlID0gQGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKClcblxuICAgICMgY29udmVuaWVuY2UgcHJvcGVydHkgZm9yIEF1ZGlvQ29udGV4dC5jdXJyZW50VGltZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGlzLCAnX25vdycsXG4gICAgICBnZXQ6ICgpIC0+IEBhdWRpb0NvbnRleHQuY3VycmVudFRpbWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGlzLCAnaW5wdXQnLFxuICAgICAgZ2V0OiAoKSAtPiBAZ2Fpbk5vZGVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGlzLCAnb3V0cHV0JyxcbiAgICAgIGdldDogKCkgLT4gQGdhaW5Ob2RlXG5cbiAgc2V0RW52ZWxvcGU6IChlbnZlbG9wZSkgLT5cbiAgICBfLmFzc2lnbiBAZW52ZWxvcGUsIGVudmVsb3BlXG5cbiAgbm90ZU9uOiAodmVsb2NpdHkpIC0+XG4gICAgQF9yZXNldCgpXG4gICAgQF9hdHRhY2soKVxuXG4gIG5vdGVPZmY6ICgpIC0+XG4gICAgQF9yZWxlYXNlKClcblxuICBfYXR0YWNrOiAoKSA9PlxuICAgIEBnYWluTm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lIDAuMCwgQF9ub3dcbiAgICBAZ2Fpbk5vZGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSAxLjAsIEBfbm93ICsgbXMycyBAZW52ZWxvcGUuYXR0YWNrXG5cbiAgX3JlbGVhc2U6ICgpID0+XG4gICAgQGdhaW5Ob2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUgMC4wLCBAX25vdyArIG1zMnMgQGVudmVsb3BlLnJlbGVhc2VcbiAgICBAX3JlbGVhc2VUaW1lb3V0ID0gc2V0VGltZW91dCAoQF93aWxsRmlyZSAncmVsZWFzZWQnKSwgQGVudmVsb3BlLnJlbGVhc2VcblxuICBfcmVzZXQ6ICgpIC0+XG4gICAgaWYgQF9yZWxlYXNlVGltZW91dD9cbiAgICAgIGNsZWFyVGltZW91dCBAX3JlbGVhc2VUaW1lb3V0XG4gICAgICBAX3JlbGVhc2VUaW1lb3V0ID0gbnVsbFxuICAgIEBnYWluTm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyBAX25vd1xuXG4gIF93aWxsRmlyZTogKGV2ZW50TmFtZSwgZGV0YWlsID0ge30pIC0+ICgpID0+XG4gICAgQGRpc3BhdGNoRXZlbnQgZXZlbnROYW1lLCBkZXRhaWxcblxuXG5jbGFzcyBUcmlnZ2VyRW52ZWxvcGUgZXh0ZW5kcyBFbnZlbG9wZVxuICBjb25zdHJ1Y3RvcjogKEBhdWRpb0NvbnRleHQsIGVudmVsb3BlID0ge30pIC0+XG4gICAgc3VwZXIgQGF1ZGlvQ29udGV4dCwgZW52ZWxvcGVcblxuICAgIEBlbnZlbG9wZSA9IF8uZGVmYXVsdHMgQGVudmVsb3BlLFxuICAgICAgaG9sZDogMTAwMFxuXG4gIHNldEhvbGREdXJhdGlvbjogKGR1cmF0aW9uKSAtPlxuICAgIEBlbnZlbG9wZS5ob2xkID0gZHVyYXRpb25cblxuICBub3RlT246ICh2ZWxvY2l0eSkgLT5cbiAgICBzdXBlciB2ZWxvY2l0eVxuXG4gICAgQF9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQgQF9yZWxlYXNlLCBAZW52ZWxvcGUuaG9sZCArIEBlbnZlbG9wZS5hdHRhY2tcblxuICBfcmVzZXQ6ICgpIC0+XG4gICAgc3VwZXIoKVxuXG4gICAgaWYgQF9ob2xkVGltZW91dD9cbiAgICAgIGNsZWFyVGltZW91dCBAX2hvbGRUaW1lb3V0XG4gICAgICBAX2hvbGRUaW1lb3V0ID0gbnVsbFxuXG5cblxuICBub3RlT2ZmOiAoKSAtPlxuICAgICMgZG8gbm90aGluZ1xuXG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9XG4gIEVudmVsb3BlOiBFbnZlbG9wZVxuICBUcmlnZ2VyRW52ZWxvcGU6IFRyaWdnZXJFbnZlbG9wZSIsIl8gPSByZXF1aXJlICdsb2Rhc2gnXG5yZXF1aXJlICdvYmplY3Qub2JzZXJ2ZSdcblxuVGltZW91dE1hbmFnZXIgPSByZXF1aXJlICcuLi91dGlsL1RpbWVvdXRNYW5hZ2VyJ1xuXG5TYW1wbGVyID0gcmVxdWlyZSAnLi9zYW1wbGVyJ1xue0VudmVsb3BlLCBUcmlnZ2VyRW52ZWxvcGV9ID0gcmVxdWlyZSAnLi9lbnZlbG9wZSdcblxubXMycyA9IChtcykgLT4gbXMgLyAxMDAwLjBcbnMybXMgPSAocykgLT4gcyAqIDEwMDAuMFxuXG5jbGFzcyBHcmFudWxhclZvaWNlXG4gIGNvbnN0cnVjdG9yOiAoQGF1ZGlvQ29udGV4dCwgb3B0aW9ucyA9IHt9KSAtPlxuICAgIEBvcHRpb25zID0gXy5kZWZhdWx0cyBvcHRpb25zLFxuICAgICAgYnVmZmVyOiBudWxsXG4gICAgICBjZW50ZXI6IDAuNSAjIHJlbGF0aXZlIHRvIGJ1ZmZlciBkdXJhdGlvblxuICAgICAgZ3JhaW5EdXJhdGlvbjogMzAwXG4gICAgICBkdXJhdGlvblJhbmRvbTogMTUwXG4gICAgICBkZXZpYXRpb246IDE1MFxuICAgICAgZ2FpbjogMC43XG4gICAgICBmYWRlUmF0aW86IDAuMSAjIHJlbGF0aXZlIHRvIGdyYWluIGR1cmF0aW9uXG4gICAgICBkZXR1bmU6IDBcblxuICAgIEBzYW1wbGVyID0gbmV3IFNhbXBsZXIgQGF1ZGlvQ29udGV4dCwgQG9wdGlvbnMuYnVmZmVyXG4gICAgQGVudmVsb3BlID0gbmV3IFRyaWdnZXJFbnZlbG9wZSBAYXVkaW9Db250ZXh0XG5cbiAgICBAc2FtcGxlci5vdXRwdXQuY29ubmVjdCBAZW52ZWxvcGUuaW5wdXRcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGlzLCAnb3V0cHV0JyxcbiAgICAgIGdldDogKCkgLT4gQGVudmVsb3BlLm91dHB1dFxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoaXMsICdidWZmZXJEdXJhdGlvbicsXG4gICAgICBnZXQ6ICgpIC0+IHMybXMgQG9wdGlvbnMuYnVmZmVyLmR1cmF0aW9uXG5cbiAgc2V0OiAob3B0aW9ucyA9IHt9KSAtPlxuICAgIGlmIG9wdGlvbnMuYnVmZmVyPyBhbmQgb3B0aW9ucy5idWZmZXIgaXNudCBAc2FtcGxlci5idWZmZXJcbiAgICAgIEBub3RlT2ZmKClcbiAgICAgIEBzYW1wbGVyLm5vdGVPZmYoKVxuICAgICAgQHNhbXBsZXIub3V0cHV0LmRpc2Nvbm5lY3QoKVxuICAgICAgQHNhbXBsZXIgPSBuZXcgU2FtcGxlciBAYXVkaW9Db250ZXh0LCBAb3B0aW9ucy5idWZmZXJcbiAgICAgIEBzYW1wbGVyLm91dHB1dC5jb25uZWN0IEBlbnZlbG9wZS5pbnB1dFxuICAgICAgIyBAbm90ZU9uIDFcblxuICAgIEBvcHRpb25zID0gXy5hc3NpZ24gQG9wdGlvbnMsIG9wdGlvbnNcblxuXG4gICMgc2V0QnVmZmVyOiAoQGJ1ZmZlcikgLT5cbiAgIyAgIEBub3RlT2ZmKClcblxuICAjICAgQHNhbXBsZXIubm90ZU9mZigpXG4gICMgICBAc2FtcGxlci5vdXRwdXQuZGlzY29ubmVjdCgpXG5cbiAgIyAgIEBzYW1wbGVyID0gbmV3IFNhbXBsZXIgQGF1ZGlvQ29udGV4dCwgQGJ1ZmZlclxuICAjICAgQHNhbXBsZXIub3V0cHV0LmNvbm5lY3QgQGVudmVsb3BlLmlucHV0XG5cbiAgbm90ZU9uOiAodmVsb2NpdHkpIC0+XG4gICAgcmVzdGFydCA9IEBfd2lsbFRyaWdnZXJHcmFpbiB2ZWxvY2l0eVxuICAgIEBlbnZlbG9wZS5hZGRFdmVudExpc3RlbmVyICdyZWxlYXNlZCcsIHJlc3RhcnRcblxuICAgIEBfdW5zdWJSZWxlYXNlID0gKCkgPT5cbiAgICAgIEBlbnZlbG9wZS5yZW1vdmVFdmVudExpc3RlbmVyICdyZWxlYXNlZCcsIHJlc3RhcnRcblxuICAgIGRvIHJlc3RhcnRcblxuXG4gIG5vdGVPZmY6ICgpIC0+XG4gICAgaWYgQF91bnN1YlJlbGVhc2U/XG4gICAgICBAX3Vuc3ViUmVsZWFzZSgpXG4gICAgICBAX3Vuc3ViUmVsZWFzZSA9IG51bGxcblxuICAgIEBzYW1wbGVyLm5vdGVPZmYoKVxuICAgIEBlbnZlbG9wZS5ub3RlT2ZmKClcblxuXG4gIF93aWxsVHJpZ2dlckdyYWluOiAodmVsb2NpdHkpIC0+ICgpID0+XG4gICAge29mZnNldCwgZHVyYXRpb259ID0gQF9waWNrR3JhaW4oKVxuXG4gICAgZmFkZVRpbWUgPSBAb3B0aW9ucy5mYWRlUmF0aW8gKiBkdXJhdGlvblxuICAgIEBlbnZlbG9wZS5zZXRFbnZlbG9wZVxuICAgICAgYXR0YWNrOiBmYWRlVGltZVxuICAgICAgaG9sZDogZHVyYXRpb24gLSBmYWRlVGltZSAqIDJcbiAgICAgIHJlbGVhc2U6IGZhZGVUaW1lXG5cbiAgICBAc2FtcGxlci5zZXRPZmZzZXQgb2Zmc2V0XG4gICAgQHNhbXBsZXIuZGV0dW5lIEBvcHRpb25zLmRldHVuZVxuXG4gICAgQHNhbXBsZXIubm90ZU9uIHZlbG9jaXR5XG4gICAgQGVudmVsb3BlLm5vdGVPbiB2ZWxvY2l0eVxuXG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgICBkdXJhdGlvbjogZHVyYXRpb25cblxuXG4gIF9waWNrR3JhaW46ICgpIC0+XG4gICAgaWYgQG9wdGlvbnMuYnVmZmVyP1xuICAgICAgZGV2aWF0aW9uID0gTWF0aC5yYW5kb20oKSAqIEBvcHRpb25zLmRldmlhdGlvblxuICAgICAgZHVyYXRpb24gPSBAb3B0aW9ucy5ncmFpbkR1cmF0aW9uXG4gICAgICBkdXJhdGlvblJhbmRvbSA9IE1hdGgucmFuZG9tKCkgKiBAb3B0aW9ucy5kdXJhdGlvblJhbmRvbVxuICAgICAgZHVyYXRpb24gKz0gZHVyYXRpb25SYW5kb21cblxuICAgICAgb2Zmc2V0OiBAb3B0aW9ucy5jZW50ZXIgKiBAYnVmZmVyRHVyYXRpb24gLSAoZHVyYXRpb24gLyAyKSArIGRldmlhdGlvblxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uXG4gICAgZWxzZVxuICAgICAgb2Zmc2V0OiAwXG4gICAgICBkdXJhdGlvbjogMFxuXG5cblxuY2xhc3MgR3JhbnVsYXJTeW50aFxuICBjb25zdHJ1Y3RvcjogKEBhdWRpb0NvbnRleHQsIG9wdGlvbnMgPSB7fSkgLT5cbiAgICBAb3B0aW9ucyA9IF8uZGVmYXVsdHNEZWVwIG9wdGlvbnMsXG4gICAgICB2b2ljZXM6IDNcbiAgICAgIGdyYW51bGFyOlxuICAgICAgICBidWZmZXI6IG51bGxcbiAgICAgICAgY2VudGVyOiAwLjVcbiAgICAgICAgZ3JhaW5EdXJhdGlvbjogMzAwXG4gICAgICAgIGR1cmF0aW9uUmFuZG9tOiAxNTBcbiAgICAgICAgZGV2aWF0aW9uOiAxNTBcbiAgICAgICAgZmFkZVJhdGlvOiAwLjI1XG4gICAgICAgIGdhaW46IGlmIG9wdGlvbnMudm9pY2VzPyB0aGVuICgxIC8gb3B0aW9ucy52b2ljZXMpIGVsc2UgMS8zXG4gICAgICAgIGRldHVuZTogMFxuXG4gICAgQGVudmVsb3BlID0gbmV3IEVudmVsb3BlIEBhdWRpb0NvbnRleHQsXG4gICAgICBhdHRhY2s6IDBcbiAgICAgIHJlbGVhc2U6IDBcblxuICAgIEB2b2ljZXMgPSBbMC4uLkBvcHRpb25zLnZvaWNlc10ubWFwICgpID0+IEBfbWFrZVZvaWNlKClcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGlzLCAnb3V0cHV0JyxcbiAgICAgIGdldDogKCkgLT4gQGVudmVsb3BlLm91dHB1dFxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoaXMsICdidWZmZXJEdXJhdGlvbicsXG4gICAgICBnZXQ6ICgpIC0+IHMybXMgQG9wdGlvbnMuZ3JhbnVsYXIuYnVmZmVyPy5kdXJhdGlvblxuXG4gIG5vdGVPbjogKHZlbG9jaXR5KSAtPlxuICAgIHZvaWNlQW1wID0gMS4wIC8gQHZvaWNlcy5sZW5ndGhcbiAgICBmcmVlVm9pY2VzID0gQHZvaWNlcy5zbGljZSgpXG5cbiAgICBhdHRlbXB0VHJpZ2dlclZvaWNlID0gKCkgPT5cbiAgICAgIGhkID0gZnJlZVZvaWNlcy5zaGlmdCgpXG4gICAgICBpZiBoZD9cbiAgICAgICAgZnJlZU1lID0gKCkgLT5cbiAgICAgICAgICBoZC5lbnZlbG9wZS5yZW1vdmVFdmVudExpc3RlbmVyICdyZWxlYXNlZCcsIGZyZWVNZVxuICAgICAgICAgIGZyZWVWb2ljZXMucHVzaCBoZFxuICAgICAgICBoZC5lbnZlbG9wZS5hZGRFdmVudExpc3RlbmVyICdyZWxlYXNlZCcsIGZyZWVNZVxuICAgICAgICByZXR1cm4gKGRvIGhkLl93aWxsVHJpZ2dlckdyYWluIHZvaWNlQW1wKS5kdXJhdGlvblxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gLTFcblxuICAgIHRyaWdnZXJBbmRXYWl0ID0gKCkgPT5cbiAgICAgIGR1cmF0aW9uID0gZG8gYXR0ZW1wdFRyaWdnZXJWb2ljZVxuICAgICAgd2FpdFRpbE5leHQgPVxuICAgICAgICBpZiBkdXJhdGlvbiBpcyAtMVxuICAgICAgICB0aGVuIEBvcHRpb25zLmdyYWluRHVyYXRpb24gLyBAdm9pY2VzLmxlbmd0aFxuICAgICAgICBlbHNlIGR1cmF0aW9uIC8gQHZvaWNlcy5sZW5ndGhcbiAgICAgIEBfbm90ZVRpbWVvdXQgPSBzZXRUaW1lb3V0IHRyaWdnZXJBbmRXYWl0LCB3YWl0VGlsTmV4dFxuICAgIHRyaWdnZXJBbmRXYWl0KClcbiAgICBAZW52ZWxvcGUubm90ZU9uIHZlbG9jaXR5XG5cbiAgbm90ZU9mZjogKCkgLT5cbiAgICBpZiBAX25vdGVUaW1lb3V0XG4gICAgICBjbGVhclRpbWVvdXQgQF9ub3RlVGltZW91dFxuXG4gICAgQHZvaWNlcy5mb3JFYWNoICh2b2ljZSkgLT4gdm9pY2Uubm90ZU9mZigpXG4gICAgQGVudmVsb3BlLm5vdGVPZmYoKVxuXG4gIHBhcmFtZXRlcnM6ICgpIC0+XG4gICAgY2VudGVyOlxuICAgICAgaWQ6ICdjZW50ZXInXG4gICAgICBkaXNwbGF5OiAnY2VudGVyJ1xuICAgICAgcmFuZ2U6IFswLCAxXVxuICAgICAgbWFwVmFsdWU6ICh2YWwpID0+XG4gICAgICAgIEBvcHRpb25zLmdyYW51bGFyLmNlbnRlciA9IHZhbFxuICAgIGdyYWluRHVyYXRpb246XG4gICAgICBpZDogJ2dyYWluRHVyYXRpb24nXG4gICAgICBkaXNwbGF5OiAnZ3JhaW4gZHVyYXRpb24nXG4gICAgICByYW5nZTogWzAsIDFdXG4gICAgICBtYXBWYWx1ZTogKHZhbCkgPT5cbiAgICAgICAgQG9wdGlvbnMuZ3JhbnVsYXIuZ3JhaW5EdXJhdGlvbiA9IHZhbFxuICAgIGR1cmF0aW9uUmFuZG9tOlxuICAgICAgaWQ6ICdkdXJhdGlvblJhbmRvbSdcbiAgICAgIGRpc3BsYXk6ICdkdXJhdGlvbiByYW5kb20nXG4gICAgICByYW5nZTogWzAsIDFdXG4gICAgICBtYXBWYWx1ZTogKHZhbCkgPT5cbiAgICAgICAgQG9wdGlvbnMuZ3JhbnVsYXIuZHVyYXRpb25SYW5kb20gPSB2YWxcbiAgICBkZXZpYXRpb246XG4gICAgICBpZDogJ2RldmlhdGlvbidcbiAgICAgIGRpc3BsYXk6ICdvZmZzZXQgZGV2aWF0aW9uJ1xuICAgICAgcmFuZ2U6IFswLCAxXVxuICAgICAgbWFwVmFsdWU6ICh2YWwpID0+XG4gICAgICAgIEBvcHRpb25zLmdyYW51bGFyLmRldmlhdGlvbiA9IHZhbFxuICAgIGZhZGVSYXRpbzpcbiAgICAgIGlkOiAnZmFkZVJhdGlvJ1xuICAgICAgZGlzcGxheTogJ2ZhZGUgcmF0aW8nXG4gICAgICByYW5nZTogWzAsIDFdXG4gICAgICBtYXBWYWx1ZTogKHZhbCkgPT5cbiAgICAgICAgQG9wdGlvbnMuZ3JhbnVsYXIuZmFkZVJhdGlvID0gdmFsXG4gICAgZGV0dW5lOlxuICAgICAgaWQ6ICdkZXR1bmUnXG4gICAgICBkaXNwbGF5OiAnZGV0dW5lIChjZW50cyknXG4gICAgICByYW5nZTogWy0xMjAwLCAxMjAwXVxuICAgICAgbWFwVmFsdWU6ICh2YWwpID0+XG4gICAgICAgIEBvcHRpb25zLmdyYW51bGFyLmRldHVuZSA9IHZhbFxuXG4gIHBhcmFtZXRlckxpc3Q6ICgpIC0+XG4gICAgXy52YWx1ZXMgQHBhcmFtZXRlcnMoKVxuXG4gIHNldDogKG9wdGlvbnMpIC0+XG4gICAgaWYgb3B0aW9ucy52b2ljZXM/XG4gICAgICB3aGlsZSBAdm9pY2VzLmxlbmd0aCBpc250IG9wdGlvbnMudm9pY2VzXG4gICAgICAgIGlmIEB2b2ljZXMubGVuZ3RoID4gb3B0aW9ucy52b2ljZXNcbiAgICAgICAgICBAdm9pY2VzW0B2b2ljZXMubGVuZ3RoIC0gMV0ubm90ZU9mZigpXG4gICAgICAgICAgQHZvaWNlcy5zcGxpY2UgKEB2b2ljZXMubGVuZ3RoIC0gMSksIDFcbiAgICAgICAgZWxzZSBpZiBAdm9pY2VzLmxlbmd0aCA8IG9wdGlvbnMudm9pY2VzXG4gICAgICAgICAgQHZvaWNlcy5wdXNoIEBfbWFrZVZvaWNlKClcblxuXG4gICAgQG9wdGlvbnMgPSBfLmFzc2lnbiBAb3B0aW9ucywgb3B0aW9uc1xuICAgIGdyYW51bGFyT3B0aW9ucyA9IF8uYXNzaWduIEBvcHRpb25zLmdyYW51bGFyLCBvcHRpb25zLmdyYW51bGFyXG4gICAgQG9wdGlvbnMuZ3JhbnVsYXIgPSBncmFudWxhck9wdGlvbnNcbiAgICBAdm9pY2VzLmZvckVhY2ggKHZvaWNlKSA9PiB2b2ljZS5zZXQgb3B0aW9ucy5ncmFudWxhclxuXG4gIF9tYWtlVm9pY2U6ICgpIC0+XG4gICAgcyA9IG5ldyBHcmFudWxhclZvaWNlIEBhdWRpb0NvbnRleHQsIEBvcHRpb25zLmdyYW51bGFyXG4gICAgcy5vdXRwdXQuY29ubmVjdCBAZW52ZWxvcGUuaW5wdXRcbiAgICByZXR1cm4gc1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYW51bGFyU3ludGgiLCJfID0gcmVxdWlyZSAnbG9kYXNoJ1xuRXZlbnRUYXJnZXQgPSByZXF1aXJlICdvby1ldmVudHRhcmdldCdcblxubXMycyA9IChtcykgLT4gbXMgLyAxMDAwLjBcbnMybXMgPSAocykgLT4gcyAqIDEwMDAuMFxuXG5jbGFzcyBTYW1wbGVyXG4gIEBfX2luc3RhbmNlQ291bnQ6IDBcblxuICBjb25zdHJ1Y3RvcjogKEBjb250ZXh0LCBAYnVmZmVyLCBAb2Zmc2V0ID0gMCkgLT5cbiAgICBFdmVudFRhcmdldCB0aGlzXG4gICAgQGlkID0gU2FtcGxlci5fX2luc3RhbmNlQ291bnQrK1xuICAgIEB2ZWxvY2l0eU5vZGUgPSBAY29udGV4dC5jcmVhdGVHYWluKClcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGlzLCAnb3V0cHV0JyxcbiAgICAgIGdldDogKCkgLT4gQHZlbG9jaXR5Tm9kZVxuXG4gIG5vdGVPbjogKHZlbG9jaXR5KSAtPlxuICAgIGlmIEBub2RlP1xuICAgICAgQG5vZGUuc3RvcCgpXG4gICAgICBAbm9kZSA9IG51bGxcblxuICAgIEB2ZWxvY2l0eU5vZGUuZ2Fpbi52YWx1ZSA9IE1hdGgubWF4IChNYXRoLm1pbiAxLCB2ZWxvY2l0eSksIDBcblxuICAgIGlmIEBidWZmZXI/XG4gICAgICBAbm9kZSA9IEBfbWFrZU5vZGUgQGJ1ZmZlclxuICAgICAgQG5vZGUuZGV0dW5lLnNldFZhbHVlQXRUaW1lIEBkZXR1bmVBbW91bnQsIEBjb250ZXh0LmN1cnJlbnRUaW1lXG4gICAgICBAbm9kZS5zdGFydCAwLCBtczJzIEBvZmZzZXRcbiAgICAgIEBub2RlLmNvbm5lY3QgQHZlbG9jaXR5Tm9kZVxuXG4gIG5vdGVPZmY6ICgpIC0+XG4gICAgIyBkbyBub3RoaW5nXG5cbiAgc2V0T2Zmc2V0OiAob2Zmc2V0KSAtPlxuICAgIEBvZmZzZXQgPSBNYXRoLm1heCAwLCBvZmZzZXRcblxuICBkZXR1bmU6IChAZGV0dW5lQW1vdW50KSAtPlxuXG4gIF9tYWtlTm9kZTogKGJ1ZmZlcikgLT5cbiAgICBpZiBAbm9kZT9cbiAgICAgIEBub2RlLmRpc2Nvbm5lY3QoKVxuXG4gICAgbm9kZSA9IEBjb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpXG4gICAgbm9kZS5idWZmZXIgPSBidWZmZXJcbiAgICAjIG5vZGUuY29ubmVjdCBAZ2Fpbk5vZGVcbiAgICByZXR1cm4gbm9kZVxuXG5cbm1vZHVsZS5leHBvcnRzID0gU2FtcGxlciIsIl8gPSByZXF1aXJlICdsb2Rhc2gnXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuXG4jIFNhbXBsZXIgPSByZXF1aXJlICcuL2F1ZGlvL3NhbXBsZXInXG4jIHtFbnZlbG9wZSwgVHJpZ2dlckVudmVsb3BlfSA9IHJlcXVpcmUgJy4vYXVkaW8vZW52ZWxvcGUnXG4jIEdyYW51bGFyU3ludGggPSByZXF1aXJlICcuL2F1ZGlvL2dyYW51bGFyJ1xuXG5BcHBsaWNhdGlvbiA9IHJlcXVpcmUgJy4vdmlldy9BcHBsaWNhdGlvbidcblN5bnRoUG9vbCA9IHJlcXVpcmUgJy4vYXVkaW8vU3ludGhQb29sJ1xuXG5rID0gcmVxdWlyZSAnLi9Db25zdGFudHMnXG5cbmRpc3BhdGNoZXIgPSByZXF1aXJlICcuL0Rpc3BhdGNoZXInXG5cbnJlcXVpcmUgJy4vc3RvcmVzL1dvcmxkJ1xucmVxdWlyZSAnLi9zdG9yZXMvU3ludGhzJ1xucmVxdWlyZSAnLi9zdG9yZXMvVXNlcidcblxuIyBhdWRpb0N0eCA9IG5ldyAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSgpXG5cbiMgb3B0czEgPVxuIyAgIHZvaWNlczogOFxuIyAgIGdyYW51bGFyOlxuIyAgICAgYnVmZmVyOiBudWxsXG4jICAgICBncmFpbkR1cmF0aW9uOiAwLjFcbiMgICAgIGRldmlhdGlvbjogMC4xXG4jICAgICBmYWRlUmF0aW86IDAuM1xuIyBzeW50aCA9IG5ldyBHcmFudWxhclN5bnRoIGF1ZGlvQ3R4XG4jIHN5bnRoLm91dHB1dC5jb25uZWN0IGF1ZGlvQ3R4LmRlc3RpbmF0aW9uXG4jIHN5bnRoLm5vdGVPbiAxXG5cbiMgdXJsID0gJy4vZGlzdC9zb3VuZHMvcmhvZGVzLndhdidcblxuIyByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiMgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpXG4jIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ1xuXG4jIHJlcXVlc3Qub25sb2FkID0gKCkgLT5cbiMgICBhdWRpb0N0eC5kZWNvZGVBdWRpb0RhdGEgcmVxdWVzdC5yZXNwb25zZSwgKGJ1ZmZlcikgLT5cbiMgICAgIG9wdHMuZ3JhbnVsYXIuYnVmZmVyID0gYnVmZmVyXG4jICAgICBzeW50aC5zZXQgb3B0c1xuIyAgICAgc3ludGgubm90ZU9uIDFcbiMgICAgIGNvbnNvbGUubG9nIHN5bnRoXG5cbiMgcmVxdWVzdC5zZW5kKClcblxuIyBsb2FkU291bmRCdWZmZXIgPSAoZGF0YSkgLT5cbiMgICBhdWRpb0N0eC5kZWNvZGVBdWRpb0RhdGEgZGF0YSwgKGJ1ZmZlcikgPT5cbiMgICAgIHN5bnRoLnNldCBidWZmZXI6IGJ1ZmZlclxuIyAgICAgc3ludGgubm90ZU9uIDFcblxuXG5zcCA9IG5ldyBTeW50aFBvb2xcbiAgdm9pY2VzOiAzXG5zcC5vdXRwdXQuY29ubmVjdCBrLkF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvblxuXG5jb250YWluZXIgPSBkb2N1bWVudC5ib2R5XG5cbiMgYmNyID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbmF1ZGlvID1cbiAgYXVkaW9Tb3VyY2U6IHNwLm91dHB1dFxuXG5pbml0aWFsUHJvcHMgPSBfLmFzc2lnbiB7fSwgYXVkaW9cblxudmlldyA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQgQXBwbGljYXRpb24sIGluaXRpYWxQcm9wc1xuUmVhY3QucmVuZGVyIHZpZXcsIGNvbnRhaW5lciIsIlBhcGVyID0gcmVxdWlyZSAncGFwZXInXG5TdG9yZSA9IHJlcXVpcmUgJy4vU3RvcmUnXG5Xb3JsZFN0b3JlID0gcmVxdWlyZSAnLi9Xb3JsZCdcbmsgPSByZXF1aXJlICcuLi9Db25zdGFudHMnXG5cbiMgZGVmaW5pdGVseSBtb3JlIG9mIGEgY29udHJvbGxlcjtcbiMgIGJ1dCBhcmVuJ3QgY29udHJvbGxlcnMganVzdCBsaWdodHdlaWdodCBzdG9yZXM/XG5jbGFzcyBFZGl0b3IgZXh0ZW5kcyBTdG9yZVxuICBnZXREZWZhdWx0RGF0YTogKCkgLT5cbiAgICBhY3RpdmVFbnRpdHlJZDogbnVsbFxuICAgIGFjdGl2ZUVudGl0eTogbnVsbFxuICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgIHF1ZXVlZEVudGl0eTogbnVsbFxuICAgIGV2ZW50czpcbiAgICAgIHdhbnRzRWRpdDogZmFsc2VcbiAgICAgIHdhbnRzQ2FuY2VsSW5zcGVjdG9yOiBmYWxzZVxuXG5cbiAgZGVsZWdhdGU6IChwYXlsb2FkKSAtPlxuICAgIGRhdGEgPSBwYXlsb2FkPy5hY3Rpb24/LmRhdGFcblxuICAgIHN3aXRjaCBwYXlsb2FkPy5hY3Rpb24/LmFjdGlvblR5cGVcbiAgICAgIHdoZW4gJ3dhbnRzRWRpdEVudGl0eSdcbiAgICAgICAge2lkfSA9IGRhdGEuaWRcbiAgICAgICAgZW50aXR5ID0gV29ybGRTdG9yZS5nZXRFbnRpdHkgZGF0YS5pZFxuICAgICAgICBpZiBlbnRpdHk/XG4gICAgICAgICAgQGRhdGEuZXZlbnRzLndhbnRzRWRpdCA9IHRydWVcbiAgICAgICAgICBAZGF0YS5xdWV1ZWRFbnRpdHkgPSBlbnRpdHlcbiAgICAgICAgICBAZW1pdENoYW5nZSgpXG5cbiAgICAgIHdoZW4gJ2RpZEJlZ2luRWRpdEVudGl0eSdcbiAgICAgICAge2VudGl0eX0gPSBkYXRhXG4gICAgICAgIEBkYXRhLmV2ZW50cy53YW50c0VkaXQgPSBmYWxzZVxuICAgICAgICBAZGF0YS5hY3RpdmVFbnRpdHkgPSBlbnRpdHlcbiAgICAgICAgQGRhdGEuaXNBY3RpdmUgPSB0cnVlXG4gICAgICAgIEBlbWl0Q2hhbmdlKClcblxuICAgICAgd2hlbiAnd2FudHNDYW5jZWxFZGl0RW50aXR5J1xuICAgICAgICBAZGF0YS5ldmVudHMud2FudHNDYW5jZWwgPSB0cnVlXG4gICAgICAgIEBlbWl0Q2hhbmdlKClcblxuICAgICAgd2hlbiAnZGlkQ2FuY2VsRWRpdEVudGl0eSdcbiAgICAgICAgQGRhdGEuZXZlbnRzLndhbnRzQ2FuY2VsID0gZmFsc2VcbiAgICAgICAgQGRhdGEuaXNBY3RpdmUgPSBmYWxzZVxuICAgICAgICBAZW1pdENoYW5nZSgpXG5cblxuXG4gIHNldEVkaXRFbnRpdHk6IChlbnRpdHlJZCkgLT5cbiAgICBAZGF0YS5hY3RpdmVFbnRpdHlJZCA9IGVudGl0eUlkXG4gICAgQGRhdGEuYWN0aXZlRW50aXR5ID0gV29ybGRTdG9yZS5nZXRFbnRpdHkgQGRhdGEuYWN0aXZlRW50aXR5SWRcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVkaXRvcigpIiwiXyA9IHJlcXVpcmUgJ2xvZGFzaCdcblxue0V2ZW50RW1pdHRlcn0gPSByZXF1aXJlICdldmVudHMnXG5kaXNwYXRjaGVyID0gcmVxdWlyZSAnLi4vRGlzcGF0Y2hlcidcbkRpc3BhdGNoYWJsZSA9IHJlcXVpcmUgJy4uL3V0aWwvRGlzcGF0Y2hhYmxlJ1xuXG5DSEFOR0VfRVZFTlQgPSAnY2hhbmdlJ1xuXG5jbGFzcyBTdG9yZSBleHRlbmRzIEV2ZW50RW1pdHRlclxuICBjb25zdHJ1Y3RvcjogKGluaXRpYWxEYXRhID0ge30pIC0+XG4gICAgRGlzcGF0Y2hhYmxlIHRoaXMsIGRpc3BhdGNoZXJcbiAgICBAZGF0YSA9IF8uZXh0ZW5kIEBnZXREZWZhdWx0RGF0YSgpLCBpbml0aWFsRGF0YVxuICAgIEByZWdpc3Rlck9uRGlzcGF0Y2hlcigpXG5cbiAgZ2V0RGVmYXVsdERhdGE6ICgpIC0+IHt9XG5cbiAgZ2V0QWxsOiAoKSAtPiBAZGF0YVxuXG4gIGVtaXRDaGFuZ2U6ICgpIC0+IEBlbWl0IENIQU5HRV9FVkVOVFxuXG4gIGFkZENoYW5nZUxpc3RlbmVyOiAoY2IpIC0+XG4gICAgQG9uIENIQU5HRV9FVkVOVCwgY2JcblxuICByZW1vdmVDaGFuZ2VMaXN0ZW5lcjogKGNiKSAtPlxuICAgIEByZW1vdmVMaXN0ZW5lciBDSEFOR0VfRVZFTlQsIGNiXG5cbiAgZGVsZWdhdGU6IHVuZGVmaW5lZFxuXG4gIHJlZ2lzdGVyT25EaXNwYXRjaGVyOiAoZGVsZWdhdGUpIC0+XG4gICAgaWYgQGRlbGVnYXRlP1xuICAgICAgZGlzcGF0Y2hlci5yZWdpc3RlciAoKSA9PiBAZGVsZWdhdGUgYXJndW1lbnRzLi4uXG4gICAgZWxzZVxuICAgICAgY29uc29sZS53YXJuICdObyBkZWxlZ2F0ZSBmb3IgJywgdGhpc1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3JlIiwiXyA9IHJlcXVpcmUgJ2xvZGFzaCdcblxuU3RvcmUgPSByZXF1aXJlICcuL1N0b3JlJ1xuV29ybGRTdG9yZSA9IHJlcXVpcmUgJy4vV29ybGQnXG4jIFN5bnRoUG9vbCA9IHJlcXVpcmUgJy4uL2F1ZGlvL1N5bnRoUG9vbCdcbmsgPSByZXF1aXJlICcuLi9Db25zdGFudHMnXG5cbkRFRkFVTFRfQlVGRkVSID0gbnVsbFxuZG8gLT5cbiAgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gIHJlcXVlc3Qub3BlbiAnR0VUJywgJy4vZGlzdC9zb3VuZHMvaGVuLndhdicsIHRydWVcbiAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG4gIHJlcXVlc3Qub25sb2FkID0gKCkgLT5cbiAgICBrLkF1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEgcmVxdWVzdC5yZXNwb25zZSwgKGJ1ZmZlcikgPT5cbiAgICAgIERFRkFVTFRfQlVGRkVSID0gYnVmZmVyXG4gIHJlcXVlc3Quc2VuZCgpXG5cbmNsYXNzIFN5bnRocyBleHRlbmRzIFN0b3JlXG4gIGdldERlZmF1bHREYXRhOiAoKSAtPlxuICAgIHN5bnRoczogW11cbiAgICBtYXN0ZXI6XG4gICAgICB2b2x1bWU6IDFcbiAgICAgIGlzTXV0ZWQ6IGZhbHNlXG5cbiAgZGVsZWdhdGU6IChwYXlsb2FkKSAtPlxuICAgIGRhdGEgPSBwYXlsb2FkPy5hY3Rpb24/LmRhdGFcblxuICAgIHN3aXRjaCBwYXlsb2FkPy5hY3Rpb24/LmFjdGlvblR5cGVcbiAgICAgIHdoZW4gJ2RpZE1hc3RlckNoYW5nZU11dGUnXG4gICAgICAgIHtpc011dGVkfSA9IGRhdGFcbiAgICAgICAgQGRhdGEubWFzdGVyLmlzTXV0ZWQgPSBpc011dGVkXG4gICAgICAgIEBlbWl0Q2hhbmdlKClcblxuICAgICAgd2hlbiAnZGlkQWRkRW50aXR5J1xuICAgICAgICB7ZW50aXR5fSA9IGRhdGFcbiAgICAgICAgZW50aXR5LnN5bnRoID1cbiAgICAgICAgICBpZDogZW50aXR5LmlkXG4gICAgICAgICAgbGV2ZWw6IDBcbiAgICAgICAgICBvcHRpb25zOiBAZGVmYXVsdFN5bnRoT3B0aW9ucygpXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBlbnRpdHkuc3ludGgsICduZWVkc0ZpbGUnLFxuICAgICAgICAgIGdldDogKCkgLT4gbm90IGVudGl0eS5zeW50aC5vcHRpb25zLmdyYW51bGFyLmJ1ZmZlcj9cbiAgICAgICAgQGVtaXRDaGFuZ2UoKVxuXG4gICAgICB3aGVuICd3YW50c0xvYWRTb3VuZEZpbGUnXG4gICAgICAgIHtlbnRpdHksIGZpbGV9ID0gZGF0YVxuXG4gICAgICAgIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChldnQpID0+XG4gICAgICAgICAgZGF0YSA9IGV2dC50YXJnZXQucmVzdWx0XG4gICAgICAgICAgay5BdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhIGRhdGEsIChidWZmZXIpID0+XG4gICAgICAgICAgICBAZGlzcGF0Y2ggJ2xvYWRCdWZmZXJJbnRvRW50aXR5JyxcbiAgICAgICAgICAgICAgYnVmZmVyOiBidWZmZXJcbiAgICAgICAgICAgICAgZW50aXR5OiBlbnRpdHlcblxuICAgICAgICAgIEBlbWl0Q2hhbmdlKClcbiAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyIGRhdGEuZmlsZVxuXG4gICAgICB3aGVuICdsb2FkQnVmZmVySW50b0VudGl0eSdcbiAgICAgICAge2J1ZmZlciwgZW50aXR5fSA9IGRhdGFcbiAgICAgICAgaWYgbm90IGVudGl0eS5zeW50aD9cbiAgICAgICAgICBjb25zb2xlLmxvZyAnZW50aXR5IGhhcyBubyBzeW50aCcsIGVudGl0eVxuICAgICAgICAgIGRlYnVnZ2VyXG5cbiAgICAgICAgIyBmb3IgZGVidWcgbW9zdGx5XG4gICAgICAgIGlmIG5vdCBidWZmZXI/XG4gICAgICAgICAgYnVmZmVyID0gREVGQVVMVF9CVUZGRVJcblxuICAgICAgICBAbG9hZEJ1ZmZlciBidWZmZXIsIGVudGl0eS5zeW50aFxuICAgICAgICBlbnRpdHkuc3ludGgubmVlZHNGaWxlID0gZmFsc2VcbiAgICAgICAgQGVtaXRDaGFuZ2UoKVxuXG4gICAgICB3aGVuICdkaWRVcGRhdGVOZWFyZXN0RW50aXRpZXMnXG5cbiAgICAgICAgQHNldExldmVscyBkYXRhLm1hcCAoe2VudGl0eSwgZGlzdGFuY2UsIHZpZXdEaXN0YW5jZVJhdGlvfSkgLT5cbiAgICAgICAgICBzeW50aDogZW50aXR5LnN5bnRoXG4gICAgICAgICAgbGV2ZWw6ICgwLjUgLSB2aWV3RGlzdGFuY2VSYXRpbykgKiAyLjBcbiAgICAgICAgQGVtaXRDaGFuZ2UoKVxuXG4gICAgICB3aGVuICdzZXRTeW50aFBhcmFtZXRlcidcbiAgICAgICAge3N5bnRoLCBwYXJhbWV0ZXJ9ID0gZGF0YVxuICAgICAgICBAc2V0UGFyYW1ldGVyIHBhcmFtZXRlci5uYW1lLCBwYXJhbWV0ZXIudmFsdWUsIHN5bnRoXG4gICAgICAgIEBlbWl0Q2hhbmdlKClcblxuICBkZWZhdWx0U3ludGhPcHRpb25zOiAoKSAtPlxuICAgIHZvaWNlczogOFxuICAgIGdyYW51bGFyOlxuICAgICAgYnVmZmVyOiBudWxsXG4gICAgICBjZW50ZXI6IDAuNVxuICAgICAgZ3JhaW5EdXJhdGlvbjogMTAwMFxuICAgICAgZHVyYXRpb25SYW5kb206IDIwMFxuICAgICAgZGV2aWF0aW9uOiAyMDBcbiAgICAgIGZhZGVSYXRpbzogMC41XG4gICAgICBnYWluOiAwLjI1XG4gICAgICBkZXR1bmU6IDBcblxuICBsb2FkQnVmZmVyOiAoYnVmZmVyLCBzeW50aERhdGEpIC0+XG4gICAgc3ludGhEYXRhLm9wdGlvbnMuZ3JhbnVsYXIuYnVmZmVyID0gYnVmZmVyXG5cblxuICBzZXRMZXZlbHM6IChsZXZlbHNJbmZvKSAtPlxuICAgIEBkYXRhLnN5bnRocyA9IF8gbGV2ZWxzSW5mb1xuICAgICAgLnNvcnRCeSAoYSwgYikgLT4gYS5sZXZlbCAtIGIubGV2ZWxcbiAgICAgIC5tYXAgKHtzeW50aCwgbGV2ZWx9KSAtPlxuICAgICAgICBzeW50aC5sZXZlbCA9IGxldmVsXG4gICAgICAgIHJldHVybiBzeW50aFxuICAgICAgLnZhbHVlKClcblxuICBzZXRQYXJhbWV0ZXI6IChwTmFtZSwgcFZhbHVlLCBzeW50aCkgLT5cbiAgICBpZiBzeW50aC5vcHRpb25zLmdyYW51bGFyW3BOYW1lXT9cbiAgICAgIHN5bnRoLm9wdGlvbnMuZ3JhbnVsYXJbcE5hbWVdID0gcFZhbHVlXG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU3ludGhzKCkiLCJfID0gcmVxdWlyZSAnbG9kYXNoJ1xuU3RvcmUgPSByZXF1aXJlICcuL1N0b3JlJ1xuV29ybGRTdG9yZSA9IHJlcXVpcmUgJy4vV29ybGQnXG5cbmNsYXNzIFVzZXIgZXh0ZW5kcyBTdG9yZVxuICBnZXREZWZhdWx0RGF0YTogKCkgLT5cbiAgICBwb3NpdGlvbjogbnVsbFxuICAgIGRlbHRhUG9zaXRpb246IFswLCAwXVxuXG4gIGRlbGVnYXRlOiAocGF5bG9hZCkgLT5cbiAgICBkYXRhID0gcGF5bG9hZD8uYWN0aW9uPy5kYXRhXG5cbiAgICBzd2l0Y2ggcGF5bG9hZD8uYWN0aW9uPy5hY3Rpb25UeXBlXG4gICAgICB3aGVuICd3YW50c0VkaXRFbnRpdHknXG4gICAgICAgIHtpZH0gPSBkYXRhXG4gICAgICAgIGVudGl0eSA9IFdvcmxkU3RvcmUuZ2V0RW50aXR5IGlkXG4gICAgICAgIGlmIGVudGl0eT9cbiAgICAgICAgICBAZGlzcGF0Y2ggJ2RpZEJlZ2luRWRpdEVudGl0eScsIGVudGl0eTogZW50aXR5XG4gICAgICAgICMgICBAZm9jdXNPbkl0ZW0gZW50aXR5LnBhdGgsIFswLCBlbnRpdHkucGF0aC5ib3VuZHMuaGVpZ2h0ICogMC4xXVxuICAgICAgICAjICAgICAudGhlbiAoKSA9PlxuICAgICAgICAjICAgICAgIEBkaXNwYXRjaCAnZGlkQmVnaW5FZGl0RW50aXR5JywgZW50aXR5OiBlbnRpdHlcbiAgICAgICAgIyBlbHNlXG4gICAgICAgICMgICBjb25zb2xlLmVycm9yICdlZGl0aW5nIG5vbmV4aXN0YW50IGVudGl0eScsIGlkXG5cbiAgICAgIHdoZW4gJ2RpZFZpZXdwb3J0VHJhbnNmb3JtJ1xuICAgICAgICB7dmlld3BvcnR9ID0gZGF0YVxuXG4gICAgICAgIEBkYXRhLmRlbHRhUG9zaXRpb24gPVxuICAgICAgICAgIGlmIEBkYXRhLnBvc2l0aW9uP1xuICAgICAgICAgIHRoZW4gdmlld3BvcnQuY2VudGVyLnN1YnRyYWN0IEBkYXRhLnBvc2l0aW9uXG4gICAgICAgICAgZWxzZSBbMCwgMF1cbiAgICAgICAgQGRhdGEucG9zaXRpb24gPSB2aWV3cG9ydC5jZW50ZXJcblxuICAgICAgICBAcmVjYWxjdWxhdGVEaXN0YW5jZXMgdmlld3BvcnQuY2VudGVyLCB2aWV3cG9ydC5zaXplXG4gICAgICAgIEBlbWl0Q2hhbmdlKClcblxuICAgICAgd2hlbiAnZGlkUmVnaXN0ZXJFbnRpdHknXG4gICAgICAgIHtwYXBlcjoge3Njb3BlfX0gPSBkYXRhXG4gICAgICAgIHZpZXdwb3J0ID0gc2NvcGUudmlld1xuICAgICAgICBAcmVjYWxjdWxhdGVEaXN0YW5jZXMgdmlld3BvcnQuY2VudGVyLCB2aWV3cG9ydC5zaXplXG4gICAgICAgIEBlbWl0Q2hhbmdlKClcblxuXG4gIHJlY2FsY3VsYXRlRGlzdGFuY2VzOiAoZnJvbVBvaW50LCB3aXRoaW5Cb3gpIC0+XG4gICAgIyBmb3IgcGF0aHMgb25seVxuICAgIGRpc3RhbmNlSW5mbyA9IF8gV29ybGRTdG9yZS5kYXRhLmVudGl0aWVzXG4gICAgICAudmFsdWVzKClcbiAgICAgIC5tYXAgKGVudGl0eSkgLT5cbiAgICAgICAgbmVhcmVzdFB0ID0gZW50aXR5LnBhcGVyLnBhdGguZ2V0TmVhcmVzdFBvaW50IGZyb21Qb2ludFxuXG4gICAgICAgIGRpc3RhbmNlOiBmcm9tUG9pbnQuZ2V0RGlzdGFuY2UgbmVhcmVzdFB0XG4gICAgICAgIGVudGl0eTogZW50aXR5XG4gICAgICAuZmlsdGVyIChlbG0pIC0+XG4gICAgICAgIGVsbS5kaXN0YW5jZSA8ICh3aXRoaW5Cb3gud2lkdGggLyAyKVxuICAgICAgLm1hcCAoZWxtKSAtPlxuICAgICAgICBfLmFzc2lnbiBlbG0sXG4gICAgICAgICAgdmlld0Rpc3RhbmNlUmF0aW86IGVsbS5kaXN0YW5jZSAvIHdpdGhpbkJveC53aWR0aFxuICAgICAgLnZhbHVlKClcblxuICAgIEBkaXNwYXRjaCAnZGlkVXBkYXRlTmVhcmVzdEVudGl0aWVzJywgZGlzdGFuY2VJbmZvXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFVzZXIoKSIsIl8gPSByZXF1aXJlICdsb2Rhc2gnXG5Qcm9taXNlID0gKHJlcXVpcmUgJ2VzNi1wcm9taXNlJykuUHJvbWlzZVxuU3RvcmUgPSByZXF1aXJlICcuL1N0b3JlJ1xuUGFwZXIgPSByZXF1aXJlICdwYXBlcidcblxubWFrZVJhbmRvbVBhdGggPSByZXF1aXJlICcuLi92aWV3L3BhcGVyL01ha2VSYW5kb21QYXRoJ1xuXG5jbGFzcyBXb3JsZCBleHRlbmRzIFN0b3JlXG4gIGNvbnN0cnVjdG9yOiAoKSAtPlxuICAgIHN1cGVyIGFyZ3VtZW50cy4uLlxuICAgIEBlbnRpdHlDb3VudCA9IDBcbiAgICBAX2ZpeGVkRWx0VXBkYXRlcyA9IHt9XG5cblxuICBnZXREZWZhdWx0RGF0YTogKCkgLT5cbiAgICBlbnRpdGllczoge31cbiAgICAjIHBhcGVyOlxuICAgICMgICBsYXllcnM6IHt9XG4gICAgIyAgIHNjb3BlOiBudWxsXG4gICAgcXVldWVkOlxuICAgICAgZW50aXR5OiBudWxsXG5cbiAgZ2V0RW50aXR5OiAoaWQpIC0+XG4gICAgaWYgaWQ/XG4gICAgdGhlbiBAZGF0YS5lbnRpdGllc1tpZF1cbiAgICBlbHNlIG51bGxcblxuICBkZWxlZ2F0ZTogKHBheWxvYWQpIC0+XG4gICAgZGF0YSA9IHBheWxvYWQ/LmFjdGlvbj8uZGF0YVxuXG4gICAgc3dpdGNoIHBheWxvYWQ/LmFjdGlvbj8uYWN0aW9uVHlwZVxuICAgICAgd2hlbiAnd2FudHNBZGRFbnRpdHknXG4gICAgICAgIGVudGl0eSA9IEBtYWtlTmV3RW50aXR5IGRhdGEucG9zaXRpb25cblxuICAgICAgICBAZGlzcGF0Y2ggJ3dhbnRzUmVnaXN0ZXJFbnRpdHknLFxuICAgICAgICAgIGVudGl0eTogZW50aXR5XG5cbiAgICAgICAgaWYgZGF0YS5maWxlP1xuICAgICAgICAgIEBkaXNwYXRjaCAnd2FudHNMb2FkU291bmRGaWxlJyxcbiAgICAgICAgICAgIGVudGl0eTogZW50aXR5XG4gICAgICAgICAgICBmaWxlOiBkYXRhLmZpbGVcblxuICAgICAgICAjIHRlbXBvcmFyeTogbG9hZCBkZWZhdWx0IGlmIG5vIGZpbGVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIEBkaXNwYXRjaCAnbG9hZEJ1ZmZlckludG9FbnRpdHknLFxuICAgICAgICAgICAgZW50aXR5OiBlbnRpdHlcbiAgICAgICAgICAgIGJ1ZmZlcjogbnVsbFxuXG4gICAgICB3aGVuICd3YW50c1JlZ2lzdGVyRW50aXR5J1xuICAgICAgICBAZGF0YS5xdWV1ZWQuZW50aXR5ID0gZGF0YS5lbnRpdHlcbiAgICAgICAgQGVtaXRDaGFuZ2UoKVxuXG4gICAgICB3aGVuICdkaWRSZWdpc3RlckVudGl0eSdcbiAgICAgICAge2VudGl0eSwgcGFwZXJ9ID0gZGF0YVxuICAgICAgICBAZGF0YS5xdWV1ZWQuZW50aXR5ID0gbnVsbFxuICAgICAgICBAZGF0YS5lbnRpdGllc1tlbnRpdHkuaWRdID0gZW50aXR5XG4gICAgICAgIEBkYXRhLmVudGl0aWVzW2VudGl0eS5pZF0ucGFwZXIgPSBwYXBlclxuICAgICAgICBAZGlzcGF0Y2ggJ2RpZEFkZEVudGl0eScsXG4gICAgICAgICAgZW50aXR5OiBlbnRpdHlcbiAgICAgICAgQGVtaXRDaGFuZ2UoKVxuXG4gICAgICAjIHdoZW4gJ3dhbnRzRm9jdXNPbkl0ZW0nXG4gICAgICAjICAge2l0ZW0sIG9mZnNldH0gPSBkYXRhXG4gICAgICAjICAgQGZvY3VzT25JdGVtIGl0ZW0sIG9mZnNldFxuXG5cbiAgbWFrZU5ld0VudGl0eTogKHBvc2l0aW9uKSAtPlxuICAgIGlkID0gXCJlbnRpdHktI3tAZW50aXR5Q291bnQrK31cIlxuXG4gICAgZW50aXR5ID1cbiAgICAgIGlkOiBpZFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgcmV0dXJuIGVudGl0eVxuXG5cbiAgIyBUT0RPOiBtb3ZlIHRoZXNlIGZvY3VzIG1ldGhvZHMgZWxzZXdoZXJlXG5cbiAgIyBmb2N1c09uSXRlbTogKGl0ZW0sIG9mZnNldCA9IFswLCAwXSwgem9vbUZhY3RvciA9IDAuNCkgLT5cbiAgIyAgIHZpZXcgPSBpdGVtLnByb2plY3Qudmlld1xuXG4gICMgICBwb2ludCA9IGl0ZW0ucG9zaXRpb25cblxuICAjICAgIyBudWRnZSBpdGVtIHVwIGEgbGl0dGxlIGJpdFxuICAjICAgIyBvZmZzZXQgPSBbMCwgdmlldy52aWV3U2l6ZS5oZWlnaHQgKiAwLjA4XVxuICAjICAgcG9pbnQgPSBwb2ludC5hZGQgb2Zmc2V0XG5cbiAgIyAgIHdpZHRoWm9vbURzdCA9IHZpZXcudmlld1NpemUud2lkdGggLyBpdGVtLmJvdW5kcy53aWR0aFxuICAjICAgaGVpZ2h0Wm9vbURzdCA9IHZpZXcudmlld1NpemUuaGVpZ2h0IC8gaXRlbS5ib3VuZHMuaGVpZ2h0XG5cbiAgIyAgIHpvb21Ub0ZpdERzdCA9IE1hdGgubWluIHdpZHRoWm9vbURzdCwgaGVpZ2h0Wm9vbURzdFxuXG4gICMgICByZXR1cm4gbmV3IFByb21pc2UgKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgIyAgICAgb3RoZXJJc0RvbmUgPSBmYWxzZSAjIGxvbFxuXG4gICMgICAgIGZpbmlzaCA9ICgpIC0+XG4gICMgICAgICAgaWYgb3RoZXJJc0RvbmU/XG4gICMgICAgICAgICBkbyByZXNvbHZlXG4gICMgICAgICAgZWxzZVxuICAjICAgICAgICAgb3RoZXJJc0RvbmUgPSB0cnVlXG5cbiAgIyAgICAgQF9hbmltYXRlUGFuVG8gcG9pbnQsIHZpZXcsIDAuMlxuICAjICAgICAgIC50aGVuIGZpbmlzaCwgcmVqZWN0XG4gICMgICAgIEBfYW5pbWF0ZVpvb20gKHpvb21Ub0ZpdERzdCAqIHpvb21GYWN0b3IpLCB2aWV3LCAwLjJcbiAgIyAgICAgICAudGhlbiBmaW5pc2gsIHJlamVjdFxuXG4gICMgX2FuaW1hdGVQYW5UbzogKGRzdCwgdmlldywgc3BlZWQpIC0+XG4gICMgICByZXR1cm4gbmV3IFByb21pc2UgKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgIyAgICAgZWxhcHNlZCA9IDBcbiAgIyAgICAgc3JjID0gdmlldy5jZW50ZXJcbiAgIyAgICAgdHJhdmVsID0gZHN0LnN1YnRyYWN0IHNyY1xuXG4gICMgICAgICMgZHVyYXRpb24gPSB0cmF2ZWwubGVuZ3RoIC8gc3BlZWRcbiAgIyAgICAgZHVyYXRpb24gPSBzcGVlZFxuXG4gICMgICAgIGFuaW1hdGVQYW4gPSAoZXZ0KSA9PlxuICAjICAgICAgIGVsYXBzZWQgKz0gZXZ0LmRlbHRhXG4gICMgICAgICAgdHJhdmVsUmF0aW8gPSBlbGFwc2VkIC8gZHVyYXRpb25cblxuICAjICAgICAgIGlmIHRyYXZlbFJhdGlvID49IDFcbiAgIyAgICAgICAgIHRyYXZlbFJhdGlvID0gMVxuICAjICAgICAgICAgdmlldy5jZW50ZXIgPSBkc3RcbiAgIyAgICAgICAgIHZpZXcub2ZmICdmcmFtZScsIGFuaW1hdGVQYW5cblxuICAjICAgICAgICAgQGRpc3BhdGNoICdkaWRWaWV3cG9ydFRyYW5zZm9ybSdcbiAgIyAgICAgICAgIGRvIHJlc29sdmVcblxuICAjICAgICAgICAgcmV0dXJuXG5cbiAgIyAgICAgICB2aWV3LmNlbnRlciA9IHNyYy5hZGQgKHRyYXZlbC5tdWx0aXBseSB0cmF2ZWxSYXRpbylcblxuICAjICAgICB2aWV3Lm9uICdmcmFtZScsIGFuaW1hdGVQYW5cblxuICAjIF9hbmltYXRlWm9vbTogKHpvb21Ec3QsIHZpZXcsIHNwZWVkKSAtPlxuICAjICAgcmV0dXJuIG5ldyBQcm9taXNlIChyZXNvbHZlLCByZWplY3QpID0+XG4gICMgICAgIGVsYXBzZWQgPSAwXG4gICMgICAgIHNyYyA9IHZpZXcuem9vbVxuICAjICAgICB0cmF2ZWwgPSB6b29tRHN0IC0gc3JjXG5cbiAgIyAgICAgIyBkdXJhdGlvbiA9IHRyYXZlbCAvIHNwZWVkXG4gICMgICAgIGR1cmF0aW9uID0gc3BlZWRcblxuICAjICAgICBhbmltYXRlWm9vbUZyYW1lID0gKGV2dCkgPT5cbiAgIyAgICAgICBlbGFwc2VkICs9IGV2dC5kZWx0YVxuICAjICAgICAgIHRyYXZlbFJhdGlvID0gZWxhcHNlZCAvIGR1cmF0aW9uXG5cbiAgIyAgICAgICBpZiB0cmF2ZWxSYXRpbyA+PSAxXG4gICMgICAgICAgICB0cmF2ZWxSYXRpbyA9IDFcbiAgIyAgICAgICAgIHZpZXcuem9vbSA9IHpvb21Ec3RcbiAgIyAgICAgICAgIHZpZXcub2ZmICdmcmFtZScsIGFuaW1hdGVab29tRnJhbWVcblxuICAjICAgICAgICAgQGRpc3BhdGNoICdkaWRWaWV3cG9ydFRyYW5zZm9ybSdcbiAgIyAgICAgICAgIGRvIHJlc29sdmVcblxuICAjICAgICAgICAgcmV0dXJuXG5cbiAgIyAgICAgICB2aWV3Lnpvb20gPSBzcmMgKyAodHJhdmVsICogdHJhdmVsUmF0aW8pXG5cbiAgIyAgICAgdmlldy5vbiAnZnJhbWUnLCBhbmltYXRlWm9vbUZyYW1lXG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgV29ybGQoKSIsIm1vZHVsZS5leHBvcnRzID0gbWl4aW5EaXNwYXRjaGFibGUgPSAob25PYmosIGRpc3BhdGNoZXIpIC0+XG4gIG9uT2JqLmRpc3BhdGNoID0gKGFjdGlvblR5cGUsIGRhdGEpIC0+XG4gICAgZGlzcGF0Y2hlci5kaXNwYXRjaFxuICAgICAgYWN0aW9uOlxuICAgICAgICBhY3Rpb25UeXBlOiBhY3Rpb25UeXBlXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgcmV0dXJuIG9uT2JqIiwiY2xhc3MgVGltZW91dE1hbmFnZXJcbiAgY29uc3RydWN0b3I6ICgpIC0+XG4gICAgQF9jbGVhclNldCA9IHt9XG5cbiAgc2V0VGltZW91dDogKGRlbGF5LCBwcm9jKSAtPlxuICAgIHRpbWVvdXRJZCA9IG51bGxcblxuICAgIHByb2NBbmRSZW1vdmUgPSAoKSA9PlxuICAgICAgZG8gcHJvY1xuICAgICAgZGVsZXRlIEBfY2xlYXJTZXRbXCIje3RpbWVvdXRJZH1cIl1cblxuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQgcHJvY0FuZFJlbW92ZSwgZGVsYXlcblxuICAgIEBfY2xlYXJTZXRbXCIje3RpbWVvdXRJZH1cIl0gPSAoKSA9PlxuICAgICAgY2xlYXJUaW1lb3V0IHRpbWVvdXRJZFxuICAgICAgZGVsZXRlIEBfY2xlYXJTZXRbXCIje3RpbWVvdXRJZH1cIl1cblxuICBjbGVhckFsbDogKCkgLT5cbiAgICBmb3IgaywgdiBvZiBAX2NsZWFyU2V0XG4gICAgICBkbyB2XG4gICAgQF9jbGVhclNldCA9IHt9XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lb3V0TWFuYWdlciIsIm1vZHVsZS5leHBvcnRzID0gbWl4aW5EaXNwYXRjaGFibGUgPSAob25PYmosIGRpc3BhdGNoZXIpIC0+XG4gIG9uT2JqLmRpc3BhdGNoID0gKGFjdGlvblR5cGUsIGRhdGEpIC0+XG4gICAgZGlzcGF0Y2hlci5kaXNwYXRjaFxuICAgICAgYWN0aW9uOlxuICAgICAgICBhY3Rpb25UeXBlOiBhY3Rpb25UeXBlXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgcmV0dXJuIG9uT2JqIiwiXyA9IHJlcXVpcmUgJ2xvZGFzaCdcblJlYWN0ID0gcmVxdWlyZSAncmVhY3QnXG5QYXBlciA9IHJlcXVpcmUgJ3BhcGVyJ1xuXG5Xb3JsZFN0b3JlID0gcmVxdWlyZSAnLi4vc3RvcmVzL1dvcmxkJ1xuRWRpdG9yU3RvcmUgPSByZXF1aXJlICcuLi9zdG9yZXMvRWRpdG9yJ1xuVXNlclN0b3JlID0gcmVxdWlyZSAnLi4vc3RvcmVzL1VzZXInXG5cbkluc3BlY3RvckNvbnRyb2xsZXIgPSByZXF1aXJlICcuL0luc3BlY3RvckNvbnRyb2xsZXInXG5Xb3JsZENvbnRyb2xsZXIgPSByZXF1aXJlICcuL1dvcmxkQ29udHJvbGxlcidcblZvbHVtZUNvbnRyb2wgPSByZXF1aXJlICcuL1ZvbHVtZUNvbnRyb2wnXG5cbm1ha2VSYW5kb21QYXRoID0gcmVxdWlyZSAnLi9wYXBlci9NYWtlUmFuZG9tUGF0aCdcbnNldHVwQ2FtZXJhVG9vbCA9IHJlcXVpcmUgJy4vcGFwZXIvQ2FtZXJhQ29udHJvbCdcblxuRGlzcGF0Y2hhYmxlID0gcmVxdWlyZSAnLi4vdXRpbC9EaXNwYXRjaGFibGUnXG5kaXNwYXRjaGVyID0gcmVxdWlyZSAnLi4vRGlzcGF0Y2hlcidcblxucmFuZG9tQ29sb3IgPSByZXF1aXJlICcuL3BhcGVyL1JhbmRvbUNvbG9yJ1xuXG5BcHBsaWNhdGlvbiA9IFJlYWN0LmNyZWF0ZUNsYXNzXG4gIGRpc3BsYXlOYW1lOiAnQXBwbGljYXRpb24nXG5cbiAgc2hhZG93QW1vdW50OiBbMjAsIDIwXVxuXG4gIGdldEluaXRpYWxTdGF0ZTogKCkgLT5cbiAgICB3b3JsZDogV29ybGRTdG9yZS5nZXRBbGwoKVxuICAgIGVkaXRvcjogRWRpdG9yU3RvcmUuZ2V0QWxsKClcbiAgICB1c2VyOiBVc2VyU3RvcmUuZ2V0QWxsKClcbiAgICBhcHA6XG4gICAgICBzaG93T3ZlcmxheXM6IGZhbHNlXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6ICgpIC0+XG4gICAgRGlzcGF0Y2hhYmxlIHRoaXMsIGRpc3BhdGNoZXJcbiAgICBXb3JsZFN0b3JlLmFkZENoYW5nZUxpc3RlbmVyIEBfb25DaGFuZ2VcbiAgICBFZGl0b3JTdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lciBAX29uQ2hhbmdlXG4gICAgVXNlclN0b3JlLmFkZENoYW5nZUxpc3RlbmVyIEBfb25DaGFuZ2VcblxuICAgIGNhbnZhcyA9IEByZWZzLmNhbnZhcy5nZXRET01Ob2RlKClcbiAgICBpbnNwZWN0b3IgPSBAcmVmcy5pbnNwZWN0b3IuZ2V0RE9NTm9kZSgpXG5cbiAgICBAZmllbGRQYXBlclNjb3BlID0gQHNldHVwRmllbGQgY2FudmFzXG4gICAgQGluc3BlY3RvclBhcGVyU2NvcGUgPSBAc2V0dXBJbnNwZWN0b3IgaW5zcGVjdG9yXG5cbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnXG4gICAgaW5zcGVjdG9yLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgaW5zcGVjdG9yLnN0eWxlLmhlaWdodCA9ICcxMDAlJ1xuXG4gICAgQGZpZWxkUGFwZXJTY29wZS52aWV3LnZpZXdTaXplID0gW2NhbnZhcy5vZmZzZXRXaWR0aCwgY2FudmFzLm9mZnNldEhlaWdodF1cbiAgICBAaW5zcGVjdG9yUGFwZXJTY29wZS52aWV3LnZpZXdTaXplID0gW2luc3BlY3Rvci5vZmZzZXRXaWR0aCwgaW5zcGVjdG9yLm9mZnNldEhlaWdodF1cblxuXG4gIHNldHVwRmllbGQ6IChjYW52YXNOb2RlKSAtPlxuICAgIGZpZWxkUGFwZXIgPSBuZXcgUGFwZXIuUGFwZXJTY29wZSgpXG4gICAgZmllbGRQYXBlci5zZXR1cCBjYW52YXNOb2RlXG5cbiAgICAobmV3IFdvcmxkQ29udHJvbGxlcigpKS5hdHRhY2ggZmllbGRQYXBlclxuICAgIHJldHVybiBmaWVsZFBhcGVyXG5cbiAgc2V0dXBJbnNwZWN0b3I6IChjYW52YXNOb2RlKSAtPlxuICAgIGluc3BlY3RvclBhcGVyID0gbmV3IFBhcGVyLlBhcGVyU2NvcGUoKVxuICAgIGluc3BlY3RvclBhcGVyLnNldHVwIGNhbnZhc05vZGVcblxuICAgIChuZXcgSW5zcGVjdG9yQ29udHJvbGxlcigpKS5hdHRhY2ggaW5zcGVjdG9yUGFwZXJcbiAgICByZXR1cm4gaW5zcGVjdG9yUGFwZXJcblxuICBoYW5kbGVEcmFnb3ZlcjogKGV2dCkgLT5cbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2dC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5J1xuXG4gIGhhbmRsZURyb3A6IChldnQpIC0+XG4gICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KClcblxuICAgIGZpbGUgPSBldnQuZGF0YVRyYW5zZmVyLmZpbGVzWzBdXG4gICAgcHQgPSBuZXcgQGZpZWxkUGFwZXJTY29wZS5Qb2ludCBldnQuY2xpZW50WCwgZXZ0LmNsaWVudFlcblxuICAgIGlmIGZpbGU/XG4gICAgICBAZGlzcGF0Y2ggJ3dhbnRzQWRkRW50aXR5JyxcbiAgICAgICAgZmlsZTogZmlsZVxuICAgICAgICBwb3NpdGlvbjogQGZpZWxkUGFwZXJTY29wZS52aWV3LnZpZXdUb1Byb2plY3QgcHRcblxuICByZW5kZXI6ICgpIC0+XG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XCJpZFwiOiBcImZyYW1lXCIsICBcXFxuICAgICAgICAgXCJyZWZcIjogXCJmcmFtZVwiLCAgXFxcbiAgICAgICAgIFwib25Nb3VzZUVudGVyXCI6ICgoKSA9PiBAc2V0U3RhdGUge2FwcDoge3Nob3dPdmVybGF5czogdHJ1ZX19KSwgIFxcXG4gICAgICAgICBcIm9uTW91c2VPdXRcIjogKChldnQpID0+XG4gICAgICAgICAgQHNldFN0YXRlIHthcHA6IHtzaG93T3ZlcmxheXM6IGV2dC5yZWxhdGVkVGFyZ2V0PyBhbmQgZXZ0LnJlbGF0ZWRUYXJnZXQgaXNudCBAcmVmcy5jYW52YXMuZ2V0RE9NTm9kZSgpfX0pfSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1wiaWRcIjogXCJjb250YWluZXJcIn0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1wiaWRcIjogXCJtZy1vdmVybGF5c1wifSxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFZvbHVtZUNvbnRyb2wsIHtcImlkXCI6IFwibWctbWFzdGVyLXZvbHVtZVwiLCAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzTmFtZVwiOiAoaWYgQHN0YXRlLmFwcC5zaG93T3ZlcmxheXMgdGhlbiAndmlzaWJsZScgZWxzZSAnaGlkZGVuJyksICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgIFwic291cmNlXCI6IChAcHJvcHMuYXVkaW9Tb3VyY2UpfVxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XCJpZFwiOiBcIm1nLWFwcFwiLCAgXFxcbiAgICAgICAgICAgICBcImNsYXNzTmFtZVwiOiBcIm1nLWFwcFwiLCAgXFxcbiAgICAgICAgICAgICBcInJlZlwiOiBcImNvbnRhaW5lclwifSxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIHtcImNsYXNzTmFtZVwiOiBcIm1nLWZpZWxkXCIsICBcXFxuICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIm1nLWZpZWxkLWNhbnZhc1wiLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwicmVmXCI6IFwiY2FudmFzXCIsICBcXFxuICAgICAgICAgICAgICAgICAgXCJzdHlsZVwiOiAoQHByb3BzLnN0eWxlKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcIm9uRHJhZ092ZXJcIjogKEBoYW5kbGVEcmFnb3ZlciksICBcXFxuICAgICAgICAgICAgICAgICAgXCJvbkRyb3BcIjogKEBoYW5kbGVEcm9wKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcImRhdGEtcmVzaXplXCI6IFwidHJ1ZVwifVxuICAgICAgICAgICksXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLCB7XCJjbGFzc05hbWVcIjogKFwibWctaW5zcGVjdG9yXCIgKyBpZiBAc3RhdGUuZWRpdG9yLmlzQWN0aXZlIHRoZW4gJyB2aXNpYmxlJyBlbHNlICcgaGlkZGVuJyksICBcXFxuICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIm1nLWluc3BlY3Rvci1jYW52YXNcIiwgIFxcXG4gICAgICAgICAgICAgICAgICBcInJlZlwiOiBcImluc3BlY3RvclwiLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwic3R5bGVcIjogKEBwcm9wcy5zdHlsZSksICBcXFxuICAgICAgICAgICAgICAgICAgXCJvbkRyYWdPdmVyXCI6IChAaGFuZGxlRHJhZ292ZXIpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwib25Ecm9wXCI6IChAaGFuZGxlRHJvcCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJkYXRhLXJlc2l6ZVwiOiBcInRydWVcIn1cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG5cbiAgY2FudmFzRGltZW5zaW9uczogKCkgLT5cbiAgICBAcmVmcy5jb250YWluZXIuZ2V0RE9NTm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgX29uQ2hhbmdlOiAoKSAtPlxuICAgIEBzZXRTdGF0ZVxuICAgICAgd29ybGQ6IFdvcmxkU3RvcmUuZ2V0QWxsKClcbiAgICAgIGVkaXRvcjogRWRpdG9yU3RvcmUuZ2V0QWxsKClcbiAgICAgIHVzZXI6IFVzZXJTdG9yZS5nZXRBbGwoKVxuXG4gICAgIyBAX3VwZGF0ZUJhY2tncm91bmQoKVxuXG4gICMgVE9ETzogc29tZSBjb250cm9sbGVyIGZvciB1c2VyLXNwZWNpZmljIGFjdGlvbnM/XG4gICMgX3VwZGF0ZUJhY2tncm91bmQ6ICgpIC0+XG4gICMgICBAYmFja2dyb3VuZExheWVyPy50cmFuc2xhdGUgKG5ldyBQYXBlci5Qb2ludCBAc3RhdGUudXNlci5kZWx0YVBvc2l0aW9uKS5tdWx0aXBseSAwLjVcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcGxpY2F0aW9uIiwiXyA9IHJlcXVpcmUgJ2xvZGFzaCdcblxuRGlzcGF0Y2hhYmxlID0gcmVxdWlyZSAnLi4vdXRpbC9kaXNwYXRjaGFibGUnXG5kaXNwYXRjaGVyID0gcmVxdWlyZSAnLi4vRGlzcGF0Y2hlcidcbkVkaXRvclN0b3JlID0gcmVxdWlyZSAnLi4vc3RvcmVzL0VkaXRvcidcblxuUmVkSW5zcGVjdG9yID0gcmVxdWlyZSAnLi9pbnNwZWN0b3JzL1JlZEluc3BlY3RvcidcblxuY2xhc3MgSW5zcGVjdG9yQ29udHJvbGxlclxuICBjb25zdHJ1Y3RvcjogKCkgLT5cbiAgICBEaXNwYXRjaGFibGUgdGhpcywgZGlzcGF0Y2hlclxuICAgIEBhY3RpdmVJbnNwZWN0b3IgPSBudWxsXG5cbiAgYXR0YWNoOiAocGFwZXIpIC0+XG4gICAgQHNldHVwVmlldyBwYXBlclxuXG4gICAgRWRpdG9yU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIgQF9vbkNoYW5nZVxuICAgIGRvIEBfb25DaGFuZ2VcblxuICBkZXRhY2g6ICgpIC0+XG4gICAgRWRpdG9yU3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIgQF9vbkNoYW5nZVxuXG4gIHVwZGF0ZTogKHN0YXRlKSAtPlxuICAgIGlmIHN0YXRlLmVkaXRvci5ldmVudHMud2FudHNFZGl0XG4gICAgICBpZiBzdGF0ZS5lZGl0b3IucXVldWVkRW50aXR5P1xuICAgICAgICAjIHRoaXMgc2hvdWxkIGJlIGR5bmFtaWMgaW4gZnV0dXJlIHZlcnNpb25zXG4gICAgICAgIEBhY3RpdmVJbnNwZWN0b3IgPSBuZXcgUmVkSW5zcGVjdG9yIHN0YXRlLmVkaXRvci5xdWV1ZWRFbnRpdHlcblxuICAgICAgICBAc2hvd0luc3BlY3RvciBAX3BhcGVyLCBAX2luc3BlY3Rvckdyb3VwLCBAYWN0aXZlSW5zcGVjdG9yXG4gICAgICAgIEBkaXNwYXRjaCAnZGlkQmVnaW5FZGl0RW50aXR5JyxcbiAgICAgICAgICBlbnRpdHk6IHN0YXRlLmVkaXRvci5xdWV1ZWRFbnRpdHlcbiAgICAgIGVsc2VcbiAgICAgICAgY29uc29sZS5lcnJvciAnd2FudGVkIGVkaXQgYnV0IG5vIGVudGl0eSBxdWV1ZWQgZm9yIGVkaXQnXG5cbiAgICBpZiBzdGF0ZS5lZGl0b3IuZXZlbnRzLndhbnRzQ2FuY2VsXG4gICAgICBAaGlkZUluc3BlY3RvciBAX3BhcGVyLCBAX2luc3BlY3Rvckdyb3VwLCBAYWN0aXZlSW5zcGVjdG9yXG4gICAgICBAZGlzcGF0Y2ggJ2RpZENhbmNlbEVkaXRFbnRpdHknXG5cblxuICBzZXR1cFZpZXc6IChwYXBlcikgLT5cbiAgICBAX3BhcGVyID0gcGFwZXJcblxuICAgIHBhcGVyLnZpZXcuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyICdtb3VzZXVwJywgKGV2dCkgPT5cbiAgICAgIHB0ID0gbmV3IHBhcGVyLlBvaW50IGV2dC5vZmZzZXRYLCBldnQub2Zmc2V0WVxuICAgICAgaWYgbm90IChwYXBlci5wcm9qZWN0LmhpdFRlc3QgcHQpP1xuICAgICAgICBAZGlzcGF0Y2ggJ3dhbnRzQ2FuY2VsRWRpdEVudGl0eSdcblxuICAgIEBfaW5zcGVjdG9yR3JvdXAgPSBuZXcgcGFwZXIuR3JvdXBcbiAgICAgIG5hbWU6ICdpbnNwZWN0b3InXG4gICAgcGFwZXIudmlldy5kcmF3KClcblxuXG4gIGhpZGVJbnNwZWN0b3I6IChwYXBlciwgaW5zcGVjdG9yR3JvdXAsIGluc3BlY3Rvck1vZGVsKSAtPlxuICAgIGluc3BlY3Rvckdyb3VwLnZpc2libGUgPSBmYWxzZVxuICAgIGluc3BlY3Rvck1vZGVsPy5yZW1vdmUoKVxuXG4gIHNob3dJbnNwZWN0b3I6IChwYXBlciwgaW5zcGVjdG9yR3JvdXAsIGluc3BlY3Rvck1vZGVsKSAtPlxuICAgIEBfc2V0dXBTeW50aE1hcHBpbmcgaW5zcGVjdG9yTW9kZWxcblxuICAgIGl0ZW0gPSBpbnNwZWN0b3JNb2RlbC5kcmF3IHBhcGVyLCAocGFwZXIudmlldy5ib3VuZHMuc2l6ZS5tdWx0aXBseSAwLjgpXG4gICAgaW5zcGVjdG9yR3JvdXAuYWRkQ2hpbGQgaXRlbVxuICAgIGluc3BlY3Rvckdyb3VwLnBvc2l0aW9uID0gcGFwZXIudmlldy5jZW50ZXJcblxuICAgIHBhcGVyLnZpZXcuZHJhdygpXG5cblxuICAgIGluc3BlY3Rvckdyb3VwLnBvc2l0aW9uID0gcGFwZXIudmlldy5jZW50ZXJcbiAgICBpbnNwZWN0b3JHcm91cC52aXNpYmxlID0gdHJ1ZVxuXG5cbiAgX3NldHVwU3ludGhNYXBwaW5nOiAoaW5zcGVjdG9yTW9kZWwpIC0+XG4gICAgc3ludGggPSBpbnNwZWN0b3JNb2RlbC5lbnRpdHkuc3ludGhcblxuICAgIGRpc3BhdGNoUGFyYW1ldGVyQ2hhbmdlID0gKHBhcmFtTmFtZSwgdmFsdWUpID0+XG4gICAgICBAZGlzcGF0Y2ggJ3NldFN5bnRoUGFyYW1ldGVyJyxcbiAgICAgICAgc3ludGg6IHN5bnRoXG4gICAgICAgIHBhcmFtZXRlcjpcbiAgICAgICAgICBuYW1lOiBwYXJhbU5hbWVcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcblxuICAgIG1ha2VHZXRGbiA9IChwYXJhbU5hbWUsIHRyYW5zZm9ybSA9IF8uaWRlbnRpdHkpIC0+XG4gICAgICAoKSAtPiB0cmFuc2Zvcm0gc3ludGgub3B0aW9ucy5ncmFudWxhcltwYXJhbU5hbWVdXG4gICAgbWFrZVNldEZuID0gKHBhcmFtTmFtZSwgdHJhbnNmb3JtID0gXy5pZGVudGl0eSkgLT5cbiAgICAgICh2KSAtPiBkaXNwYXRjaFBhcmFtZXRlckNoYW5nZSBwYXJhbU5hbWUsIHRyYW5zZm9ybSB2XG5cbiAgICBpbnNwZWN0b3JNb2RlbC5tYXBQYXJhbWV0ZXIgJ3NjcnViYmVyWCcsXG4gICAgICAobWFrZUdldEZuICdjZW50ZXInLCAodikgLT4gdiAqIDEwKSxcbiAgICAgIChtYWtlU2V0Rm4gJ2NlbnRlcicsICgodikgLT5cbiAgICAgICAgY29va2VkID0gKCh2IC8gMTApICsgMikgJSAxXG5cbiAgICAgICAgaW5zcGVjdG9yTW9kZWwuc2V0RmVlZGJhY2tQYXJhbWV0ZXIgJ3BsYXloZWFkUG9zaXRpb24nLCBjb29rZWRcbiAgICAgICAgcmV0dXJuIGNvb2tlZCkpXG5cbiAgICBpbnNwZWN0b3JNb2RlbC5tYXBQYXJhbWV0ZXIgJ2JhY2tncm91bmRYJyxcbiAgICAgIChtYWtlR2V0Rm4gJ2dyYWluRHVyYXRpb24nLCAodikgLT4gdiAvIDEwKSxcbiAgICAgIChtYWtlU2V0Rm4gJ2dyYWluRHVyYXRpb24nLCAodikgLT5cbiAgICAgICAgdl8gPSB2ICogMTBcblxuICAgICAgICAjIGluIG1zXG4gICAgICAgIG1pbiA9IDEwMFxuICAgICAgICBtYXggPSAxMDAwXG5cbiAgICAgICAgY29va2VkID0gTWF0aC5taW4gbWF4LCAoTWF0aC5tYXggbWluLCB2XylcbiAgICAgICAgbm9ybWFsaXplZCA9IChjb29rZWQgLSBtaW4pIC8gKG1heCAtIG1pbilcbiAgICAgICAgaW5zcGVjdG9yTW9kZWwuc2V0RmVlZGJhY2tQYXJhbWV0ZXIgJ3NjcnViYmVySGVpZ2h0Jywgbm9ybWFsaXplZFxuXG4gICAgICAgIHJldHVybiBjb29rZWQpXG5cbiAgICBpbnNwZWN0b3JNb2RlbC5tYXBQYXJhbWV0ZXIgJ2JhY2tncm91bmRZJyxcbiAgICAgIChtYWtlR2V0Rm4gJ2RldHVuZScsICgodikgLT4gdiAvIDUwKSksXG4gICAgICAobWFrZVNldEZuICdkZXR1bmUnLCAoKHYpIC0+XG4gICAgICAgIGNvb2tlZCA9IHYgKiA1MFxuICAgICAgICBtaW4gPSAtMTIwMFxuICAgICAgICBtYXggPSAxMjAwXG4gICAgICAgIHJhbmdlZCA9IChNYXRoLm1heCBtaW4sIChNYXRoLm1pbiBtYXgsIGNvb2tlZCkpXG4gICAgICAgIG5vcm1hbGl6ZWQgPSAocmFuZ2VkIC0gbWluKSAvIChtYXggLSBtaW4pXG4gICAgICAgICMgaW5zcGVjdG9yTW9kZWwuc2V0RmVlZGJhY2tQYXJhbWV0ZXIgJ2l0ZW1BZ2l0YXRpb24nLCBub3JtYWxpemVkXG4gICAgICAgIGluc3BlY3Rvck1vZGVsLnNldEZlZWRiYWNrUGFyYW1ldGVyICdodWUnLCBub3JtYWxpemVkIC8gM1xuICAgICAgICBpbnNwZWN0b3JNb2RlbC5zZXRGZWVkYmFja1BhcmFtZXRlciAnbGlnaHRuZXNzJywgbm9ybWFsaXplZFxuICAgICAgICBjb25zb2xlLmxvZyBub3JtYWxpemVkXG4gICAgICAgIHJldHVybiBjb29rZWQpKVxuXG4gICAgaW5pdGlhbFNjcnViYmVySGVpZ2h0ID1cbiAgICAgIChzeW50aC5vcHRpb25zLmdyYW51bGFyLmdyYWluRHVyYXRpb24gLSAxMDApIC8gKDEwMDAgLSAxMDApXG4gICAgaW5zcGVjdG9yTW9kZWwuc2V0RmVlZGJhY2tQYXJhbWV0ZXIgXFxcbiAgICAgICdzY3J1YmJlckhlaWdodCcsXG4gICAgICBpbml0aWFsU2NydWJiZXJIZWlnaHRcblxuICBfZmV0Y2hTdGF0ZTogKCkgLT5cbiAgICBlZGl0b3I6IEVkaXRvclN0b3JlLmdldEFsbCgpXG5cblxuICBfb25DaGFuZ2U6ICgpID0+XG4gICAgQHN0YXRlID0gQF9mZXRjaFN0YXRlKClcbiAgICBAdXBkYXRlIEBzdGF0ZVxuXG5cbm1vZHVsZS5leHBvcnRzID0gSW5zcGVjdG9yQ29udHJvbGxlciIsIl8gPSByZXF1aXJlICdsb2Rhc2gnXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuXG5kaXNwYXRjaGVyID0gcmVxdWlyZSAnLi4vRGlzcGF0Y2hlcidcbkRpc3BhdGNoYWJsZSA9IHJlcXVpcmUgJy4uL3V0aWwvRGlzcGF0Y2hhYmxlJ1xuXG5Wb2x1bWVDb250cm9sID0gUmVhY3QuY3JlYXRlQ2xhc3NcbiAgZGlzcGxheU5hbWU6ICdWb2x1bWVDb250cm9sJ1xuXG4gIGdldEluaXRpYWxTdGF0ZTogKCkgLT5cbiAgICBtdXRlZDogZmFsc2VcblxuICBjb21wb25lbnREaWRNb3VudDogKCkgLT5cbiAgICBEaXNwYXRjaGFibGUgdGhpcywgZGlzcGF0Y2hlclxuXG4gIHJlbmRlcjogKCkgLT5cbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcImNsYXNzTmFtZVwiOiAoQHByb3BzLmNsYXNzTmFtZSksICBcXFxuICAgICAgICAgXCJpZFwiOiAoQHByb3BzLmlkKSwgIFxcXG4gICAgICAgICBcIm9uQ2xpY2tcIjogKCgpID0+XG4gICAgICAgICAgQGRpc3BhdGNoICdkaWRNYXN0ZXJDaGFuZ2VNdXRlJyxcbiAgICAgICAgICAgIGlzTXV0ZWQ6IG5vdCBAc3RhdGUubXV0ZWRcbiAgICAgICAgICBAc2V0U3RhdGUge211dGVkOiBub3QgQHN0YXRlLm11dGVkfSl9LFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJjbGljayB0byBcIiwgKGlmIEBzdGF0ZS5tdXRlZCB0aGVuICd1bm11dGUnIGVsc2UgJ211dGUnKSlcbiAgICApXG5cblxubW9kdWxlLmV4cG9ydHMgPSBWb2x1bWVDb250cm9sIiwiXyA9IHJlcXVpcmUgJ2xvZGFzaCdcblxuRGlzcGF0Y2hhYmxlID0gcmVxdWlyZSAnLi4vdXRpbC9kaXNwYXRjaGFibGUnXG5kaXNwYXRjaGVyID0gcmVxdWlyZSAnLi4vRGlzcGF0Y2hlcidcbldvcmxkU3RvcmUgPSByZXF1aXJlICcuLi9zdG9yZXMvV29ybGQnXG5Vc2VyU3RvcmUgPSByZXF1aXJlICcuLi9zdG9yZXMvVXNlcidcblxuc2V0dXBDYW1lcmFUb29sID0gcmVxdWlyZSAnLi9wYXBlci9DYW1lcmFDb250cm9sJ1xubWFrZVRpbGVkSXRlbSA9IHJlcXVpcmUgJy4vcGFwZXIvVGlsZWRJdGVtJ1xuSW5maW5pdGVUaWxlZEl0ZW0gPSByZXF1aXJlICcuL3BhcGVyL0luZmluaXRlVGlsZWRJdGVtJ1xubWFrZVJhbmRvbVBhdGggPSByZXF1aXJlICcuL3BhcGVyL01ha2VSYW5kb21QYXRoJ1xucmFuZG9tQ29sb3IgPSByZXF1aXJlICcuL3BhcGVyL1JhbmRvbUNvbG9yJ1xuXG5jbGFzcyBXb3JsZENvbnRyb2xsZXJcbiAgY29uc3RydWN0b3I6ICgpIC0+XG4gICAgRGlzcGF0Y2hhYmxlIHRoaXMsIGRpc3BhdGNoZXJcblxuICAgIEBfb25WaWV3cG9ydFRyYW5zZm9ybSA9IFtdXG5cbiAgYXR0YWNoOiAocGFwZXIpIC0+XG4gICAgQHNldHVwVmlldyBwYXBlclxuXG4gICAgV29ybGRTdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lciBAX29uQ2hhbmdlXG4gICAgVXNlclN0b3JlLmFkZENoYW5nZUxpc3RlbmVyIEBfb25DaGFuZ2VcbiAgICBkbyBAX29uQ2hhbmdlXG5cblxuICBkZXRhY2g6ICgpIC0+XG4gICAgV29ybGRTdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lciBAX29uQ2hhbmdlXG4gICAgVXNlclN0b3JlLnJlbW92ZUNoYW5nZUxpc3RlbmVyIEBfb25DaGFuZ2VcblxuICB1cGRhdGU6IChzdGF0ZSkgLT5cbiAgICBpZiBzdGF0ZS53b3JsZC5xdWV1ZWQuZW50aXR5P1xuICAgICAgZ3JhcGhpYyA9IEBfbWFrZUVudGl0eUdyYXBoaWMgQHBhcGVyLCBzdGF0ZS53b3JsZC5xdWV1ZWQuZW50aXR5XG4gICAgICBAZGlzcGF0Y2ggJ2RpZFJlZ2lzdGVyRW50aXR5JyxcbiAgICAgICAgcGFwZXI6XG4gICAgICAgICAgc2NvcGU6IEBwYXBlclxuICAgICAgICAgIHBhdGg6IGdyYXBoaWMucGF0aFxuICAgICAgICAgIHNoYWRvdzogZ3JhcGhpYy5zaGFkb3dcbiAgICAgICAgZW50aXR5OiBzdGF0ZS53b3JsZC5xdWV1ZWQuZW50aXR5XG5cbiAgICBpZiBzdGF0ZS51c2VyLnBvc2l0aW9uP1xuICAgICAgcGFyYWxsYXhGYWN0b3IgPSAyXG4gICAgICAjIEBfYmFja2dyb3VuZEdyb3VwLnBvc2l0aW9uID0gKG5ldyBAcGFwZXIuUG9pbnQgc3RhdGUudXNlci5wb3NpdGlvbikubXVsdGlwbHkgKDEgLyBwYXJhbGxheEZhY3RvcilcbiAgICAgIG5ld09yaWdpbiA9IChuZXcgQHBhcGVyLlBvaW50IHN0YXRlLnVzZXIucG9zaXRpb24pLm11bHRpcGx5ICgxIC8gcGFyYWxsYXhGYWN0b3IpXG4gICAgICBAX2JhY2tncm91bmRHcm91cC5jaGlsZHJlblsndGlsZWRCZyddPy5zZXRPcmlnaW4gbmV3T3JpZ2luXG4gICAgICBAX2JhY2tncm91bmRHcm91cC5jaGlsZHJlblsndGlsZWROb2lzZSddPy5zZXRPcmlnaW4gbmV3T3JpZ2luXG5cbiAgICAgIEBfb25WaWV3cG9ydFRyYW5zZm9ybS5mb3JFYWNoIChjYikgLT4gZG8gY2JcblxuXG5cbiAgc2V0dXBWaWV3OiAocGFwZXIpIC0+XG4gICAgQHBhcGVyID0gcGFwZXJcblxuICAgIEBfc2hhZG93R3JvdXAgPSBuZXcgcGFwZXIuR3JvdXBcbiAgICAgIG5hbWU6ICdzaGFkb3dzJ1xuICAgIEBfZW50aXR5R3JvdXAgPSBuZXcgcGFwZXIuR3JvdXBcbiAgICAgIG5hbWU6ICdlbnRpdGllcydcblxuICAgIEBfYmFja2dyb3VuZEdyb3VwID0gQF9tYWtlQmFja2dyb3VuZCBwYXBlciwgcGFwZXIudmlldy5jZW50ZXIubXVsdGlwbHkgMC41XG4gICAgQF93b3JsZEdyb3VwID0gbmV3IHBhcGVyLkdyb3VwXG4gICAgICBuYW1lOiAnd29ybGQnXG4gICAgICBjaGlsZHJlbjogW0BfYmFja2dyb3VuZEdyb3VwLCBAX3NoYWRvd0dyb3VwLCBAX2VudGl0eUdyb3VwXVxuXG4gICAgdG9vbCA9IG5ldyBwYXBlci5Ub29sKClcbiAgICBAX3NldHVwQWRkRW50aXR5VG9vbCB0b29sLCBwYXBlclxuICAgIEBfc2V0dXBTZWxlY3Rpb25Ub29sIHRvb2wsIHBhcGVyXG5cbiAgICBzY29wZSA9IHRoaXNcbiAgICBzZXR1cENhbWVyYVRvb2wgcGFwZXIsIHRvb2wsIHBhcGVyLnZpZXcuZWxlbWVudCxcbiAgICAgIG9uVHJhbnNmb3JtOiAoKSAtPlxuICAgICAgICBzY29wZS5kaXNwYXRjaCAnZGlkVmlld3BvcnRUcmFuc2Zvcm0nLFxuICAgICAgICAgIHZpZXdwb3J0OiBwYXBlci52aWV3XG4gICAgQGRpc3BhdGNoICdkaWRWaWV3cG9ydFRyYW5zZm9ybScsXG4gICAgICB2aWV3cG9ydDogcGFwZXIudmlld1xuXG4gICAgQGRpc3BhdGNoICdzZXR1cEluc3BlY3RvcicsXG4gICAgICBwYXBlcjogcGFwZXJcblxuXG4gIF9mZXRjaFN0YXRlOiAoKSAtPlxuICAgIHdvcmxkOiBXb3JsZFN0b3JlLmdldEFsbCgpXG4gICAgdXNlcjogVXNlclN0b3JlLmdldEFsbCgpXG5cbiAgX29uQ2hhbmdlOiAoKSA9PlxuICAgIEBzdGF0ZSA9IEBfZmV0Y2hTdGF0ZSgpXG4gICAgQHVwZGF0ZSBAc3RhdGVcblxuXG4gICMjIyBEUkFXSU5HICMjI1xuXG4gIF9tYWtlRW50aXR5R3JhcGhpYzogKHBhcGVyLCBlbnRpdHkpIC0+XG4gICAgcGF0aCA9IEBfbWFrZVBhcGVyRW50aXR5IHBhcGVyLCBlbnRpdHkuaWQsIGVudGl0eS5wb3NpdGlvblxuICAgIHNoYWRvdyA9IEBfbWFrZVNoYWRvdyBwYXBlciwgcGF0aFxuXG4gICAgZGF0YSA9XG4gICAgICBlbnRpdHlJZDogZW50aXR5LmlkXG5cbiAgICBwYXRoLmRhdGEgPSBzaGFkb3cuZGF0YSA9IGRhdGFcbiAgICBwYXRoLm5hbWUgPSBzaGFkb3cubmFtZSA9IGVudGl0eS5pZFxuXG4gICAgQF9lbnRpdHlHcm91cC5hZGRDaGlsZCBwYXRoXG4gICAgQF9zaGFkb3dHcm91cC5hZGRDaGlsZCBzaGFkb3dcblxuICAgIHBhdGg6IHBhdGhcbiAgICBzaGFkb3c6IHNoYWRvd1xuXG5cbiAgX21ha2VQYXBlckVudGl0eTogKHBhcGVyLCBpZCwgcG9zaXRpb24pIC0+XG4gICAgaWYgbm90IHBvc2l0aW9uP1xuICAgICAgcG9zaXRpb24gPSBwYXBlci52aWV3LmNlbnRlclxuXG4gICAgaXRlbSA9IG1ha2VSYW5kb21QYXRoIHBhcGVyLFxuICAgICAgbGVmdDogMFxuICAgICAgdG9wOiAwXG4gICAgICB3aWR0aDogTWF0aC5yYW5kb20oKSAqIDQ1MCArIDUwXG4gICAgICBoZWlnaHQ6IE1hdGgucmFuZG9tKCkgKiA0NTAgKyA1MFxuICAgIGl0ZW0ucG9zaXRpb24gPSBwb3NpdGlvblxuICAgIGl0ZW0uZmlsbENvbG9yID1cbiAgICAgIGdyYWRpZW50OlxuICAgICAgICBzdG9wczogWyByYW5kb21Db2xvciB7YnJpZ2h0bmVzczogMC44fVxuICAgICAgICAgICAgICAgICByYW5kb21Db2xvciB7YnJpZ2h0bmVzczogMC44fSBdXG4gICAgICBvcmlnaW46IGl0ZW0uYm91bmRzLnRvcExlZnRcbiAgICAgIGRlc3RpbmF0aW9uOiBpdGVtLmJvdW5kcy5ib3R0b21SaWdodFxuXG4gICAgcmV0dXJuIGl0ZW1cblxuICBfbWFrZVNoYWRvdzogKHBhcGVyLCBwYXRoKSAtPlxuICAgIHIgPSBwYXRoLmNsb25lKClcbiAgICByLmZpbGxDb2xvciA9ICdibGFjaydcbiAgICByLm9wYWNpdHkgPSAwLjZcbiAgICByLnRyYW5zbGF0ZSBbMzAsIDMwXVxuICAgIHJldHVybiByXG5cbiAgX21ha2VCYWNrZ3JvdW5kOiAocGFwZXIsIGluaXRpYWxQb3NpdGlvbikgLT5cbiAgICBiYWNrZ3JvdW5kR3JvdXAgPSBuZXcgcGFwZXIuR3JvdXBcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kJ1xuICAgICAgcG9zaXRpb246IGluaXRpYWxQb3NpdGlvblxuICAgIGJhY2tncm91bmRHcm91cC5zZW5kVG9CYWNrKClcblxuICAgIGJsb2JQcm90byA9IEBfbWFrZUJhY2tncm91bmRCbG9iIHBhcGVyLCBbMCwgMF1cbiAgICBiYWNrZ3JvdW5kR3JvdXAuYWRkQ2hpbGQgYmxvYlByb3RvXG5cbiAgICBvdXRlckNvbG9yID0gbmV3IHBhcGVyLkNvbG9yIDAsIDBcbiAgICBiYWNrZ3JvdW5kU2hhcGVzID1cbiAgICAgICMgWy0xMC4uLjEwXVxuICAgICAgWy0xLi4xXVxuICAgICAgICAubWFwICh4KSAtPlxuICAgICAgICAgIFstMS4uMV0ubWFwICh5KSAtPiBuZXcgcGFwZXIuUG9pbnQgeCwgeVxuICAgICAgICAucmVkdWNlIChhY2MsIGVsbSkgLT4gYWNjLmNvbmNhdCBlbG1cbiAgICAgICAgLm1hcCAoY29vcmRpbmF0ZSkgPT5cbiAgICAgICAgICBjbG9uZSA9IGJsb2JQcm90by5jbG9uZSgpXG4gICAgICAgICAgY2xvbmUucG9zaXRpb24gPSBjb29yZGluYXRlLm11bHRpcGx5IFs4MDAsIDgwMF1cbiAgICAgICAgICBjbG9uZS5wb3NpdGlvbiA9IGNsb25lLnBvc2l0aW9uLmFkZCBbIE1hdGgucmFuZG9tKCkgKiA0MDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiA0MDAgXVxuXG4gICAgICAgICAgaHVlcyA9IFtcbiAgICAgICAgICAgIDVcbiAgICAgICAgICAgIDE4N1xuICAgICAgICAgIF1cblxuICAgICAgICAgIGlubmVyQ29sb3IgPSBuZXcgcGFwZXIuQ29sb3JcbiAgICAgICAgICAgIGh1ZTogaHVlc1tNYXRoLmZsb29yIChNYXRoLnJhbmRvbSgpICogaHVlcy5sZW5ndGgpXVxuICAgICAgICAgICAgc2F0dXJhdGlvbjogMC4zXG4gICAgICAgICAgICBicmlnaHRuZXNzOiAwLjRcbiAgICAgICAgICBvdXRlckNvbG9yID0gcmFuZG9tQ29sb3Ige3NhdHVyYXRpb246IDAuMywgYnJpZ2h0bmVzczogMC4zfVxuICAgICAgICAgIG91dGVyQ29sb3IuYWxwaGEgPSAwXG4gICAgICAgICAgY2xvbmUuZmlsbENvbG9yID1cbiAgICAgICAgICAgIGdyYWRpZW50OlxuICAgICAgICAgICAgICBzdG9wczogW2lubmVyQ29sb3IsIG91dGVyQ29sb3JdXG4gICAgICAgICAgICAgIHJhZGlhbDogdHJ1ZVxuICAgICAgICAgICAgb3JpZ2luOiBjbG9uZS5ib3VuZHMuY2VudGVyXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogY2xvbmUuYm91bmRzLnJpZ2h0Q2VudGVyXG5cbiAgICAgICAgICByZXR1cm4gY2xvbmVcblxuICAgIGNsb25lR3JvdXAgPSBuZXcgcGFwZXIuR3JvdXAgYmFja2dyb3VuZFNoYXBlc1xuICAgIHRpbGVkQmcgPSBuZXcgSW5maW5pdGVUaWxlZEl0ZW0gcGFwZXIsIGNsb25lR3JvdXAsXG4gICAgICBvdmVybGFwOiBuZXcgcGFwZXIuUG9pbnQgLTAuNSwgLTAuNVxuICAgIHRpbGVkQmcubmFtZSA9ICd0aWxlZEJnJ1xuICAgIGJhY2tncm91bmRHcm91cC5hZGRDaGlsZCB0aWxlZEJnXG4gICAgdXBkYXRlVE4gPSAoKSAtPiB0aWxlZEJnLnNldFZpZXdCb3VuZHMgcGFwZXIudmlldy5ib3VuZHNcbiAgICBAX29uVmlld3BvcnRUcmFuc2Zvcm0ucHVzaCB1cGRhdGVUTlxuICAgIGRvIHVwZGF0ZVROXG5cbiAgICByYXN0ZXJVcmwgPSAnaHR0cDovL3d3dy5uZWlsYmxldmlucy5jb20vY2dfZWR1Y2F0aW9uL3Byb2NlZHVyYWxfbm9pc2UvcGVybGluX2ZyYWN0YWxfbWF4LmpwZydcbiAgICBub2lzZSA9IG5ldyBwYXBlci5SYXN0ZXIgcmFzdGVyVXJsXG4gICAgbm9pc2Uub3BhY2l0eSA9IDAuMlxuICAgIG5vaXNlLmJsZW5kTW9kZSA9ICdtdWx0aXBseSdcbiAgICBub2lzZS5vbkxvYWQgPSAoKSA9PlxuICAgICAgdGlsZWROb2lzZSA9IG5ldyBJbmZpbml0ZVRpbGVkSXRlbSBwYXBlciwgbm9pc2VcbiAgICAgIHRpbGVkTm9pc2UubmFtZSA9ICd0aWxlZE5vaXNlJ1xuICAgICAgYmFja2dyb3VuZEdyb3VwLmFkZENoaWxkIHRpbGVkTm9pc2VcbiAgICAgIHVwZGF0ZVROID0gKCkgLT4gdGlsZWROb2lzZS5zZXRWaWV3Qm91bmRzIHBhcGVyLnZpZXcuYm91bmRzXG4gICAgICBAX29uVmlld3BvcnRUcmFuc2Zvcm0ucHVzaCB1cGRhdGVUTlxuICAgICAgZG8gdXBkYXRlVE5cblxuXG4gICAgcmV0dXJuIGJhY2tncm91bmRHcm91cFxuXG5cbiAgX21ha2VCYWNrZ3JvdW5kQmxvYjogKHBhcGVyLCBwb3NpdGlvbikgLT5cbiAgICBzaXplID0gMTAwMFxuICAgIG91dGVyQ29sb3IgPSBuZXcgcGFwZXIuQ29sb3IgMCwgMFxuXG4gICAgcG9zaXRpb24gPSAobmV3IHBhcGVyLlBvaW50IE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpLmFkZCBwb3NpdGlvblxuXG4gICAgciA9IG5ldyBwYXBlci5QYXRoLkNpcmNsZVxuICAgICAgY2VudGVyOiBwb3NpdGlvbi5tdWx0aXBseSAoc2l6ZSAvIDIpXG4gICAgICByYWRpdXM6IHNpemVcbiAgICByLmZpbGxDb2xvciA9XG4gICAgICBncmFkaWVudDpcbiAgICAgICAgc3RvcHM6IFsocmFuZG9tQ29sb3Ige3NhdHVyYXRpb246IDAuNSwgYnJpZ2h0bmVzczogMC42fSksIG91dGVyQ29sb3JdXG4gICAgICAgIHJhZGlhbDogdHJ1ZVxuICAgICAgb3JpZ2luOiByLmJvdW5kcy5jZW50ZXJcbiAgICAgIGRlc3RpbmF0aW9uOiByLmJvdW5kcy5yaWdodENlbnRlclxuICAgIHIuYmxlbmRNb2RlID0gJ25vcm1hbCdcbiAgICByZXR1cm4gclxuXG5cbiAgIyMjIFRPT0xTICMjI1xuXG4gIF9zZXR1cEFkZEVudGl0eVRvb2w6ICh0b29sLCBwYXBlcikgLT5cbiAgICB0b29sLm9uICdtb3VzZWRvd24nLCAoZXZ0KSA9PlxuICAgICAgaWYgcGFwZXIuS2V5LmlzRG93biAnc2hpZnQnXG4gICAgICAgIEBkaXNwYXRjaCAnd2FudHNBZGRFbnRpdHknLFxuICAgICAgICAgIHBvc2l0aW9uOiBldnQuZG93blBvaW50XG5cblxuICBfc2V0dXBTZWxlY3Rpb25Ub29sOiAodG9vbCwgcGFwZXIpIC0+XG4gICAgaGl0T3B0aW9ucyA9XG4gICAgICBzZWdtZW50czogdHJ1ZVxuICAgICAgc3Ryb2tlOiB0cnVlXG4gICAgICBmaWxsOiB0cnVlXG4gICAgICB0b2xlcmFuY2U6IDVcbiAgICBsYXN0SGl0ID0gbnVsbFxuXG4gICAgdG9vbC5vbk1vdXNlTW92ZSA9IChldnQpID0+XG4gICAgICBoaXRSZXN1bHRzID0gQF9lbnRpdHlHcm91cC5oaXRUZXN0IGV2dC5wb2ludCwgaGl0T3B0aW9uc1xuICAgICAgaGl0ID0gaWYgaGl0UmVzdWx0cz8gdGhlbiBoaXRSZXN1bHRzLml0ZW0uZGF0YS5lbnRpdHlJZCBlbHNlIG51bGxcblxuICAgICAgaWYgaGl0IGlzbnQgbGFzdEhpdFxuICAgICAgICBpZiBsYXN0SGl0P1xuICAgICAgICAgIEBfaGFuZGxlTW91c2VIb3ZlckVudGl0eSBsYXN0SGl0LCAnZXhpdCdcbiAgICAgICAgaWYgaGl0P1xuICAgICAgICAgIEBfaGFuZGxlTW91c2VIb3ZlckVudGl0eSBoaXQsICdlbnRlcidcbiAgICAgIEBfaGFuZGxlTW91c2VIb3ZlckVudGl0eSBoaXQsICdvdmVyJ1xuICAgICAgbGFzdEhpdCA9IGhpdFxuXG4gICAgdG9vbC5vbiAnbW91c2V1cCcsIChldnQpID0+XG4gICAgICBpZiBsYXN0SGl0P1xuICAgICAgICBAZGlzcGF0Y2ggJ3dhbnRzRWRpdEVudGl0eScsXG4gICAgICAgICAgaWQ6IGxhc3RIaXRcbiAgICAgICAgQF9oYW5kbGVNb3VzZUhvdmVyRW50aXR5IGxhc3RIaXQsICd1cCdcblxuICAgIHRvb2wub24gJ21vdXNlZG93bicsIChldnQpID0+XG4gICAgICBpZiBub3QgbGFzdEhpdD8gYW5kIChub3QgcGFwZXIuS2V5LmlzRG93biAnc2hpZnQnKVxuICAgICAgICBAZGlzcGF0Y2ggJ3dhbnRzQ2FuY2VsRWRpdEVudGl0eSdcblxuICBfaGFuZGxlTW91c2VIb3ZlckVudGl0eTogZG8gLT5cbiAgICByZXNldCA9IG51bGxcbiAgICByZXR1cm4gKGVudGl0eUlkLCBzdGF0ZSkgLT5cbiAgICAgIGVudGl0eSA9XG4gICAgICAgIHBhdGg6IEBfZW50aXR5R3JvdXAuY2hpbGRyZW5bZW50aXR5SWRdXG4gICAgICAgIHNoYWRvdzogQF9lbnRpdHlHcm91cC5jaGlsZHJlbltlbnRpdHlJZF1cblxuICAgICAgc3dpdGNoIHN0YXRlXG4gICAgICAgIHdoZW4gJ2VudGVyJ1xuICAgICAgICAgIGlmIHJlc2V0P1xuICAgICAgICAgICAgZG8gcmVzZXRcblxuICAgICAgICAgIHNldFN0cm9rZVdpZHRoID0gKCkgPT5cbiAgICAgICAgICAgIGVudGl0eS5wYXRoLnN0cm9rZVdpZHRoID0gMyAqIDEgLyBAcGFwZXIudmlldy56b29tXG4gICAgICAgICAgIyBAX2ZpeGVkRWx0VXBkYXRlc1tlbnRpdHkuaWRdID0gc2V0U3Ryb2tlV2lkdGhcblxuICAgICAgICAgIG9sZENvbG9yID0gZW50aXR5LnBhdGguc3Ryb2tlQ29sb3JcbiAgICAgICAgICBvbGRXaWR0aCA9IGVudGl0eS5wYXRoLnN0cm9rZVdpZHRoXG5cbiAgICAgICAgICByZXNldCA9ICgpID0+XG4gICAgICAgICAgICBlbnRpdHkucGF0aC5zdHJva2VDb2xvciA9IG9sZENvbG9yXG4gICAgICAgICAgICBlbnRpdHkucGF0aC5zdHJva2VXaWR0aCA9IG9sZFdpZHRoXG4gICAgICAgICAgICAjIGRlbGV0ZSBAX2ZpeGVkRWx0VXBkYXRlc1tlbnRpdHkuaWRdXG5cbiAgICAgICAgICBlbnRpdHkucGF0aC5zdHJva2VDb2xvciA9ICcjNDE4MUZGJ1xuICAgICAgICAgIGRvIHNldFN0cm9rZVdpZHRoXG5cbiAgICAgICAgd2hlbiAnZXhpdCdcbiAgICAgICAgICBpZiByZXNldD9cbiAgICAgICAgICAgIGRvIHJlc2V0XG5cbiAgICAgICAgd2hlbiAndXAnXG4gICAgICAgICAgaWYgcmVzZXQ/XG4gICAgICAgICAgICBkbyByZXNldFxuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkQ29udHJvbGxlciIsIntFdmVudEVtaXR0ZXJ9ID0gcmVxdWlyZSAnZXZlbnRzJ1xuXyA9IHJlcXVpcmUgJ2xvZGFzaCdcblxuIyMjXG5BYnN0cmFjdCBjbGFzcyBmb3IgaW5zcGVjdG9ycy5cbiMjI1xuY2xhc3MgSW5zcGVjdG9yQmFzZSBleHRlbmRzIEV2ZW50RW1pdHRlclxuICBjb25zdHJ1Y3RvcjogKHBhcmFtZXRlckNhbGxiYWNrcyA9IHt9KSAtPlxuICAgIEBfcGFyYW1ldGVyQ2FsbGJhY2tzID0gcGFyYW1ldGVyQ2FsbGJhY2tzXG4gICAgQF9mZWVkYmFja1BhcmFtZXRlcnMgPSBfLm1hcFZhbHVlcyBAZGVmYXVsdEZlZWRiYWNrVmFsdWVzKCksICh2YWx1ZSwga2V5KSAtPlxuICAgICAgY2FsbGJhY2tzOiBbXVxuICAgICAgdmFsdWU6IHZhbHVlXG5cblxuICAjIyBEcmF3aW5nXG5cbiAgZHJhdzogKHBhcGVyLCBzaXplKSAtPlxuXG4gIHJlbW92ZTogKCkgLT5cblxuICAjIyBQYXJhbWV0ZXJzXG5cbiAgcGFyYW1ldGVyTGlzdDogKCkgLT5cbiAgICBjb25zb2xlLndhcm4gJ0luc3BlY3RvciBuZWVkcyB0byBvdmVycmlkZSBgcGFyYW1ldGVyTGlzdCgpYC4nXG5cbiAgbWFwUGFyYW1ldGVyOiAocGFyYW1OYW1lLCBnZXRGbiwgc2V0Rm4pIC0+XG4gICAgQF9wYXJhbWV0ZXJDYWxsYmFja3NbcGFyYW1OYW1lXSA9XG4gICAgICBnZXRGbjogZ2V0Rm5cbiAgICAgIHNldEZuOiBzZXRGblxuXG4gIGdldFBhcmFtZXRlcjogKHBhcmFtTmFtZSkgLT5cbiAgICBjYWxsYmFja3MgPSBAX3BhcmFtZXRlckNhbGxiYWNrc1twYXJhbU5hbWVdXG5cbiAgICBpZiBjYWxsYmFja3M/LmdldEZuP1xuICAgIHRoZW4gY2FsbGJhY2tzLmdldEZuKClcbiAgICBlbHNlIHVuZGVmaW5lZFxuXG4gIHNldFBhcmFtZXRlcjogKHBhcmFtTmFtZSwgdmFsdWUpIC0+XG4gICAgY2FsbGJhY2tzID0gQF9wYXJhbWV0ZXJDYWxsYmFja3NbcGFyYW1OYW1lXVxuXG4gICAgaWYgY2FsbGJhY2tzPy5zZXRGbj9cbiAgICAgIGNhbGxiYWNrcy5zZXRGbiB2YWx1ZVxuICAgICAgQGVtaXQgXCIje3BhcmFtTmFtZX1DaGFuZ2VkXCIsIHZhbHVlXG4gICAgZWxzZSB1bmRlZmluZWRcblxuICBhZGRQYXJhbWV0ZXJMaXN0ZW5lcjogKHBhcmFtTmFtZSwgY2FsbGJhY2spIC0+XG4gICAgQG9uIFwiI3twYXJhbU5hbWV9Q2hhbmdlZFwiLCBjYWxsYmFja1xuXG4gIHJlbW92ZVBhcmFtZXRlckxpc3RlbmVyOiAocGFyYW1OYW1lLCBjYWxsYmFjaykgLT5cbiAgICBAcmVtb3ZlTGlzdGVuZXIgXCIje3BhcmFtTmFtZX1DaGFuZ2VkXCIsIGNhbGxiYWNrXG5cblxuICAjIyBWaXN1YWwgZmVlZGJhY2tcblxuICAjIERlZmluZSBkZWZhdWx0IHZhbHVlcyBmb3IgZmVlZGJhY2sgcGFyYW1ldGVycy5cbiAgIyBAcmV0dXJucyB7PHBhcmFtTmFtZT46IDx2YWx1ZSA6IEZsb2F0Pn1cbiAgZGVmYXVsdEZlZWRiYWNrVmFsdWVzOiAoKSAtPlxuICAgIGNvbnNvbGUud2FybiAnSW5zcGVjdG9yIG5lZWRzIHRvIG92ZXJyaWRlIGBkZWZhdWx0RmVlZGJhY2tWYWx1ZXMoKWAuJ1xuICAgIHt9XG5cblxuICByZWZyZXNoRmVlZGJhY2tQYXJhbWV0ZXJzOiAoKSAtPlxuICAgIE9iamVjdC5rZXlzIEBfZmVlZGJhY2tQYXJhbWV0ZXJzXG4gICAgICAuZm9yRWFjaCAocGFyYW1OYW1lKSA9PlxuICAgICAgICBAc2V0RmVlZGJhY2tQYXJhbWV0ZXIgcGFyYW1OYW1lLCBAX2ZlZWRiYWNrUGFyYW1ldGVyc1twYXJhbU5hbWVdLnZhbHVlXG5cbiAgIyBVcGRhdGVzIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyLiBUcmlnZ2VycyBhbGwgZmVlZGJhY2sgbGlzdGVuZXJzIG9uIHRoYXRcbiAgIyAgIHBhcmFtZXRlci5cbiAgc2V0RmVlZGJhY2tQYXJhbWV0ZXIgOiAocGFyYW1OYW1lLCB2YWx1ZSkgLT5cbiAgICBkZWx0YSA9IHZhbHVlIC0gQF9mZWVkYmFja1BhcmFtZXRlcnNbcGFyYW1OYW1lXS52YWx1ZVxuICAgIEBfZmVlZGJhY2tQYXJhbWV0ZXJzW3BhcmFtTmFtZV0udmFsdWUgPSB2YWx1ZVxuICAgIEBlbWl0IFwiI3twYXJhbU5hbWV9Q2hhbmdlZEZlZWRiYWNrXCIsIHZhbHVlLCBkZWx0YVxuXG4gIGdldEZlZWRiYWNrUGFyYW1ldGVyOiAocGFyYW1OYW1lKSAtPlxuICAgIEBfZmVlZGJhY2tQYXJhbWV0ZXJzW3BhcmFtTmFtZV0udmFsdWVcblxuICAjIHVzZWQgaW50ZXJuYWxseSB0byBsaW5rIGEgZmVlZGJhY2sgcGFyYW1ldGVyIHRvIGEgdmlld1xuICBfYWRkRmVlZGJhY2tMaXN0ZW5lcjogKHBhcmFtTmFtZSwgY2FsbGJhY2ssIGFmdGVySW50ZXJhY3Rpb25DYWxsYmFjaykgLT5cbiAgICBhZnRlckludGVyYWN0aW9uQ2FsbGJhY2tJZCA9IG51bGxcblxuICAgIEBvbiBcIiN7cGFyYW1OYW1lfUNoYW5nZWRGZWVkYmFja1wiLCAoKSAtPlxuICAgICAgYXJncyA9IGFyZ3VtZW50c1xuICAgICAgaWYgYWZ0ZXJJbnRlcmFjdGlvbkNhbGxiYWNrP1xuICAgICAgICBpZiBhZnRlckludGVyYWN0aW9uQ2FsbGJhY2tJZD9cbiAgICAgICAgICBjbGVhclRpbWVvdXQgYWZ0ZXJJbnRlcmFjdGlvbkNhbGxiYWNrSWRcbiAgICAgICAgICBhZnRlckludGVyYWN0aW9uQ2FsbGJhY2tJZCA9IG51bGxcbiAgICAgICAgYWZ0ZXJJbnRlcmFjdGlvbkNhbGxiYWNrSWQgPVxuICAgICAgICAgIHNldFRpbWVvdXQgKCgpIC0+IGFmdGVySW50ZXJhY3Rpb25DYWxsYmFjayBhcmdzLi4uKSwgMTAwXG4gICAgICBjYWxsYmFjayBhcmdzLi4uXG4gICAgIyBUT0RPOiBtYWtlIHN1cmUgdGhlc2UgZG9uJ3QgbGVha1xuICAgIEBfZmVlZGJhY2tQYXJhbWV0ZXJzW3BhcmFtTmFtZV0uY2FsbGJhY2tzLnB1c2ggY2FsbGJhY2tcblxuICBfcmVtb3ZlRmVlZGJhY2tMaXN0ZW5lcjogKHBhcmFtTmFtZSwgY2FsbGJhY2spIC0+XG4gICAgQHJlbW92ZUxpc3RlbmVyIFwiI3twYXJhbU5hbWV9Q2hhbmdlZEZlZWRiYWNrXCIsIGNhbGxiYWNrXG5cbiAgX3JlbW92ZUFsbEZlZWRiYWNrTGlzdGVuZXJzOiAoKSAtPlxuICAgIChPYmplY3Qua2V5cyBAX2ZlZWRiYWNrUGFyYW1ldGVycykuZm9yRWFjaCAocGFyYW1OYW1lKSA9PlxuICAgICAgQF9mZWVkYmFja1BhcmFtZXRlcnNbcGFyYW1OYW1lXS5jYWxsYmFja3MuZm9yRWFjaCAoY2FsbGJhY2spID0+XG4gICAgICAgIEBfcmVtb3ZlRmVlZGJhY2tMaXN0ZW5lciBwYXJhbU5hbWUsIGNhbGxiYWNrXG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEluc3BlY3RvckJhc2UiLCJJbnNwZWN0b3JCYXNlID0gcmVxdWlyZSAnLi9JbnNwZWN0b3JCYXNlJ1xuXG5jbGFzcyBSZWRJbnNwZWN0b3IgZXh0ZW5kcyBJbnNwZWN0b3JCYXNlXG4gIGNvbnN0cnVjdG9yOiAoQGVudGl0eSwgcGFyYW1ldGVyQ2FsbGJhY2tzKSAtPlxuICAgIHN1cGVyIHBhcmFtZXRlckNhbGxiYWNrc1xuXG4gICAgIyBob2xkcyBhbGwgcmVzdWx0cyBvZiBjYWxsaW5nIGBkcmF3KClgXG4gICAgQF9nZnhJbnN0YW5jZXMgPSBbXVxuXG4gIHBhcmFtZXRlckxpc3Q6ICgpIC0+XG4gICAgcmV0dXJuIFsgJ2JhY2tncm91bmRYJ1xuICAgICAgICAgICAgICdiYWNrZ3JvdW5kWSdcbiAgICAgICAgICAgICAnc2NydWJiZXJYJ1xuICAgICAgICAgICAgICdzY3J1YmJlclknIF1cblxuICBmZWVkYmFja1BhcmFtZXRlckxpc3Q6ICgpIC0+IFsgJ3NjcnViYmVySGVpZ2h0JyBdXG5cbiAgIyBNYWtlIGEgbmV3IFBhcGVyLmpzIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgaW5zcGVjdG9yLlxuICBkcmF3OiAocGFwZXIsIHNpemUpIC0+XG4gICAgcmF0aW8gPSAxLjc3XG5cbiAgICBwcmV0dHlTaXplID0gbmV3IHBhcGVyLlNpemUgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQgLyByYXRpb1xuICAgIGlmIHByZXR0eVNpemUuaGVpZ2h0ID4gc2l6ZS5oZWlnaHRcbiAgICAgIHByZXR0eVNpemUgPSBuZXcgcGFwZXIuU2l6ZSBzaXplLmhlaWdodCAqIHJhdGlvLCBzaXplLmhlaWdodFxuXG4gICAgdG9wTGVmdCA9IChuZXcgcGFwZXIuUG9pbnQgcHJldHR5U2l6ZSkubmVnYXRlKCkubXVsdGlwbHkgMC41XG4gICAgYm91bmRzID0gbmV3IHBhcGVyLlJlY3RhbmdsZSB0b3BMZWZ0LCBwcmV0dHlTaXplXG5cbiAgICByZXN1bHQgPSBuZXcgcGFwZXIuR3JvdXBcbiAgICAgIGNoaWxkcmVuOiBbIEBfY3JlYXRlQmFja2dyb3VuZCBwYXBlciwgYm91bmRzLCBAZW50aXR5XG4gICAgICAgICAgICAgICAgICBAX2NyZWF0ZVNjcnViYmVyIHBhcGVyLCBib3VuZHMsIEBlbnRpdHlcbiAgICAgICAgICAgICAgICAgIEBfY3JlYXRlRW50aXR5IHBhcGVyLCBib3VuZHMsIEBlbnRpdHkgXVxuXG4gICAgQF9zZXR1cEludGVyYWN0aW9uIHBhcGVyLCByZXN1bHRcblxuICAgIEBfZ2Z4SW5zdGFuY2VzLnB1c2ggcmVzdWx0XG5cbiAgICBAcmVmcmVzaEZlZWRiYWNrUGFyYW1ldGVycygpXG5cbiAgICByZXR1cm4gcmVzdWx0XG5cbiAgIyBSZW1vdmUgYWxsIFBhcGVyLmpzIHJlcHJlc2VudGF0aW9ucyBmcm9tIHRoZWlyIHJlc3BlY3RpdmUgcHJvamVjdHMuXG4gIHJlbW92ZTogKCkgLT5cbiAgICBAX2dmeEluc3RhbmNlcy5mb3JFYWNoIChpbnN0KSAtPiBpbnN0LnJlbW92ZSgpXG4gICAgQF9nZnhJbnN0YW5jZXMgPSBbXVxuXG4gICAgQF9kZXN0cm95SW50ZXJhY3Rpb24oKVxuICAgIEBfcmVtb3ZlQWxsRmVlZGJhY2tMaXN0ZW5lcnMoKVxuXG5cbiAgZGVmYXVsdEZlZWRiYWNrVmFsdWVzOiAoKSAtPlxuICAgICdzY3J1YmJlckhlaWdodCc6IDAuMlxuICAgICdwbGF5aGVhZFBvc2l0aW9uJzogMC41XG4gICAgJ2l0ZW1BZ2l0YXRpb24nOiAwLjVcbiAgICAnaHVlJzogMFxuICAgICdsaWdodG5lc3MnOiAwLjYyXG5cblxuXG4gIF9jcmVhdGVCYWNrZ3JvdW5kOiAocGFwZXIsIGJvdW5kcywgZW50aXR5KSAtPlxuICAgIHJlY3QgPSBuZXcgcGFwZXIuUGF0aC5SZWN0YW5nbGVcbiAgICAgIG5hbWU6ICdyZWRJbnNwZWN0b3JCRydcbiAgICAgIHNpemU6IGJvdW5kcy5zaXplXG4gICAgICBmaWxsQ29sb3I6IG5ldyBwYXBlci5Db2xvclxuICAgICAgICBodWU6IEBnZXRGZWVkYmFja1BhcmFtZXRlciAnaHVlJ1xuICAgICAgICBzYXR1cmF0aW9uOiAwLjgxXG4gICAgICAgIGxpZ2h0bmVzczogQGdldEZlZWRiYWNrUGFyYW1ldGVyICdsaWdodG5lc3MnXG4gICAgcmVjdC5wb3NpdGlvbiA9IFswLCAwXVxuXG4gICAgcmVjdC5kYXRhLm9uTW91c2V3aGVlbCA9IChldnQpID0+XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgIG51ZGdlQW1vdW50WCA9IC1ldnQuZGVsdGFYIC8gMTAwXG4gICAgICBvbGRWYWx1ZVggPSBAZ2V0UGFyYW1ldGVyICdiYWNrZ3JvdW5kWCdcbiAgICAgIEBzZXRQYXJhbWV0ZXIgJ2JhY2tncm91bmRYJywgb2xkVmFsdWVYICsgbnVkZ2VBbW91bnRYXG5cbiAgICAgIG51ZGdlQW1vdW50WSA9IGV2dC5kZWx0YVkgLyAxMDBcbiAgICAgIG9sZFZhbHVlWSA9IEBnZXRQYXJhbWV0ZXIgJ2JhY2tncm91bmRZJ1xuICAgICAgQHNldFBhcmFtZXRlciAnYmFja2dyb3VuZFknLCBvbGRWYWx1ZVkgKyBudWRnZUFtb3VudFlcblxuICAgIHJlY3Qub24gJ2ZyYW1lJywgKCkgPT5cbiAgICAgIHJlY3QuZmlsbENvbG9yLmh1ZSA9IChAZ2V0RmVlZGJhY2tQYXJhbWV0ZXIgJ2h1ZScpICogMzYwXG4gICAgICByZWN0LmZpbGxDb2xvci5saWdodG5lc3MgPSAoQGdldEZlZWRiYWNrUGFyYW1ldGVyICdsaWdodG5lc3MnKVxuICAgICAgcGFwZXIudmlldy5kcmF3KClcblxuICAgIHJldHVybiByZWN0XG5cbiAgX2NyZWF0ZVNjcnViYmVyOiAocGFwZXIsIGJvdW5kcywgZW50aXR5KSAtPlxuICAgIHNjcnViYmVyR3JvdXAgPSBuZXcgcGFwZXIuR3JvdXAoKVxuXG4gICAgc2NydWJiZXIgPSBuZXcgcGFwZXIuUGF0aC5SZWN0YW5nbGVcbiAgICAgIHBvaW50OiBib3VuZHMudG9wTGVmdFxuICAgICAgc2l6ZTogW2JvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodF1cbiAgICBzY3J1YmJlckdyb3VwLmFkZENoaWxkIHNjcnViYmVyXG5cbiAgICBzY3J1YmJlci5maWxsQ29sb3IgPSAnYmxhY2snXG4gICAgc2NydWJiZXIub3BhY2l0eSA9IDAuMlxuICAgIHNjcnViYmVyLm5hbWUgPSAnc2NydWJiZXInXG5cbiAgICBwbGF5aGVhZCA9IG5ldyBwYXBlci5QYXRoLlJlY3RhbmdsZVxuICAgICAgcG9pbnQ6IHNjcnViYmVyLmJvdW5kcy50b3BMZWZ0XG4gICAgICBzaXplOiBbMSwgc2NydWJiZXIuYm91bmRzLmhlaWdodF1cbiAgICAgIGZpbGxDb2xvcjogJ3doaXRlJ1xuICAgICAgbmFtZTogJ3BsYXloZWFkJ1xuICAgICAgb3BhY2l0eTogMFxuICAgIHNjcnViYmVyR3JvdXAuYWRkQ2hpbGQgcGxheWhlYWRcblxuICAgIGluaXRpYWxIZWlnaHQgPSBzY3J1YmJlci5ib3VuZHMuc2l6ZS5oZWlnaHQgKiAwLjhcbiAgICBAX2FkZEZlZWRiYWNrTGlzdGVuZXIgJ3NjcnViYmVySGVpZ2h0JywgKHZhbCwgZGVsdGEpIC0+XG4gICAgICBjb29rZWQgPSB2YWwgKiAwLjggKyAwLjJcbiAgICAgIHRhcmdldEhlaWdodCA9IGNvb2tlZCAqIGluaXRpYWxIZWlnaHRcbiAgICAgIHNjYWxlUmF0aW8gPSB0YXJnZXRIZWlnaHQgLyBzY3J1YmJlci5ib3VuZHMuc2l6ZS5oZWlnaHRcbiAgICAgIHNjcnViYmVyLnNjYWxlIDEsIHNjYWxlUmF0aW9cblxuICAgICAgcGFwZXIudmlldy5kcmF3KClcblxuICAgICAgZGlzdGFuY2VUb0JvdHRvbSA9IHNjcnViYmVyLnBhcmVudC5wYXJlbnQuYm91bmRzLmJvdHRvbSAtIHNjcnViYmVyLmJvdW5kcy5ib3R0b21cbiAgICAgIHNjcnViYmVyLnRyYW5zbGF0ZSBbMCwgZGlzdGFuY2VUb0JvdHRvbV1cblxuICAgICAgcGFwZXIudmlldy5kcmF3KClcblxuXG4gICAgb25QbGF5aGVhZFBvc2l0aW9uID0gKHZhbCwgZGVsdGEpIC0+XG4gICAgICBwbGF5aGVhZC5wb3NpdGlvbi54ID0gc2NydWJiZXIuYm91bmRzLmxlZnQgKyB2YWwgKiBzY3J1YmJlci5ib3VuZHMud2lkdGhcbiAgICAgIHBsYXloZWFkLm9wYWNpdHkgPSAwLjJcbiAgICAgIHBhcGVyLnZpZXcuZHJhdygpXG5cbiAgICBhZnRlclBsYXloZWFkUG9zaXRpb24gPSAodmFsKSAtPlxuICAgICAgcGxheWhlYWQub3BhY2l0eSA9IDBcbiAgICAgIHBhcGVyLnZpZXcuZWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCdcbiAgICAgIHBhcGVyLnZpZXcuZHJhdygpXG5cbiAgICBAX2FkZEZlZWRiYWNrTGlzdGVuZXIgJ3BsYXloZWFkUG9zaXRpb24nLCBvblBsYXloZWFkUG9zaXRpb24sIGFmdGVyUGxheWhlYWRQb3NpdGlvblxuXG4gICAgZGVsdGEgPSBuZXcgcGFwZXIuUG9pbnQgMCwgMFxuICAgIHNjcnViYmVyLm9uICdmcmFtZScsICgpIC0+XG4gICAgICBzY3J1YmJlci50cmFuc2xhdGUgZGVsdGEubmVnYXRlKClcbiAgICAgIHJhbmdlID0gMlxuICAgICAgZGVsdGEgPSBuZXcgcGFwZXIuUG9pbnQgXFxcbiAgICAgICAgTWF0aC5yYW5kb20oKSAqIHJhbmdlIC0gKHJhbmdlIC8gMiksXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiByYW5nZSAtIChyYW5nZSAvIDIpXG4gICAgICBzY3J1YmJlci50cmFuc2xhdGUgZGVsdGFcblxuXG4gICAgc2NydWJiZXIuZGF0YS5vbk1vdXNld2hlZWwgPSAoZXZ0KSA9PlxuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgICBudWRnZUFtb3VudFggPSAtZXZ0LmRlbHRhWCAvIDEwMFxuICAgICAgb2xkVmFsdWVYID0gQGdldFBhcmFtZXRlciAnc2NydWJiZXJYJ1xuICAgICAgQHNldFBhcmFtZXRlciAnc2NydWJiZXJYJywgb2xkVmFsdWVYICsgbnVkZ2VBbW91bnRYXG5cbiAgICAgIG51ZGdlQW1vdW50WSA9IGV2dC5kZWx0YVkgLyAxMDBcbiAgICAgIG9sZFZhbHVlWSA9IEBnZXRQYXJhbWV0ZXIgJ3NjcnViYmVyWSdcbiAgICAgIEBzZXRQYXJhbWV0ZXIgJ3NjcnViYmVyWScsIG9sZFZhbHVlWSArIG51ZGdlQW1vdW50WVxuXG5cbiAgICByZXR1cm4gc2NydWJiZXJHcm91cFxuXG4gIF9jcmVhdGVFbnRpdHk6IChwYXBlciwgYm91bmRzLCBlbnRpdHkpIC0+XG4gICAgcmVzdWx0ID0gbmV3IHBhcGVyLkdyb3VwKClcblxuICAgIG9yaWdpbmFsID0gZW50aXR5LnBhcGVyLnBhdGhcbiAgICBvcmlnaW5hbFNoYWRvdyA9IGVudGl0eS5wYXBlci5zaGFkb3dcblxuICAgIGNvcHkgPSBlbnRpdHkucGFwZXIucGF0aC5jbG9uZSgpXG4gICAgY29weS5zdHJva2VDb2xvciA9IG51bGxcbiAgICBzaGFkb3dDb3B5ID0gZW50aXR5LnBhcGVyLnNoYWRvdy5jbG9uZSgpXG5cbiAgICBkZWx0YSA9IGNvcHkucG9zaXRpb24ubmVnYXRlKClcbiAgICBjb3B5LnRyYW5zbGF0ZSBkZWx0YVxuICAgIHNoYWRvd0NvcHkudHJhbnNsYXRlIGRlbHRhXG5cbiAgICByZXN1bHQuYWRkQ2hpbGQgc2hhZG93Q29weVxuICAgIHJlc3VsdC5hZGRDaGlsZCBjb3B5XG5cblxuICAgICMgYWdpdGF0aW9uID0gMFxuICAgICMgQF9hZGRGZWVkYmFja0xpc3RlbmVyICdpdGVtQWdpdGF0aW9uJywgKHYpIC0+IGFnaXRhdGlvbiA9IHYgKiA1MFxuICAgICMgcmVzdWx0Lm9uICdmcmFtZScsIChldnQpIC0+XG4gICAgIyAgICMgcmVzdWx0LnJvdGF0ZSBldnQuZGVsdGEgKiBhZ2l0YXRpb25cbiAgICAjICAgb3JpZ2luYWwuc2VnbWVudHMuZm9yRWFjaCAob3JpZ2luYWxTZWdtZW50LCBpZHgpIC0+XG4gICAgIyAgICAgcmFuZG9tUG9pbnQgPSBuZXcgcGFwZXIuUG9pbnQgKE1hdGgucmFuZG9tKCkgLSAwLjUpLFxuICAgICMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChNYXRoLnJhbmRvbSgpIC0gMC41KVxuICAgICMgICAgIGFnaXRhdGlvbkFtb3VudCA9IHJhbmRvbVBvaW50Lm11bHRpcGx5IGFnaXRhdGlvblxuXG4gICAgIyAgICAgY29weS5zZWdtZW50c1tpZHhdLnBvaW50ID1cbiAgICAjICAgICAgIG9yaWdpbmFsU2VnbWVudC5wb2ludC5hZGQgYWdpdGF0aW9uQW1vdW50XG4gICAgIyAgICAgc2hhZG93Q29weS5zZWdtZW50c1tpZHhdLnBvaW50ID1cbiAgICAjICAgICAgIG9yaWdpbmFsU2hhZG93LnNlZ21lbnRzW2lkeF0ucG9pbnQuYWRkIGFnaXRhdGlvbkFtb3VudFxuXG4gICAgcmV0dXJuIHJlc3VsdFxuXG4gIF9zZXR1cEludGVyYWN0aW9uOiAocGFwZXIsIGdyb3VwKSAtPlxuICAgIG9uTW91c2V3aGVlbCA9IEBfb25Nb3VzZXdoZWVsIHBhcGVyLCBncm91cFxuICAgIHBhcGVyLnZpZXcuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyICdtb3VzZXdoZWVsJywgb25Nb3VzZXdoZWVsXG4gICAgQF9kZXN0cm95SW50ZXJhY3Rpb24gPSAoKSAtPlxuICAgICAgcGFwZXIudmlldy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIgJ21vdXNld2hlZWwnLCBvbk1vdXNld2hlZWxcblxuICBfb25Nb3VzZXdoZWVsOiAocGFwZXIsIGdyb3VwKSA9PiAoZXZ0KSA9PlxuICAgIHB0ID0gcGFwZXIudmlldy52aWV3VG9Qcm9qZWN0IFtldnQub2Zmc2V0WCwgZXZ0Lm9mZnNldFldXG4gICAgaGl0UmVzdWx0cyA9IGdyb3VwLmhpdFRlc3QgcHRcbiAgICBpZiBoaXRSZXN1bHRzP1xuICAgICAgaWYgaGl0UmVzdWx0cy5pdGVtLmRhdGEub25Nb3VzZXdoZWVsP1xuICAgICAgICBoaXRSZXN1bHRzLml0ZW0uZGF0YS5vbk1vdXNld2hlZWwgZXZ0XG5cbm1vZHVsZS5leHBvcnRzID0gUmVkSW5zcGVjdG9yIiwiXyA9IHJlcXVpcmUgJ2xvZGFzaCdcblxuIyMjXG5UaGlzIGlzIGN1cnJlbnRseSBtb3JlIGNvbXBsZXggdGhhbiBpdCBuZWVkcyB0byBiZSwgc2luY2UgSSBtaXhlZCB0b2dldGhlclxuY2FtZXJhIGNvbnRyb2wgZm9yIG9wZXJhdGluZyBvbiBncm91cHMgYW5kIHRoZSBtYXN0ZXIgdmlld3BvcnQgaW50byB0aGUgc2FtZVxuZnVuY3Rpb25zLi4uXG5cbkNhbWVyYSBjb250cm9sIG9uIGdyb3VwcyBkaWRuJ3Qgd29yayBvdXQgYXMgcGxhbm5lZCAocHJvYmxlbSB3aXRoIGFkZGluZ1xuY2hpbGRyZW4gYWZ0ZXIgdHJhbnNmb3JtKSwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdGhhdCBwYXJ0IG9mIHRoZSBjb2RlLiBJJ2xsXG5nZXQgcmlkIG9mIGl0IHNvbWV0aW1lLlxuIyMjXG5cblxua0xlZnRNb3VzZUZsYWcgPSAxXG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZXJhQ29udHJvbFRvb2wgPSAocGFwZXIsIHRvb2wsIGNhbnZhcywgb3B0aW9ucykgLT5cbiAgb3B0aW9ucyA9IF8uZGVmYXVsdHMgb3B0aW9ucyxcbiAgICBvblRyYW5zZm9ybTogXy5pZGVudGl0eVxuICAgIHZpZXdJdGVtOiBwYXBlci52aWV3XG5cbiAgc2V0dXBab29tIHBhcGVyLCB0b29sLCBjYW52YXMsIG9wdGlvbnNcbiAgc2V0dXBQYW4gcGFwZXIsIHRvb2wsIGNhbnZhcywgb3B0aW9uc1xuXG5zZXR1cFpvb20gPSAocGFwZXIsIHRvb2wsIGNhbnZhcywgb3B0aW9ucykgLT5cbiAgem9vbSA9IChhbW91bnQsIHB0KSAtPlxuICAgIGdldFpvb20gPVxuICAgICAgaWYgb3B0aW9ucy52aWV3SXRlbS56b29tP1xuICAgICAgdGhlbiAoKSAtPiBvcHRpb25zLnZpZXdJdGVtLnpvb21cbiAgICAgIGVsc2UgKCkgLT4gb3B0aW9ucy52aWV3SXRlbS5zY2FsaW5nLnhcbiAgICBzZXRab29tID1cbiAgICAgIGlmIG9wdGlvbnMudmlld0l0ZW0uem9vbT9cbiAgICAgIHRoZW4gKGFtdCwgY2VudGVyKSAtPlxuICAgICAgICBzY3JvbGxBbW91bnQgPSBvcHRpb25zLnZpZXdJdGVtLmNlbnRlci5zdWJ0cmFjdCBjZW50ZXJcbiAgICAgICAgb3B0aW9ucy52aWV3SXRlbS5zY3JvbGxCeSBzY3JvbGxBbW91bnRcbiAgICAgICAgem9vbURlbHRhID0gYW10IC8gb3B0aW9ucy52aWV3SXRlbS56b29tXG4gICAgICAgIG9wdGlvbnMudmlld0l0ZW0uem9vbSA9IGFtdFxuICAgICAgICBvcHRpb25zLnZpZXdJdGVtLnNjcm9sbEJ5IHNjcm9sbEFtb3VudC5uZWdhdGUoKS5tdWx0aXBseSB6b29tRGVsdGFcbiAgICAgIGVsc2UgKGFtdCwgY2VudGVyKSAtPlxuICAgICAgICBvcHRpb25zLnZpZXdJdGVtLnNjYWxlIFsxIC8gYW10LCAxIC8gYW10XSwgY2VudGVyXG5cbiAgICBuZXdab29tID0gZ2V0Wm9vbSgpICogYW1vdW50XG4gICAgbmV3Wm9vbSA9IE1hdGgubWF4IChNYXRoLm1pbiBuZXdab29tLCA1KSwgMC41XG5cbiAgICBpZiBuZXdab29tICE9IGdldFpvb20oKVxuICAgICAgc2V0Wm9vbSBuZXdab29tLCBwdFxuICAgICAgZG8gb3B0aW9ucy5vblRyYW5zZm9ybVxuXG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyICdtb3VzZXdoZWVsJywgKGV2dCkgLT5cbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBldnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgaWYgbm90IHBhcGVyLktleS5pc0Rvd24gJ29wdGlvbidcbiAgICAgIG1vdXNlT2Zmc2V0ID0gbmV3IHBhcGVyLlBvaW50IGV2dC5vZmZzZXRYLCBldnQub2Zmc2V0WVxuICAgICAgcHJvak1vdXNlT2Zmc2V0ID0gcGFwZXIudmlldy52aWV3VG9Qcm9qZWN0IG1vdXNlT2Zmc2V0XG5cbiAgICAgIGRlbHRhID0gLWV2dC5kZWx0YVkgLyAxMDAuMFxuICAgICAgZGVsdGEgKj0gMC44XG4gICAgICB6b29tICgxICsgZGVsdGEpLCBwcm9qTW91c2VPZmZzZXRcblxuICBsYXN0WCA9IG51bGxcbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIgJ21vdXNlZG93bicsIChldnQpIC0+XG4gICAgbGFzdFggPSBldnQuY2xpZW50WFxuXG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyICdtb3VzZW1vdmUnLCAoZXZ0KSAtPlxuICAgIG1vdXNlQnV0dG9uRG93biA9IChldnQuYnV0dG9ucyAmIGtMZWZ0TW91c2VGbGFnKSBpcyAxXG4gICAgaWYgbW91c2VCdXR0b25Eb3duIGFuZCBwYXBlci5LZXkuaXNEb3duICdvcHRpb24nXG4gICAgICBtb3VzZU9mZnNldCA9IG5ldyBwYXBlci5Qb2ludCBldnQub2Zmc2V0WCwgZXZ0Lm9mZnNldFlcbiAgICAgIHByb2pNb3VzZU9mZnNldCA9IHBhcGVyLnZpZXcudmlld1RvUHJvamVjdCBtb3VzZU9mZnNldFxuXG4gICAgICBkZWx0YVggPSBldnQuY2xpZW50WCAtIGxhc3RYXG4gICAgICBsYXN0WCA9IGV2dC5jbGllbnRYXG5cbiAgICAgIHpvb20gMSArIDIgKiBkZWx0YVggLyBwYXBlci52aWV3LnZpZXdTaXplLndpZHRoLCBwYXBlci52aWV3LmNlbnRlclxuXG5cbnNldHVwUGFuID0gKHBhcGVyLCB0b29sLCBjYW52YXMsIG9wdGlvbnMpIC0+XG4gIHBhbkluZXJ0aWEgPSBuZXcgcGFwZXIuUG9pbnQgMCwgMFxuICBsYXN0U2Nyb2xsID0gbmV3IHBhcGVyLlBvaW50IDAsIDBcblxuICAjIGlzIHRoaXMgc2lsbHk/XG4gIGxhc3RQb2ludCA9IG51bGxcblxuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lciAnbW91c2Vkb3duJywgKGV2dCkgLT5cbiAgICAjIFRvb2xFdmVudC5wb2ludCBnaXZlcyB1cyB0aGUgcG9pbnQgaW4gcHJvamVjdCBjb29yZGluYXRlc1xuICAgICMgbGFzdFBvaW50ID0gcGFwZXIudmlldy5wcm9qZWN0VG9WaWV3IGV2dC5wb2ludFxuICAgIGxhc3RQb2ludCA9IG5ldyBwYXBlci5Qb2ludCBldnQub2Zmc2V0WCwgZXZ0Lm9mZnNldFlcblxuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lciAnbW91c2Vtb3ZlJywgKGV2dCkgLT5cbiAgICBtb3VzZUJ1dHRvbkRvd24gPSAoZXZ0LmJ1dHRvbnMgJiBrTGVmdE1vdXNlRmxhZykgaXMgMVxuICAgIGlmIG1vdXNlQnV0dG9uRG93biBhbmQgbm90IHBhcGVyLktleS5pc0Rvd24gJ29wdGlvbidcbiAgICAgIHB0ID0gbmV3IHBhcGVyLlBvaW50IGV2dC5vZmZzZXRYLCBldnQub2Zmc2V0WVxuICAgICAgdmlld0RlbHRhID0gbGFzdFBvaW50LnN1YnRyYWN0IHB0XG4gICAgICBwYW5JbmVydGlhID0gdmlld0RlbHRhLm11bHRpcGx5ICgxIC8gcGFwZXIudmlldy56b29tKVxuICAgICAgbGFzdFBvaW50ID0gcHRcblxuICB0b29sLm9uICdtb3VzZWRvd24nLCAoZXZ0KSAtPlxuICAgIHBhbkluZXJ0aWEgPSBuZXcgcGFwZXIuUG9pbnQgMCwgMFxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICdmb2N1cycsICgpIC0+XG4gICAgcGFuSW5lcnRpYSA9IG5ldyBwYXBlci5Qb2ludCAwLCAwXG5cbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIgJ21vdXNld2hlZWwnLCAoZXZ0KSAtPlxuICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgaWYgcGFwZXIuS2V5LmlzRG93biAnb3B0aW9uJ1xuICAgICAgZGVsdGEgPSBuZXcgcGFwZXIuUG9pbnQgZXZ0LmRlbHRhWCwgZXZ0LmRlbHRhWVxuICAgICAgZGVsdGEgPSBkZWx0YS5tdWx0aXBseSAoMSAvIHBhcGVyLnZpZXcuem9vbSlcbiAgICAgIHBhbkluZXJ0aWEgPSBkZWx0YVxuXG4gIGRlY2F5ID0gMC44XG5cbiAgc2V0Q2VudGVyID1cbiAgICBpZiBvcHRpb25zLnZpZXdJdGVtLmNlbnRlcj9cbiAgICB0aGVuIChwdCkgLT4gb3B0aW9ucy52aWV3SXRlbS5jZW50ZXIgPSBwdFxuICAgIGVsc2UgKHB0KSAtPlxuICAgICAgZGVsdGEgPSBvcHRpb25zLnZpZXdJdGVtLnBvc2l0aW9uLnN1YnRyYWN0IHB0XG4gICAgICBvcHRpb25zLnZpZXdJdGVtLnBvc2l0aW9uID0gZGVsdGEuYWRkIG9wdGlvbnMudmlld0l0ZW0ucG9zaXRpb25cbiAgZ2V0Q2VudGVyID1cbiAgICBpZiBvcHRpb25zLnZpZXdJdGVtLmNlbnRlcj9cbiAgICB0aGVuICgpIC0+IG9wdGlvbnMudmlld0l0ZW0uY2VudGVyXG4gICAgZWxzZSAoKSAtPiBvcHRpb25zLnZpZXdJdGVtLnBvc2l0aW9uXG5cbiAgcGFwZXIudmlldy5vbiAnZnJhbWUnLCAoZXZ0KSAtPlxuICAgIGlmIHBhbkluZXJ0aWEubGVuZ3RoID4gMC4wMVxuICAgICAgIyBvcHRpb25zLnZpZXdJdGVtLmNlbnRlciA9IG9wdGlvbnMudmlld0l0ZW0uY2VudGVyLmFkZCBwYW5JbmVydGlhXG4gICAgICBzZXRDZW50ZXIgKGdldENlbnRlcigpLmFkZCBwYW5JbmVydGlhKVxuICAgICAgaWYgbm90IHBhcGVyLktleS5pc0Rvd24gJ29wdGlvbidcbiAgICAgICAgIyBwYW5JbmVydGlhID0gcGFuSW5lcnRpYS5tdWx0aXBseSAoNjAgKiBkZWNheSAqIGV2dC5kZWx0YSlcbiAgICAgICAgZGVsdGEgPSAocGFuSW5lcnRpYS5tdWx0aXBseSBkZWNheSkuc3VidHJhY3QgcGFuSW5lcnRpYVxuICAgICAgICBkZWx0YS5tdWx0aXBseSBldnQuZGVsdGFcbiAgICAgICAgcGFuSW5lcnRpYSA9IHBhbkluZXJ0aWEuYWRkIGRlbHRhXG4gICAgICBkbyBvcHRpb25zLm9uVHJhbnNmb3JtIiwiXyA9IHJlcXVpcmUgJ2xvZGFzaCdcblBhcGVyID0gcmVxdWlyZSAncGFwZXInXG5cbmNsYXNzIEluZmluaXRlVGlsZWRJdGVtIGV4dGVuZHMgUGFwZXIuR3JvdXBcbiAgY29uc3RydWN0b3I6IChAcGFwZXIsIGJhc2VJdGVtLCBvcHRpb25zID0ge30pIC0+XG4gICAgc3VwZXIgW11cblxuICAgIEBfb3B0aW9ucyA9IF8uZGVmYXVsdHMgb3B0aW9ucyxcbiAgICAgIHZpZXdCb3VuZHM6IEBwYXBlci52aWV3LmJvdW5kc1xuICAgICAgb3JpZ2luOiBuZXcgQHBhcGVyLlBvaW50IDAsIDBcbiAgICAgIG92ZXJsYXA6IG5ldyBAcGFwZXIuUG9pbnQgMCwgMFxuXG4gICAgQF9zeW1ib2wgPSBuZXcgQHBhcGVyLlN5bWJvbCBiYXNlSXRlbVxuXG4gIHNldE9yaWdpbjogKHB0KSAtPlxuICAgIEBfb3B0aW9ucy5vcmlnaW4gPSBwdFxuICAgIEBfdXBkYXRlSW5zdGFuY2VzKClcblxuICAjIFNldHMgdGhlIG5ldyB2aWV3cG9ydCBib3VuZHMsIGFuZCByZWFycmFuZ2VzIGluc3RhbmNlcyB0byBmaWxsIHRoYXQgYm91bmRzLlxuICBzZXRWaWV3Qm91bmRzOiAobmV3Qm91bmRzKSAtPlxuICAgIEBfb3B0aW9ucy52aWV3Qm91bmRzID0gbmV3Qm91bmRzXG4gICAgQF91cGRhdGVJbnN0YW5jZXMoKVxuXG4gIF91cGRhdGVJbnN0YW5jZXM6ICgpIC0+XG4gICAgQHJlbW92ZUNoaWxkcmVuKClcblxuICAgIHN5bWJvbFNpemUgPSBAX3N5bWJvbC5kZWZpbml0aW9uLmJvdW5kcy5zaXplXG5cbiAgICBkaW1XaXRoT3ZlcmxhcCA9XG4gICAgICB3aWR0aDogc3ltYm9sU2l6ZS53aWR0aCAqICgxICsgQF9vcHRpb25zLm92ZXJsYXAueClcbiAgICAgIGhlaWdodDogc3ltYm9sU2l6ZS5oZWlnaHQgKiAoMSArIEBfb3B0aW9ucy5vdmVybGFwLnkpXG4gICAgdGlsZVJhbmdlWCA9XG4gICAgICBsZWZ0OiBNYXRoLmZsb29yKChAX29wdGlvbnMudmlld0JvdW5kcy5sZWZ0IC0gQF9vcHRpb25zLm9yaWdpbi54KSAvIGRpbVdpdGhPdmVybGFwLndpZHRoKVxuICAgICAgcmlnaHQ6IE1hdGguY2VpbCgoQF9vcHRpb25zLnZpZXdCb3VuZHMucmlnaHQgLSBAX29wdGlvbnMub3JpZ2luLngpIC8gZGltV2l0aE92ZXJsYXAud2lkdGgpXG4gICAgdGlsZVJhbmdlWSA9XG4gICAgICB0b3A6IE1hdGguZmxvb3IoKEBfb3B0aW9ucy52aWV3Qm91bmRzLnRvcCAtIEBfb3B0aW9ucy5vcmlnaW4ueSkgLyBkaW1XaXRoT3ZlcmxhcC5oZWlnaHQpXG4gICAgICBib3R0b206IE1hdGguY2VpbCgoQF9vcHRpb25zLnZpZXdCb3VuZHMuYm90dG9tIC0gQF9vcHRpb25zLm9yaWdpbi55KSAvIGRpbVdpdGhPdmVybGFwLmhlaWdodClcblxuXG4gICAgZm9yIHggaW4gW3RpbGVSYW5nZVgubGVmdC4udGlsZVJhbmdlWC5yaWdodF1cbiAgICAgIGZvciB5IGluIFt0aWxlUmFuZ2VZLnRvcC4udGlsZVJhbmdlWS5ib3R0b21dXG4gICAgICAgIHBvc2l0aW9uID0gbmV3IEBwYXBlci5Qb2ludCBcXFxuICAgICAgICAgIHggKiBkaW1XaXRoT3ZlcmxhcC53aWR0aCArIEBfb3B0aW9ucy5vcmlnaW4ueCxcbiAgICAgICAgICB5ICogZGltV2l0aE92ZXJsYXAuaGVpZ2h0ICsgQF9vcHRpb25zLm9yaWdpbi55XG4gICAgICAgIEBhZGRDaGlsZCAoQF9zeW1ib2wucGxhY2UgcG9zaXRpb24sIHRydWUpXG5cblxubW9kdWxlLmV4cG9ydHMgPSBJbmZpbml0ZVRpbGVkSXRlbSIsIl8gPSByZXF1aXJlICdsb2Rhc2gnXG5cbiMgbWFrZVJhbmRvbVBhdGggPSAoYm91bmRzID0ge30sIG1heFNlZ21lbnRzID0gMTApIC0+XG4jICAgYm91bmRzID0gXy5kZWZhdWx0cyBib3VuZHMsXG4jICAgICBsZWZ0OiAwXG4jICAgICB0b3A6IDBcbiMgICAgIHdpZHRoOiAxMDBcbiMgICAgIGhlaWdodDogMTAwXG5cbiMgICBzZWdtZW50cyA9IFswLi4ubWF4U2VnbWVudHNdXG4jICAgICAubWFwIChpZHgpIC0+XG4jICAgICAgIFtNYXRoLnJhbmRvbSgpICogYm91bmRzLndpZHRoICsgYm91bmRzLmxlZnQsXG4jICAgICAgICBNYXRoLnJhbmRvbSgpICogYm91bmRzLmhlaWdodCArIGJvdW5kcy50b3BdXG4jICAgICAubWFwIChhbmNob3IsIGlkeCwgYXJyYXkpIC0+XG4jICAgICAgIGwgPSBhcnJheS5sZW5ndGhcbiMgICAgICAgcHJldmlvdXMgPSBhcnJheVsoaWR4ICsgbCAtIDEpICUgbF1cbiMgICAgICAgbmV4dCA9IGFycmF5WyhsICsgMSkgJSBsXVxuXG5cbiMgICAgICAgcDJuID0gbmV3IGZhYnJpYy5Qb2ludCBcXFxuIyAgICAgICAgIChuZXh0WzBdIC0gcHJldmlvdXNbMF0pLFxuIyAgICAgICAgIChuZXh0WzFdIC0gcHJldmlvdXNbMV0pXG5cbiMgICAgICAgc21vb3RoID0gTWF0aC5yYW5kb20oKVxuXG4jICAgICAgIGFuY2hvcjogYW5jaG9yXG4jICAgICAgIGhhbmRsZUluOiBwMm4ubXVsdGlwbHkgc21vb3RoXG4jICAgICAgIGhhbmRsZU91dDogcDJuLm11bHRpcGx5IC1zbW9vdGhcblxuIyAgICMgY3VydmVzID0gc2VnbWVudHMubWFwIChzZWdtZW50LCBpZHgsIGFycmF5KSAtPlxuIyAgICMgICBpZiBpZHggaXMgKGFycmF5Lmxlbmd0aCAtIDEpXG4jICAgIyAgICAgcmV0dXJuXG4jICAgIyAgIGVsc2VcbiMgICAjICAgICByZXR1cm4gbmV3IHBhcGVyLkN1cnZlIFxcXG4jICAgIyAgICAgICBzZWdtZW50LFxuIyAgICMgICAgICAgYXJyYXlbaWR4ICsgMV1cblxuIyAgIHN2Z1JlZHVjdGlvbiA9IChhY2MsIGVsbSwgaWR4KSAtPlxuIyAgICAgaWYgaWR4IGlzIDBcbiMgICAgICAgYWNjICs9IFwiTSAje2VsbS5hbmNob3JbMF19ICN7ZWxtLmFuY2hvclsxXX1cIlxuIyAgICAgZWxzZVxuIyAgICAgICBhY2MgKz0gXCIgTCAje2VsbS5hbmNob3JbMF19ICN7ZWxtLmFuY2hvclsxXX1cIlxuIyAgIHN2Z1BhdGhTdHJpbmcgPSBzZWdtZW50cy5yZWR1Y2Ugc3ZnUmVkdWN0aW9uLCAnJ1xuIyAgIHN2Z1BhdGhTdHJpbmcgKz0gJyB6J1xuXG4jICAgY29uc29sZS5sb2cgc3ZnUGF0aFN0cmluZ1xuXG4jICAgcmV0dXJuIG5ldyBmYWJyaWMuUGF0aCBzdmdQYXRoU3RyaW5nXG5cbm1ha2VSYW5kb21QYXRoID0gKHBhcGVyLCBib3VuZHMgPSB7fSwgbWF4U2VnbWVudHMgPSA1KSAtPlxuICBib3VuZHMgPSBfLmRlZmF1bHRzIGJvdW5kcyxcbiAgICBsZWZ0OiAwXG4gICAgdG9wOiAwXG4gICAgd2lkdGg6IDEwMFxuICAgIGhlaWdodDogMTAwXG5cbiAgc2VnbWVudHMgPSBbMC4uLm1heFNlZ21lbnRzXVxuICAgIC5tYXAgKGlkeCkgLT5cbiAgICAgIFtNYXRoLnJhbmRvbSgpICogYm91bmRzLndpZHRoICsgYm91bmRzLmxlZnQsXG4gICAgICAgTWF0aC5yYW5kb20oKSAqIGJvdW5kcy5oZWlnaHQgKyBib3VuZHMudG9wXVxuICAgIC5tYXAgKGFuY2hvciwgaWR4LCBhcnJheSkgLT5cbiAgICAgIGwgPSBhcnJheS5sZW5ndGhcbiAgICAgIHByZXZpb3VzID0gYXJyYXlbKGlkeCArIGwgLSAxKSAlIGxdXG4gICAgICBuZXh0ID0gYXJyYXlbKGwgKyAxKSAlIGxdXG5cbiAgICAgIHAybiA9IG5ldyBwYXBlci5Qb2ludCBcXFxuICAgICAgICAobmV4dFswXSAtIHByZXZpb3VzWzBdKSxcbiAgICAgICAgKG5leHRbMV0gLSBwcmV2aW91c1sxXSlcblxuICAgICAgc21vb3RoRmFjdG9yID0gTWF0aC5yYW5kb20oKVxuXG4gICAgICByZXR1cm4gbmV3IHBhcGVyLlNlZ21lbnRcbiAgICAgICAgcG9pbnQ6IGFuY2hvclxuICAgICAgICBoYW5kbGVJbjogcDJuLm11bHRpcGx5IHNtb290aEZhY3RvclxuICAgICAgICBoYW5kbGVPdXQ6IHAybi5tdWx0aXBseSAtc21vb3RoRmFjdG9yXG5cbiAgY3VydmVzID0gc2VnbWVudHMubWFwIChzZWdtZW50LCBpZHgsIGFycmF5KSAtPlxuICAgIGlmIGlkeCBpcyAoYXJyYXkubGVuZ3RoIC0gMSlcbiAgICAgIHJldHVyblxuICAgIGVsc2VcbiAgICAgIHJldHVybiBuZXcgcGFwZXIuQ3VydmUgXFxcbiAgICAgICAgc2VnbWVudCxcbiAgICAgICAgYXJyYXlbaWR4ICsgMV1cblxuXG4gIHJldHVybiBuZXcgcGFwZXIuUGF0aFxuICAgIHNlZ21lbnRzOiBzZWdtZW50c1xuICAgIGN1cnZlczogY3VydmVzXG4gICAgY2xvc2VkOiB0cnVlXG5cblxubW9kdWxlLmV4cG9ydHMgPSBtYWtlUmFuZG9tUGF0aCIsIlBhcGVyID0gcmVxdWlyZSAncGFwZXInXG5fID0gcmVxdWlyZSAnbG9kYXNoJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmRvbUNvbG9yID0gKG9wdGlvbnMgPSB7fSwgcGFwZXIgPSBQYXBlcikgLT5cbiAgb3B0aW9ucyA9IF8uZGVmYXVsdHMgb3B0aW9ucyxcbiAgICBodWU6IE1hdGgucmFuZG9tKCkgKiAzNjBcbiAgICBzYXR1cmF0aW9uOiBNYXRoLnJhbmRvbSgpXG4gICAgYnJpZ2h0bmVzczogTWF0aC5yYW5kb20oKVxuXG4gIG5ldyBwYXBlci5Db2xvciBvcHRpb25zIiwiXyA9IHJlcXVpcmUgJ2xvZGFzaCdcblxubW9kdWxlLmV4cG9ydHMgPSBtYWtlVGlsZWRJdGVtID0gKHBhcGVyLCBiYXNlSXRlbSwgb3B0aW9ucyA9IHt9KSAtPlxuICBvcHRpb25zID0gXy5kZWZhdWx0cyBvcHRpb25zLFxuICAgIHBvc2l0aW9uOiBiYXNlSXRlbS5wb3NpdGlvblxuICAgIHdpZHRoSW5UaWxlczogNVxuICAgIGhlaWdodEluVGlsZXM6IDVcbiAgICByZW1vdmVPcmlnaW5hbDogZmFsc2VcbiAgICBvbkluc3RhbmNlOiBfLmlkZW50aXR5XG4gICAgZ3JvdXA6IG5ldyBwYXBlci5Hcm91cCgpXG5cbiAgaWYgbm90IG9wdGlvbnMucmFuZG9tP1xuICAgIG9wdGlvbnMucmFuZG9tID0ge31cbiAgb3B0aW9ucy5yYW5kb20gPSBfLmRlZmF1bHRzIG9wdGlvbnMucmFuZG9tLFxuICAgIHg6IDBcbiAgICB5OiAwXG5cbiAgc3ltYm9sID0gbmV3IHBhcGVyLlN5bWJvbCBiYXNlSXRlbVxuXG4gIGlmIG9wdGlvbnMucmVtb3ZlT3JpZ2luYWxcbiAgICBkbyBiYXNlSXRlbS5yZW1vdmVcblxuXG4gIGZvciB4IGluIFswLi4ub3B0aW9ucy53aWR0aEluVGlsZXNdXG4gICAgZm9yIHkgaW4gWzAuLi5vcHRpb25zLmhlaWdodEluVGlsZXNdXG4gICAgICBpbnN0YW5jZSA9IGRvIHN5bWJvbC5wbGFjZVxuICAgICAgb2Zmc2V0ID0gbmV3IHBhcGVyLlBvaW50IFxcXG4gICAgICAgIHN5bWJvbC5kZWZpbml0aW9uLmJvdW5kcy53aWR0aCAqIHgsXG4gICAgICAgIHN5bWJvbC5kZWZpbml0aW9uLmJvdW5kcy5oZWlnaHQgKiB5XG4gICAgICBvZmZzZXQgPSBvZmZzZXQuYWRkIFtNYXRoLnJhbmRvbSgpICogKG9wdGlvbnMucmFuZG9tLnggKiAyKSAtIG9wdGlvbnMucmFuZG9tLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJhbmRvbSgpICogKG9wdGlvbnMucmFuZG9tLnkgKiAyKSAtIG9wdGlvbnMucmFuZG9tLnldXG4gICAgICBpbnN0YW5jZS5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb24uYWRkIG9mZnNldFxuXG4gICAgICBpbnN0YW5jZSA9IG9wdGlvbnMub25JbnN0YW5jZSBpbnN0YW5jZVxuICAgICAgb3B0aW9ucy5ncm91cC5hZGRDaGlsZCBpbnN0YW5jZVxuXG4gIHJldHVybiBvcHRpb25zLmdyb3VwIl19
